#ifndef PROGRESSIVEPIP_H_
#define PROGRESSIVEPIP_H_

template <class ALPHABET>
struct ProgressivePIPResult;

#include <string>
#include <map>
#include <vector>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <algorithm>
#include "Alphabet.h"
#include "PhyTree.h"
#include "ModelFactory.h"
#include "debug.h"
#include "Sequence.h"
#include <Eigen/Dense>
#include <random>

#include <set>


#include <Eigen/Sparse>

//#include <ext/hash_map>
//#include "uthash.h"

#define ERR_STATE 0
#define MATCH_STATE 1
#define GAP_X_STATE 2
#define GAP_Y_STATE 3
#define STOP_STATE 4

#include <chrono>

//#define VERBOSE

const std::string my_dna_alphabet[5] = {"T","C","A","G","-"};

//const char my_aa_alphabet[21] = { 'A', 'C', 'D', 'E', 'F', 'G', 'H',
//		'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', '-' };
//
//const char my_codon_alphabet[63] = {
//		"FFLLSSSSYYCCWLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG-" };

const char mytable[256] = { -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 2, -1, 1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, 0, 0, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 1,
		-1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0,
		-1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };



template <class ALPHABET>
struct ProgressivePIPResult{
	std::vector<std::pair<std::string,sequence_t<ALPHABET>>> MSA;
	std::vector< std::pair<std::string,std::string> > MSAs;
	sequence_t<ALPHABET> traceback_path;
	score_t score;
	Eigen::VectorXd Pc;
	std::map<std::string,Eigen::VectorXd> fv_map;
	double lk_gap;
	double pc0;
};

class ProgressivePIPException : public swps3_exception {
public:
	ProgressivePIPException(std::string msg) : swps3_exception(msg) {}
};

template <class ALPHABET>
ProgressivePIPResult<ALPHABET> compute_DP_PIP_tree(PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,std::ostream& fileTr) throw (ProgressivePIPException);

template <class ALPHABET>
ProgressivePIPResult<ALPHABET> compute_DP_PIP_tree_fast(PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,Eigen::MatrixXd &matFv,std::ostream& fileTr) throw (ProgressivePIPException);



double compute_nu(double tau,double lambda,double mu);


template <class T>
void sort(std::vector<T> &unsorted,std::vector<T> &sorted,std::vector<size_t> &index_map);

template< class T >
void reorder(std::vector<T> & unordered,std::vector<size_t> const & index_map,std::vector<T> & ordered);



/*
 *  ___                 _                           _        _   _
 * |_ _|_ __ ___  _ __ | | ___ _ __ ___   ___ _ __ | |_ __ _| |_(_) ___  _ __
 *  | || '_ ` _ \| '_ \| |/ _ \ '_ ` _ \ / _ \ '_ \| __/ _` | __| |/ _ \| '_ \
 *  | || | | | | | |_) | |  __/ | | | | |  __/ | | | || (_| | |_| | (_) | | | |
 * |___|_| |_| |_| .__/|_|\___|_| |_| |_|\___|_| |_|\__\__,_|\__|_|\___/|_| |_|
 *               |_|
 */

//=======================================================================================================
//DP-PIP
// Comparison struct used by sort
// http://bytes.com/topic/c/answers/132045-sort-get-index
template<class T> struct index_cmp{
  index_cmp(const T arr) : arr(arr) {}
  bool operator()(const size_t a, const size_t b) const
  {
    return arr[a] > arr[b];
  }
  const T arr;
};
//=======================================================================================================
//DP-PIP
template <class T>
void sort(std::vector<T> & unsorted,std::vector<T> & sorted,std::vector<size_t> & index_map){
  //Original unsorted index map
  index_map.resize(unsorted.size());
  for(size_t i=0;i<unsorted.size();i++){
    index_map[i] = i;
  }
  // Sort the index map, using unsorted for comparison
  sort(index_map.begin(),index_map.end(),index_cmp<std::vector<T>& >(unsorted));

  sorted.resize(unsorted.size());
  reorder(unsorted,index_map,sorted);

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void reorderProgressivePIPResult(std::vector<ProgressivePIPResult<ALPHABET>> &subopt,std::vector<size_t> const & index_map){
	// copy for the reorder according to index_map, because unsorted may also be
	// sorted
	// This implementation is O(n), but also uses O(n) extra memory
	std::vector<ProgressivePIPResult<ALPHABET>> copy = subopt;
	//ordered.resize(index_map.size());
	for(unsigned int i = 0; i<index_map.size();i++){
		subopt[i] = copy[index_map[i]];
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void sortProgressivePIPResult(std::vector<ProgressivePIPResult<ALPHABET>> &subopt){
	std::vector<size_t> index_map;
	std::vector<score_t> scores;

	//Original unsorted index map
	index_map.resize(subopt.size());
	scores.resize(subopt.size());

	for(size_t i=0;i<subopt.size();i++){
		index_map[i] = i;
		scores[i]=subopt.at(i).score;
	}

	// Sort the index map, using unsorted for comparison
	sort(index_map.begin(),index_map.end(),index_cmp<std::vector<score_t>& >(scores));

	//sorted.resize(unsorted.size());
	reorderProgressivePIPResult(subopt,index_map);


	//============================================
	//std::cout<<"-----------------------------\n";
	//for(int i=0;i<index_map.size();i++){
	//	std::cout<<index_map[i]<<"\n";
	//}
	//============================================


}
//=======================================================================================================
//DP-PIP
// This implementation is O(n), but also uses O(n) extra memory
template< class T >
void reorder(std::vector<T> & unordered,std::vector<size_t> const & index_map,std::vector<T> & ordered){
  // copy for the reorder according to index_map, because unsorted may also be
  // sorted
  std::vector<T> copy = unordered;
  ordered.resize(index_map.size());
  for(unsigned int i = 0; i<index_map.size();i++){
    ordered[i] = copy[index_map[i]];
  }

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void check_sequences_tree(PhyTree &tree,const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences){

	if(tree.isLeaf()){

		const std::string name = tree.getName();

		typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>> ::const_iterator vect_iter;
		vect_iter it = std::find_if(sequences.begin(),sequences.end(),CompareFirst<ALPHABET>(name));


		if (it == sequences.end()){
			error("ERROR sequence name doesn't match any tree leaf");
			exit(EXIT_FAILURE);
		}

	}else{

		check_sequences_tree<ALPHABET>(tree[0],sequences);
		check_sequences_tree<ALPHABET>(tree[1],sequences);

	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static sequence_t<ALPHABET> alignment_reconstruction(Eigen::MatrixXi TR,int MSA_len){
	sequence_t<ALPHABET> extended(MSA_len,ALPHABET::unknow);

	int id1=TR.rows()-1;
	int id2=TR.cols()-1;

	for(int i=MSA_len-1;i>=0;i--){
	    switch(TR(id1,id2)){
	        case MATCH_STATE:
	            id1=id1-1;
	            id2=id2-1;
	            extended[i]=ALPHABET::match;
	            break;
	        case GAP_X_STATE:
	            id1=id1-1;
	            extended[i]=ALPHABET::gapX;
	            break;
	        case GAP_Y_STATE:
	            id2=id2-1;
	            extended[i]=ALPHABET::gapY;
	            break;
	        default:
	            error("ERROR in alignment_reconstruction");
	            exit(EXIT_FAILURE);
	    }
	}

	return extended;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static sequence_t<ALPHABET> create_col_MSA_gap(std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &result){

	if(!check_uniform_len(result)){
		error("ERROR in create_col_MSA: non aligned");
	}

	sequence_t<ALPHABET> colMSA(result.size(),ALPHABET::GAP);

	return colMSA;
}
//=======================================================================================================
//DP-PIP
std::string create_col_MSA_gap_s(int len){

	std::string colMSA (len,'-');

	return colMSA;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static sequence_t<ALPHABET> create_col_MSA(std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &result,int index){
	sequence_t<ALPHABET> colMSA;

	if(!check_uniform_len(result)){
		error("ERROR in create_col_MSA: non aligned");
	}

	for(unsigned int i=0;i<result.size();i++){
		colMSA.append(result.at(i).second,index,1);
	}

	return colMSA;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
std::string create_col_MSA_s(std::vector<std::pair<std::string,std::string>> &result,int index){
	std::string colMSA;

//	if(!check_uniform_len_s<ALPHABET>(result)){
//		error("ERROR in create_col_MSA: non aligned");
//	}

	for(unsigned int i=0;i<result.size();i++){
		colMSA.append(result.at(i).second,index,1);
	}

	return colMSA;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void align_seq_left(std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &result,sequence_t<ALPHABET> &anc_seq){
	unsigned int idx;

	typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>>::iterator vect_iterator;
	for (vect_iterator iter = result.begin(); iter != result.end(); iter++){

		std::pair<std::string,sequence_t<ALPHABET>> seq = (*iter);
		sequence_t<ALPHABET> seq_not_aligned=seq.second;
		sequence_t<ALPHABET> seq_aligned(anc_seq.size(),ALPHABET::X);

		/*
		std::cout<<".....................\n";
		std::cout<<stringFromSequence(anc_seq)<<"\n";
		std::cout<<stringFromSequence(seq_not_aligned)<<"\n";
		std::cout<<stringFromSequence(seq_aligned)<<"\n";
		std::cout<<".....................\n";
		*/

		idx=0;
		for(unsigned int j=0;j<anc_seq.size();j++){

			if(anc_seq.at(j)==ALPHABET::match){

				seq_aligned[j]=seq_not_aligned.at(idx);
				idx++;

			}else if(anc_seq.at(j)==ALPHABET::gapX){

					seq_aligned[j]=seq_not_aligned.at(idx);
					idx++;

			}else if(anc_seq.at(j)==ALPHABET::gapY){

					seq_aligned[j]=ALPHABET::GAP;

			}else{
					error("ERROR in align_seq");
			}
		}

		*(iter)=std::make_pair(seq.first,seq_aligned);
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void align_seq_left_s(std::vector<std::pair<std::string,std::string>> &result,sequence_t<ALPHABET> &traceback_path){
	unsigned int idx;

	typedef typename std::vector<std::pair<std::string,std::string>>::iterator vect_iterator;
	for (vect_iterator iter = result.begin(); iter != result.end(); iter++){

		std::pair<std::string,std::string> seq = (*iter);
		std::string seq_not_aligned=seq.second;
		std::string seq_aligned(traceback_path.size(),'-');

		idx=0;
		for(unsigned int j=0;j<traceback_path.size();j++){

			if(traceback_path.at(j)==ALPHABET::match){

				seq_aligned[j]=seq_not_aligned.at(idx);
				idx++;

			}else if(traceback_path.at(j)==ALPHABET::gapX){

					seq_aligned[j]=seq_not_aligned.at(idx);
					idx++;

			}else if(traceback_path.at(j)==ALPHABET::gapY){

					seq_aligned[j]='-';

			}else{
					error("ERROR in align_seq");
			}
		}

		*(iter)=std::make_pair(seq.first,seq_aligned);
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
std::vector<std::pair<std::string,std::string>> align_seq_left_s_v2(	std::vector<std::pair<std::string,std::string>> &MSA_in,
																	sequence_t<ALPHABET> &traceback_path){

	unsigned int idx;

	std::vector<std::pair<std::string,std::string>> MSA_out;

	typedef typename std::vector<std::pair<std::string,std::string>>::iterator vect_iterator;
	for (vect_iterator iter = MSA_in.begin(); iter != MSA_in.end(); iter++){

		std::pair<std::string,std::string> seq = (*iter);

		std::string seq_name=seq.first;
		std::string seq_not_aligned=seq.second;
		std::string seq_aligned(traceback_path.size(),'-');

		idx=0;
		for(unsigned int j=0;j<traceback_path.size();j++){

			if(traceback_path.at(j)==ALPHABET::match){

				seq_aligned[j]=seq_not_aligned.at(idx);
				idx++;

			}else if(traceback_path.at(j)==ALPHABET::gapX){

					seq_aligned[j]=seq_not_aligned.at(idx);
					idx++;

			}else if(traceback_path.at(j)==ALPHABET::gapY){

					seq_aligned[j]='-';

			}else{
					error("ERROR in align_seq");
			}
		}

		MSA_out.push_back(std::make_pair(seq_name,seq_aligned));
	}

	return MSA_out;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void align_seq_right(std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &result,sequence_t<ALPHABET> &anc_seq){
	unsigned int idx;

	typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>>::iterator vect_iterator;
	for (vect_iterator iter = result.begin(); iter != result.end(); iter++){

		std::pair<std::string,sequence_t<ALPHABET>> seq = (*iter);
		sequence_t<ALPHABET> seq_not_aligned=seq.second;
		sequence_t<ALPHABET> seq_aligned(anc_seq.size(),ALPHABET::X);

		idx=0;
		for(unsigned int j=0;j<anc_seq.size();j++){

			if(anc_seq.at(j)==ALPHABET::match){

				seq_aligned[j]=seq_not_aligned.at(idx);
				idx++;

			}else if(anc_seq.at(j)==ALPHABET::gapX){

					seq_aligned[j]=ALPHABET::GAP;

			}else if(anc_seq.at(j)==ALPHABET::gapY){

				seq_aligned[j]=seq_not_aligned.at(idx);
					idx++;

			}else{
					error("ERROR in align_seq");
			}
		}

		*(iter)=std::make_pair(seq.first,seq_aligned);
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void align_seq_right_s(std::vector<std::pair<std::string,std::string>> &result,sequence_t<ALPHABET> &traceback_path){
	unsigned int idx;

	typedef typename std::vector<std::pair<std::string,std::string>>::iterator vect_iterator;
	for (vect_iterator iter = result.begin(); iter != result.end(); iter++){

		std::pair<std::string,std::string> seq = (*iter);
		std::string seq_not_aligned=seq.second;
		std::string seq_aligned(traceback_path.size(),'-');

		idx=0;
		for(unsigned int j=0;j<traceback_path.size();j++){

			if(traceback_path.at(j)==ALPHABET::match){

				seq_aligned[j]=seq_not_aligned.at(idx);
				idx++;

			}else if(traceback_path.at(j)==ALPHABET::gapX){

					seq_aligned[j]='-';

			}else if(traceback_path.at(j)==ALPHABET::gapY){

				seq_aligned[j]=seq_not_aligned.at(idx);
					idx++;

			}else{
					error("ERROR in align_seq");
			}
		}

		*(iter)=std::make_pair(seq.first,seq_aligned);
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
std::vector<std::pair<std::string,std::string>> align_seq_right_s_v2(	std::vector<std::pair<std::string,std::string>> &result,
																																		sequence_t<ALPHABET> &traceback_path){
	unsigned int idx;

	std::vector<std::pair<std::string,std::string>> MSA_out;

	typedef typename std::vector<std::pair<std::string,std::string>>::iterator vect_iterator;
	for (vect_iterator iter = result.begin(); iter != result.end(); iter++){

		std::pair<std::string,std::string> seq = (*iter);

		std::string seq_name=seq.first;
		std::string seq_not_aligned=seq.second;
		std::string seq_aligned(traceback_path.size(),'-');

		idx=0;
		for(unsigned int j=0;j<traceback_path.size();j++){

			if(traceback_path.at(j)==ALPHABET::match){

				seq_aligned[j]=seq_not_aligned.at(idx);
				idx++;

			}else if(traceback_path.at(j)==ALPHABET::gapX){

					seq_aligned[j]='-';

			}else if(traceback_path.at(j)==ALPHABET::gapY){

				seq_aligned[j]=seq_not_aligned.at(idx);
					idx++;

			}else{
					error("ERROR in align_seq");
			}
		}

		MSA_out.push_back(std::make_pair(seq_name,seq_aligned));
	}

	return MSA_out;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static std::vector<std::pair<std::string,sequence_t<ALPHABET>>> build_MSA_PIP(sequence_t<ALPHABET> ancestral,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &MSA_L,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &MSA_R){
	std::vector<std::pair<std::string,sequence_t<ALPHABET>>> MSA;

	//std::cout<<"ancestral: "<<stringFromSequence(ancestral)<<"\n";

	//std::cout<<"aligning left...\n";

	align_seq_left(MSA_L,ancestral);

	//std::cout<<"MSA_L:\n";
	//PrintVector(MSA_L);


	//std::cout<<"aligning right...\n";

	align_seq_right(MSA_R,ancestral);


	//std::cout<<"MSA_R:\n";
	//PrintVector(MSA_R);

	//std::cout<<"push left...\n";

	for (unsigned int i=0;i<MSA_L.size();i++){
		MSA.push_back(MSA_L.at(i));
	}

	//std::cout<<"push right...\n";

	for (unsigned int i=0;i<MSA_R.size();i++){
		MSA.push_back(MSA_R.at(i));
	}

	return MSA;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static std::vector<std::pair<std::string,std::string>> build_MSA_PIP_s(sequence_t<ALPHABET> traceback_path,std::vector<std::pair<std::string,std::string>> &MSA_L,std::vector<std::pair<std::string,std::string>> &MSA_R){
//	std::vector<std::pair<std::string,std::string>> MSA;
//
//	align_seq_left_s(MSA_L,traceback_path);
//	align_seq_right_s(MSA_R,traceback_path);
//
//	for (unsigned int i=0;i<MSA_L.size();i++){
//		MSA.push_back(MSA_L.at(i));
//	}
//
//	for (unsigned int i=0;i<MSA_R.size();i++){
//		MSA.push_back(MSA_R.at(i));
//	}
//
//	return MSA;

	std::vector<std::pair<std::string,std::string>> MSA;
	std::vector<std::pair<std::string,std::string>> MSA_L_out;
	std::vector<std::pair<std::string,std::string>> MSA_R_out;

	MSA_L_out=align_seq_left_s_v2(MSA_L,traceback_path);
	MSA_R_out=align_seq_right_s_v2(MSA_R,traceback_path);

	for (unsigned int i=0;i<MSA_L_out.size();i++){
		MSA.push_back(MSA_L_out.at(i));
	}

	for (unsigned int i=0;i<MSA_R_out.size();i++){
		MSA.push_back(MSA_R_out.at(i));
	}

	return MSA;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static Eigen::VectorXd new_compute_fv(PhyTree &tree,Eigen::VectorXd &fv_L,Eigen::VectorXd &fv_R){
	Eigen::VectorXd fv;

	fv.resize(ALPHABET::DIM+1);;

	fv=(tree[0].get_Pr()*fv_L).cwiseProduct(tree[1].get_Pr()*fv_R);

	return fv;
}
//=======================================================================================================
//DP-PIP (from Knuth)
bool approximatelyEqual(float a, float b, float epsilon)
{
    return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
//=======================================================================================================
//DP-PIP (from Knuth)
bool essentiallyEqual(float a, float b, float epsilon)
{
    return fabs(a - b) <= ( (fabs(a) > fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
//=======================================================================================================
//DP-PIP (from Knuth)
bool definitelyGreaterThan(float a, float b, float epsilon)
{
    return (a - b) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
//=======================================================================================================
//DP-PIP (from Knuth)
bool definitelyLessThan(float a, float b, float epsilon)
{
    return (b - a) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
//=======================================================================================================
//DP-PIP
//static double max_of_three(double a,double b,double c){
//     double m = a;
//
//     (m < b) && (m = b);
//     (m < c) && (m = c);
//
//     return m;
//}
//=======================================================================================================
//DP-PIP
double max_of_three_2(double a, double b, double c,double epsilon){

	//------------------------------------
	if(fabs(a)<epsilon){
		a=-INFINITY;
	}
	if(fabs(b)<epsilon){
		b=-INFINITY;
	}
	if(fabs(c)<epsilon){
		c=-INFINITY;
	}
	//------------------------------------

	if(std::isinf(a) && std::isinf(b) && std::isinf(c)){
		perror("max_of_three_2: all inf\n");
		exit(EXIT_FAILURE);
	}

	if(a>b){
		if(a>c){
			return a;
		}
		return c;
	}else{
		if(b>c){
			return b;
		}
		return c;
	}

}
//=======================================================================================================
//DP-PIP
//static int index_of_max_4(double m, double x, double y,double epsilon,std::default_random_engine &generator,std::uniform_real_distribution<double> &distribution){
//
//
//
////	double random_number;
////	for(int i=0;i<1000;i++){
////		random_number=distribution(generator);
////		std::cout<<"r = "<<random_number<<"\n";
////	}
////	exit(EXIT_SUCCESS);
//
//
//
//	printf("m,x,y : %20.18f %20.18f %20.18f\n",m,x,y);
//
//
//	int ERR=0;
//
//	if(not(std::isinf(m)) & not(std::isinf(x)) & (fabs(m-x)<epsilon)){
////		printf("m=x : %f %f %f\n",m,x,y);
//		x=m;
//	}
//
//	if(not(std::isinf(m)) & not(std::isinf(y)) & (fabs(m-y)<epsilon)){
////		printf("m=y : %f %f %f\n",m,x,y);
//		y=m;
//	}
//
//	if(not(std::isinf(x)) & not(std::isinf(y)) & (fabs(x-y)<epsilon)){
////		printf("x=y : %f %f %f\n",m,x,y);
//		y=x;
//	}
//
//	if(m>x){
//		if(m>y){
//			return int(MATCH_STATE);
//		}else if (y>m){
//			return int(GAP_Y_STATE);
//		}else{
//			if(abs(m-y)<epsilon){
//				//m or y
//				double random_number  = distribution(generator);
//
////				std::cout<<"random number my: "<<random_number<<"\n";
//
//				if(random_number < (1.0/2.0) ){
//					return int(MATCH_STATE);
//				}else{
//					return int(GAP_Y_STATE);
//				}
//			}else{
//				perror("ERROR in index_of_max_3\n");
//				exit(EXIT_FAILURE);
//			}
//		}
//	}else if (x>m){
//		if(x>y){
//			return int(GAP_X_STATE);
//		}else if (y>x){
//			return int(GAP_Y_STATE);
//		}else{
//			if(abs(x-y)<epsilon){
//				//x or y
//				double random_number  = distribution(generator);
//
//				printf("DOVREI ENTRARE QUI\n");
//				std::cout<<"random number xy: "<<random_number<<"\n";
//
////				while(random_number<0.5){
////					random_number  = distribution(generator);
////					printf("DOVREI ENTRARE QUI\n");
////					std::cout<<"random number xy: "<<random_number<<"\n";
////				}
//
//
//				if(random_number < (1.0/2.0) ){
//					return int(GAP_X_STATE);
//				}else{
//					return int(GAP_Y_STATE);
//				}
//			}else{
//				perror("ERROR in index_of_max_3\n");
//				exit(EXIT_FAILURE);
//			}
//		}
//	}else{
//
//		double mx=x;
//		if(mx>y){
//			//m or x
//			double random_number  = distribution(generator);
//
////			std::cout<<"random number mx: "<<random_number<<"\n";
//
//			if(random_number < (1.0/2.0) ){
//				return int(MATCH_STATE);
//			}else{
//				return int(GAP_X_STATE);
//			}
//		}else if (y>mx){
//			return int(GAP_Y_STATE);
//		}else{
//			if(abs(mx-y)<epsilon){
//				//m or x or y
//				double random_number  = distribution(generator);
//
////				std::cout<<"random number mxy: "<<random_number<<"\n";
//
//				if(random_number < (1.0/3.0)){
//					return int(MATCH_STATE);
//				}else if(random_number < (2.0/3.0)){
//					return int(GAP_X_STATE);
//				}else{
//					return int(GAP_Y_STATE);
//				}
//			}else{
//				perror("ERROR in index_of_max_3\n");
//				exit(EXIT_FAILURE);
//			}
//		}
//	}
//
//
//	return ERR;
//
//}
//=======================================================================================================
//DP-PIP
int index_of_max_3(double m, double x, double y,double epsilon,std::default_random_engine &generator,std::uniform_real_distribution<double> &distribution){

	double random_number;

//	double random_number;
//	for(int i=0;i<1000;i++){
//		random_number=distribution(generator);
//		std::cout<<"r = "<<random_number<<"\n";
//	}
//	exit(EXIT_SUCCESS);



//	printf("m,x,y : %20.18f %20.18f %20.18f\n",m,x,y);


	int ERR=-1;

	if(not(std::isinf(m)) & not(std::isinf(x)) & (fabs(m-x)<epsilon)){
//		printf("m=x : %f %f %f\n",m,x,y);
		x=m;
	}

	if(not(std::isinf(m)) & not(std::isinf(y)) & (fabs(m-y)<epsilon)){
//		printf("m=y : %f %f %f\n",m,x,y);
		y=m;
	}

	if(not(std::isinf(x)) & not(std::isinf(y)) & (fabs(x-y)<epsilon)){
//		printf("x=y : %f %f %f\n",m,x,y);
		y=x;
	}

	if(m>x){
		if(m>y){
			return int(MATCH_STATE);
		}else if (y>m){
			return int(GAP_Y_STATE);
		}else{
			if(abs(m-y)<epsilon){

//				printf("M or Y\n");

				//m or y
				random_number  = distribution(generator);

//				std::cout<<random_number<<"\n";

				if(random_number < (1.0/2.0) ){

//					printf("->M\n");

					return int(MATCH_STATE);
				}else{

//					printf("->Y\n");

					return int(GAP_Y_STATE);
				}
			}else{
				perror("ERROR in index_of_max_3\n");
				exit(EXIT_FAILURE);
			}
		}
	}else if (x>m){
		if(x>y){
			return int(GAP_X_STATE);
		}else if (y>x){
			return int(GAP_Y_STATE);
		}else{
			if(abs(x-y)<epsilon){

//				printf("X or Y\n");

				//x or y
				random_number  = distribution(generator);

//				std::cout<<random_number<<"\n";

				if(random_number < (1.0/2.0) ){

//					printf("->X\n");

					return int(GAP_X_STATE);
				}else{

//					printf("->Y\n");

					return int(GAP_Y_STATE);
				}
			}else{
				perror("ERROR in index_of_max_3\n");
				exit(EXIT_FAILURE);
			}
		}
	}else{

		double mx=x;
		if(mx>y){

//			printf("M or X\n");

			//m or x
			random_number  = distribution(generator);

//			std::cout<<random_number<<"\n";

			if(random_number < (1.0/2.0) ){

//				printf("->M\n");

				return int(MATCH_STATE);
			}else{

//				printf("->X\n");

				return int(GAP_X_STATE);
			}
		}else if (y>mx){
			return int(GAP_Y_STATE);
		}else{
			if(abs(mx-y)<epsilon){


//				printf("M or X or Y\n");

				//m or x or y
				random_number  = distribution(generator);

//				std::cout<<random_number<<"\n";

				if(random_number < (1.0/3.0)){

//					printf("->M\n");

					return int(MATCH_STATE);
				}else if(random_number < (2.0/3.0)){

//					printf("->X\n");

					return int(GAP_X_STATE);
				}else{

//					printf("->Y\n");

					return int(GAP_Y_STATE);
				}
			}else{
				perror("ERROR in index_of_max_3\n");
				exit(EXIT_FAILURE);
			}
		}
	}


	return ERR;

}
//=======================================================================================================
//DP-PIP
//static int index_of_max(double m, double x, double y){
//
//	if(m>x){
//		if(m>y){
//			return int(MATCH_STATE);
//		}else{
//			return int(GAP_Y_STATE);
//		}
//	}else{
//		if(x>y){
//			return int(GAP_X_STATE);
//		}else{
//			return int(GAP_Y_STATE);
//		}
//	}
//
//	return 0;
//}
//=======================================================================================================
//DP-PIP
//static int index_of_max_2(double a, double b, double c,double epsilon,double random_number){
//
//	//------------------------------------
//	if(abs(a)<epsilon){
//		a=-INFINITY;
//	}
//	if(abs(b)<epsilon){
//		b=-INFINITY;
//	}
//	if(abs(c)<epsilon){
//		c=-INFINITY;
//	}
//	//------------------------------------
//
//
////	std::cout<<"a: "<<a<<" b: "<<b<<" c: "<<c<<"\n";
//
//
//	if(definitelyGreaterThan(a,b,epsilon)){
//
//		if(definitelyGreaterThan(a,c,epsilon)){
//			return int(MATCH_STATE);
//		}else{
//			if(definitelyGreaterThan(c,a,epsilon)){
//				return int(GAP_Y_STATE);
//			}else{
//
//				if(random_number>1.0/2.0){
//					return int(MATCH_STATE);
//				}else{
//					return int(GAP_Y_STATE);
//				}
//
//			}
//		}
//
//	}else{
//
//		if(definitelyGreaterThan(b,a,epsilon)){
//			if(definitelyGreaterThan(b,c,epsilon)){
//				return int(GAP_X_STATE);
//			}else{
//				if(definitelyGreaterThan(c,b,epsilon)){
//					return int(GAP_Y_STATE);
//				}else{
//
//					if(random_number>1.0/2.0){
//						return int(GAP_X_STATE);
//					}else{
//						return int(GAP_Y_STATE);
//					}
//
//				}
//			}
//		}else{
//
//			if(definitelyGreaterThan(c,a,epsilon)){
//				return int(GAP_Y_STATE);
//			}else{
//
//				if(random_number<1.0/3.0){
//					return int(MATCH_STATE);
//				}else if(random_number<2.0/3.0){
//					return int(GAP_X_STATE);
//				}else{
//					return int(GAP_Y_STATE);
//				}
//
//
//			}
//
//
//		}
//	}
//
//	return ERR_STATE;
//}
//=======================================================================================================
//DP-PIP
/*
static void fill_Pc(PhyTree &tree,Eigen::MatrixXi &TR,Eigen::MatrixXd &PX,Eigen::MatrixXd &PY,int len){

	tree.setZero_Pc(len);

	int id1=TR.rows()-1;
	int id2=TR.cols()-1;

	for(int i=len-1;i>=0;i--){
		switch(TR(id1,id2)){
			case MATCH:
				id1=id1-1;
				id2=id2-1;
				break;
			case GAPX:
				//tree.Pc[i]=(double)PX(id1,id2);
				tree.set_Pc(i,(double)PX(id1,id2));
				id1=id1-1;
				break;
			case GAPY:
				//tree.Pc[i]=(double)PY(id1,id2);
				tree.set_Pc(i,(double)PY(id1,id2));
				id2=id2-1;
				break;
			default:
				error("ERROR in fill_Pc");
				exit(EXIT_FAILURE);
		}
	}

}
*/
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void fill_Pc_new(ProgressivePIPResult<ALPHABET> &result,Eigen::MatrixXi &TR,Eigen::MatrixXd &PX,Eigen::MatrixXd &PY,int len){


	//std::cout<<"-------------------------------------\n";


	result.Pc.setZero(len);

	int id1=TR.rows()-1;
	int id2=TR.cols()-1;

	for(int i=len-1;i>=0;i--){
		switch(TR(id1,id2)){
			case MATCH_STATE:
				id1=id1-1;
				id2=id2-1;

				break;
			case GAP_X_STATE:

				//std::cout<<"Pc["<<i<<"]=PX["<<id1<<","<<id2<<"]="<<(double)PX(id1,id2)<<"\n";

				result.Pc[i]=(double)PX(id1,id2);
				id1=id1-1;
				break;
			case GAP_Y_STATE:

				//std::cout<<"Pc["<<i<<"]=PY["<<id1<<","<<id2<<"]="<<(double)PY(id1,id2)<<"\n";

				result.Pc[i]=(double)PY(id1,id2);
				id2=id2-1;
				break;
			default:
				error("ERROR in fill_Pc");
				exit(EXIT_FAILURE);
		}
	}

	//std::cout<<"-------------------------------------\n";

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void fill_Pc_new3(ProgressivePIPResult<ALPHABET> &result,sequence_t<ALPHABET>tracepath,Eigen::MatrixXd &PM,Eigen::MatrixXd &PX,Eigen::MatrixXd &PY){

	int len=tracepath.length();

	int id1=PM.rows()-1;
	int id2=PM.cols()-1;

	result.Pc.setZero(len);

	for(int i=len-1;i>=0;i--){
		if(tracepath[i]==ALPHABET::match){
			result.Pc[i]=(double)PM(id1,id2);
			id1=id1-1;
			id2=id2-1;
		}else if(tracepath[i]==ALPHABET::gapX){
			result.Pc[i]=(double)PX(id1,id2);
			id1=id1-1;
		}else if(tracepath[i]==ALPHABET::gapY){
			result.Pc[i]=(double)PY(id1,id2);
			id2=id2-1;
		}else{
			error("ERROR in fill_Pc_new3");
			exit(EXIT_FAILURE);
		}
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void fill_Pc_new2(ProgressivePIPResult<ALPHABET> &result,Eigen::MatrixXi &TR,Eigen::MatrixXd &PM,Eigen::MatrixXd &PX,Eigen::MatrixXd &PY,int len){


	//std::cout<<"-------------------------------------\n";


	result.Pc.setZero(len);

	int id1=TR.rows()-1;
	int id2=TR.cols()-1;

	for(int i=len-1;i>=0;i--){
		switch(TR(id1,id2)){
			case MATCH_STATE:
				result.Pc[i]=(double)PM(id1,id2);

				id1=id1-1;
				id2=id2-1;
				break;
			case GAP_X_STATE:

				//std::cout<<"Pc["<<i<<"]=PX["<<id1<<","<<id2<<"]="<<(double)PX(id1,id2)<<"\n";

				result.Pc[i]=(double)PX(id1,id2);
				id1=id1-1;
				break;
			case GAP_Y_STATE:

				//std::cout<<"Pc["<<i<<"]=PY["<<id1<<","<<id2<<"]="<<(double)PY(id1,id2)<<"\n";

				result.Pc[i]=(double)PY(id1,id2);
				id2=id2-1;
				break;
			default:
				error("ERROR in fill_Pc");
				exit(EXIT_FAILURE);
		}
	}

	//std::cout<<"-------------------------------------\n";

}
//=======================================================================================================
//DP-PIP
double compute_nu(double tau,double lambda,double mu){

	if(fabs(mu)<1e-8){
		error("ERROR in compute_nu: mu too small");
	}

	return lambda*(tau+1/mu);
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static double compute_Pa(PhyTree &tree,double fv_ij,double pC,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,sequence_t<ALPHABET> &sq){

	double pL=0.0;
	double p0;

	if(tree.isLeaf()){
		error("ERROR in compute_Pa, 'tree' not an internal node!");
	}

	if(tree[0].isLeaf()){

		double freq;
		if(sq.length()!=1){
			error("ERROR in compute_Pa");
			exit(EXIT_FAILURE);
		}

		freq=pi(sq[0].value());

	    pL=freq*tree[0].get_iota() * tree[0].get_beta();
	}

	if(tree.getParent()==NULL){
	    p0=tree.get_iota()*fv_ij;
	}else{
	    p0=tree.get_iota()*tree.get_beta()*fv_ij;
	}

	return pL + p0 + pC;

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static double compute_Pa_new(PhyTree &tree,double fv_ij,double pC,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,sequence_t<ALPHABET> &sq,double lk_gap){

	double pL=0.0;
	double p0;

	double pR=0.0;

	if(tree.isLeaf()){
		error("ERROR in compute_Pa, 'tree' not an internal node!");
	}


	if(!tree[1].isLeaf()){
		pR=lk_gap;
	}




	if(tree[0].isLeaf()){

		double freq;
		if(sq.length()!=1){
			error("ERROR in compute_Pa");
			exit(EXIT_FAILURE);
		}

		freq=pi(sq[0].value());

	    pL=freq*tree[0].get_iota() * tree[0].get_beta();
	}

	if(tree.getParent()==NULL){
	    p0=tree.get_iota()*fv_ij;
	}else{
	    p0=tree.get_iota()*tree.get_beta()*fv_ij;
	}

	return pL + p0 + pC +pR;

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static double compute_Pb(PhyTree &tree,double fv_ij,double pC,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,sequence_t<ALPHABET> &sq){

	double pR=0.0;
	double p0;

	if(tree.isLeaf()){
		error("ERROR in compute_Pb, 'tree' not an internal node!");
	}

	if(tree[1].isLeaf()){

		double freq;
		if(sq.length()!=1){
			error("ERROR in compute_Pb");
			exit(EXIT_FAILURE);
		}

		freq=pi(sq[0].value());

		pR=freq*tree[1].get_iota() * tree[1].get_beta();
	}

	if(tree.getParent()==NULL){
		p0=tree.get_iota()*fv_ij;
	}else{
		p0=tree.get_iota()*tree.get_beta()*fv_ij;
	}

	return pR + p0 + pC;

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static double compute_Pb_new(PhyTree &tree,double fv_ij,double pC,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,sequence_t<ALPHABET> &sq,double lk_gap){

	double pR=0.0;
	double p0;

	double pL=0.0;

	if(tree.isLeaf()){
		error("ERROR in compute_Pb, 'tree' not an internal node!");
	}



	if(!tree[0].isLeaf()){
		pL=lk_gap;
	}




	if(tree[1].isLeaf()){

		double freq;
		if(sq.length()!=1){
			error("ERROR in compute_Pb");
			exit(EXIT_FAILURE);
		}

		freq=pi(sq[0].value());

		pR=freq*tree[1].get_iota() * tree[1].get_beta();
	}

	if(tree.getParent()==NULL){
		p0=tree.get_iota()*fv_ij;
	}else{
		p0=tree.get_iota()*tree.get_beta()*fv_ij;
	}








//		std::cout<<"compute_Pb_new\n";
//		std::cout<<"pR: "<<pR<<"\n";
//		std::cout<<"p0: "<<p0<<"\n";
//		std::cout<<"pC: "<<pC<<"\n";
//		std::cout<<"pL: "<<pL<<"\n";







	return pR + p0 + pC + pL;

}
//=======================================================================================================
//DP-PIP
static double compute_Pe(PhyTree &tree,double fv_ij){

	double pL=0.0;
	double pR=0.0;
	double p0;

	if(tree.isLeaf()){
		error("ERROR in compute_Pe, 'tree' not an internal node!");
	}

	if(tree[0].isLeaf()){
		pL=tree[0].get_iota() - tree[0].get_iota() * tree[0].get_beta();
	}

	if(tree[1].isLeaf()){
		pR=tree[1].get_iota() - tree[1].get_iota() * tree[1].get_beta();
	}

	if(tree.getParent()==NULL){
	    p0=tree.get_iota()*fv_ij;
	}else{
	    p0=tree.get_iota()-tree.get_iota()*tree.get_beta()+tree.get_iota()*tree.get_beta()*fv_ij;
	}


	//std::cout<<"pL: "<<pL<<"\n";
	//std::cout<<"pR: "<<pR<<"\n";
	//std::cout<<"p0: "<<p0<<"\n";


	return pL + pR + p0;

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_pr_gap(	PhyTree &tree,
						std::map<std::string,Eigen::VectorXd> &map_L,
						std::map<std::string,Eigen::VectorXd> &map_R,
						std::map<std::string,Eigen::VectorXd> &map0,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double &pC,
						double lk_gap){

	double pr;
	double pL;
	double p0;
	double pR;
	double fv0;
	Eigen::VectorXd fv;


	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;

	MapIterator itL=map_L.find(stringFromSequence<ALPHABET>(sL));
	if(itL == map_L.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sL);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvL=itL->second;

	MapIterator itR=map_R.find(stringFromSequence<ALPHABET>(sR));
	if(itR == map_R.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sR);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvR=itR->second;

	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	std::string	s;
	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(sR));

	map0[s]=fv;

	fv0=fv.dot(pi);

//	if(!tree[1].isLeaf()){
//		pR=lk_gap;
//	}else{
//		pR=0.0;
//	}

	if(tree[0].isLeaf()){

		if(sL.length()!=1){
			error("ERROR in compute_pr_gap");
			exit(EXIT_FAILURE);
		}

		pL=tree[0].get_iota() - tree[0].get_iota() * tree[0].get_beta();
	}else{
		pL=0.0;
	}

	if(tree[1].isLeaf()){

		if(sR.length()!=1){
			error("ERROR in compute_pr_gap");
			exit(EXIT_FAILURE);
		}

		pR=tree[1].get_iota() - tree[1].get_iota() * tree[1].get_beta();
	}else{
		pR=0.0;
	}


	if(tree.getParent()==NULL){
		p0=tree.get_iota()*fv0;
	}else{
		p0=tree.get_iota()-tree.get_iota()*tree.get_beta()+tree.get_iota()*tree.get_beta()*fv0;
	}

	pr=p0 + pL + pC +pR;

//	std::cout.precision(15);
//	std::cout<<"pr: "<<pr<<"\n";
//	std::cout<<"p0: "<<p0<<"\n";
//	std::cout<<"pL: "<<pL<<"\n";
//	std::cout<<"pC: "<<pC<<"\n";
//	std::cout<<"pR: "<<pR<<"\n";


	pC=pr;

	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		if(p_tree->getParent()->getParent()==NULL){
			pr+=(p_tree->getParent()->get_iota()*fv0);
		}else{
			pr+=(p_tree->getParent()->get_iota() - p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta() + p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);
		}

		p_tree=p_tree->getParent();
	}


//	std::cout<<"pr(top): "<<pr<<"\n";


	return pr;
}
//=======================================================================================================
//DP-PIP
//static double compute_Pe_new(PhyTree &tree,double fv_ij,double pc0){
//
//	double pL=0.0;
//	double pR=0.0;
//	double p0;
//
//	if(tree.isLeaf()){
//		error("ERROR in compute_Pe, 'tree' not an internal node!");
//	}
//
//	if(tree[0].isLeaf()){
//		pL=tree[0].get_iota() - tree[0].get_iota() * tree[0].get_beta();
//	}
//
//	if(tree[1].isLeaf()){
//		pR=tree[1].get_iota() - tree[1].get_iota() * tree[1].get_beta();
//	}
//
//	if(tree.getParent()==NULL){
//	    p0=tree.get_iota()*fv_ij;
//	}else{
//	    p0=tree.get_iota()-tree.get_iota()*tree.get_beta()+tree.get_iota()*tree.get_beta()*fv_ij;
//	}
//
//	/*
//	std::cout<<"pL: "<<pL<<"\n";
//	std::cout<<"pR: "<<pR<<"\n";
//	std::cout<<"p0: "<<p0<<"\n";
//	std::cout<<"pc0: "<<pc0<<"\n";
//	*/
//
//	return pL + pR + p0 + pc0;
//
//}
//=======================================================================================================
//DP-PIP
static double compute_Pab(PhyTree &tree,double fv_ij){

	if(tree.isLeaf()){
		error("ERROR in compute_Pab, 'tree' not an internal node!");
	}

	if(tree.getParent()==NULL){
	    return tree.get_iota()*fv_ij;
	}else{
	    return tree.get_iota()*tree.get_beta()*fv_ij;
	}

}
//=======================================================================================================
//DP-PIP
Eigen::SparseMatrix<double,Eigen::RowMajor>** initialize_MatrixSparse3D(int height,int width,int depth){

	Eigen::SparseMatrix<double,Eigen::RowMajor>** matrix = new Eigen::SparseMatrix<double,Eigen::RowMajor>*[depth];

	for(int i = 0; i < depth; i++){
        matrix[i] = new (Eigen::SparseMatrix<double,Eigen::RowMajor>)(Eigen::SparseMatrix<double,Eigen::RowMajor>(height,width));
    }

    return matrix;
}
//=======================================================================================================
//DP-PIP
Eigen::SparseMatrix<int,Eigen::RowMajor>** initialize_MatrixSparse3D_int(int height,int width,int depth){

	Eigen::SparseMatrix<int,Eigen::RowMajor>** matrix = new Eigen::SparseMatrix<int,Eigen::RowMajor>*[depth];

	for(int i = 0; i < depth; i++){
        matrix[i] = new (Eigen::SparseMatrix<int,Eigen::RowMajor>)(Eigen::SparseMatrix<int,Eigen::RowMajor>(height,width));
    }

    return matrix;
}
//=======================================================================================================
//DP-PIP
//static void delete_MatrixSparse3D(Eigen::SparseMatrix<double,Eigen::RowMajor>** matrix,int depth){
//
//	for(int i=0;i<depth;i++){
//    	delete matrix[i];
//    }
//}
//=======================================================================================================
//DP-PIP
void get_non_zero_elements_list(Eigen::SparseMatrix<double,Eigen::RowMajor>*m,std::vector< std::pair<int,int> > &list){

	list.clear();

	for(int k=0;k<m->outerSize();++k){
		for(Eigen::SparseMatrix<double,Eigen::RowMajor>::InnerIterator it(*m,k); it; ++it){
			list.push_back( std::pair<int,int>(it.row(),it.col()));
		}
	}

}
//=======================================================================================================
//DP-PIP
void next_nonzero_elements(std::vector< std::pair<int,int> > *lm_old,std::vector< std::pair<int,int> > *lx_old,std::vector< std::pair<int,int> > *ly_old,std::vector< std::pair<int,int> > *lm_new,std::vector< std::pair<int,int> > *lx_new,std::vector< std::pair<int,int> > *ly_new,int height,int width){

	while(!lm_old->empty()){
		std::pair<int,int> p=lm_old->back();
		if( ((p.first+1)<height) & ((p.second+1)<width) ){
			lm_new->push_back(std::pair<int,int>(p.first+1,p.second+1));
		}
		if( (p.second+1)<width){
			ly_new->push_back(std::pair<int,int>(p.first,p.second+1));
		}
		if( (p.first+1)<height){
			lx_new->push_back(std::pair<int,int>(p.first+1,p.second));
		}
		lm_old->pop_back();
	}

	while(!lx_old->empty()){
		std::pair<int,int> p=lx_old->back();
		if( ((p.first+1)<height) & ((p.second+1)<width)){
			lm_new->push_back(std::pair<int,int>(p.first+1,p.second+1));
		}
		if( (p.second+1)<width){
			ly_new->push_back(std::pair<int,int>(p.first,p.second+1));
		}
		if( (p.first+1)<height){
			lx_new->push_back(std::pair<int,int>(p.first+1,p.second));
		}
		lx_old->pop_back();
	}

	while(!ly_old->empty()){
		std::pair<int,int> p=ly_old->back();
		if( ((p.first+1)<height) & ((p.second+1)<width) ){
			lm_new->push_back(std::pair<int,int>(p.first+1,p.second+1));
		}
		if( (p.second+1)<width){
			ly_new->push_back(std::pair<int,int>(p.first,p.second+1));
		}
		if( (p.first+1)<height){
			lx_new->push_back(std::pair<int,int>(p.first+1,p.second));
		}
		ly_old->pop_back();
	}
}
//=======================================================================================================
//DP-PIP
//void next_nonzero_elements_set(std::set< std::pair<int,int> > &lm1,
//							   std::set< std::pair<int,int> > &lx1,
//							   std::set< std::pair<int,int> > &ly1,
//							   std::set< std::pair<int,int> > &lm2,
//							   std::set< std::pair<int,int> > &lx2,
//							   std::set< std::pair<int,int> > &ly2,
//							   int height,int width){
//
//
//	lm2.clear();
//	lx2.clear();
//	ly2.clear();
//
//	typedef typename std::set< std::pair<int,int> >::iterator iter_set;
//
//	for(iter_set it = lm1.begin(); it != lm1.end(); it++){
//		if( ((it->first+1)<height) & ((it->second+1)<width) ){
//			lm2.insert(std::pair<int,int>(it->first+1,it->second+1));
//		}
//		if( (it->first+1)<height){
//			lx2.insert(std::pair<int,int>(it->first+1,it->second));
//		}
//		if( (it->second+1)<width){
//			ly2.insert(std::pair<int,int>(it->first,it->second+1));
//		}
//	}
//
//	for(iter_set it = lx1.begin(); it != lx1.end(); it++){
//		if( ((it->first+1)<height) & ((it->second+1)<width) ){
//			lm2.insert(std::pair<int,int>(it->first+1,it->second+1));
//		}
//		if( (it->first+1)<height){
//			lx2.insert(std::pair<int,int>(it->first+1,it->second));
//		}
//		if( (it->second+1)<width){
//			ly2.insert(std::pair<int,int>(it->first,it->second+1));
//		}
//	}
//
//	for(iter_set it = ly1.begin(); it != ly1.end(); it++){
//		if( ((it->first+1)<height) & ((it->second+1)<width) ){
//			lm2.insert(std::pair<int,int>(it->first+1,it->second+1));
//		}
//		if( (it->first+1)<height){
//			lx2.insert(std::pair<int,int>(it->first+1,it->second));
//		}
//		if( (it->second+1)<width){
//			ly2.insert(std::pair<int,int>(it->first,it->second+1));
//		}
//	}
//
//	std::swap(lm1,lm2);
//	std::swap(lx1,lx2);
//	std::swap(ly1,ly2);
//
//}
//=======================================================================================================
//DP-PIP
/*
double computeLK_M(	Eigen::SparseMatrix<double,Eigen::RowMajor>*M,
					Eigen::SparseMatrix<double,Eigen::RowMajor>*X,
					Eigen::SparseMatrix<double,Eigen::RowMajor>*Y,
					int i,int j){

	double Pa,Pb,Pab;
	double pc0;
	double pc;
	double fv0;


	if(j==0){

		fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,sL,col_gap_R,pi);

		M(i,0)=i;

		log_SM(i,0)=-INFINITY;
		log_SY(i,0)=-INFINITY;

		pc=getPc(result_L,i-1);

		Pa=compute_Pa_new<ALPHABET>(tree,fv0,pc,pi,sL,lk_gap);

		PX(i,0)=Pa;

		//:*:*:*:*:*:*:*:*:*:*:*:*
		PM(i,j)=0.0;
		PY(i,j)=0.0;
		//:*:*:*:*:*:*:*:*:*:*:*:*

		log_SX(i,0)=-log(double(M(i,0)))+log(nu)+log(Pa)+log_SX(i-1,0);

		TR(i,0)=GAP_X_STATE;

	}else if(i==0){

		fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,col_gap_L,sR,pi);

		M(0,j)=j;

		log_SM(0,j)=-INFINITY;
		log_SX(0,j)=-INFINITY;

		pc=getPc(result_R,j-1);

		Pb=compute_Pb_new<ALPHABET>(tree,fv0,pc,pi,sR,lk_gap);
		PY(0,j)=Pb;

		//:*:*:*:*:*:*:*:*:*:*:*:*
		PM(i,j)=0.0;
		PX(i,j)=0.0;
		//:*:*:*:*:*:*:*:*:*:*:*:*

		log_SY(0,j)=-log(double(M(0,j)))+log(nu)+log(Pb)+log_SY(0,j-1);

		TR(0,j)=GAP_Y_STATE;

	}else{

		fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,sL,sR,pi);

		Pab=compute_Pab(tree,fv0);

		//:*:*:*:*:*:*:*:*:*:*:*:*
		PM(i,j)=Pab;
		//:*:*:*:*:*:*:*:*:*:*:*:*

		log_SM(i,j)=-log(double(M(i-1,j-1)+1))+log(nu)+log(Pab)+max_of_three((double)log_SM(i-1,j-1),(double)log_SX(i-1,j-1),(double)log_SY(i-1,j-1));

		fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,sL,col_gap_R,pi);

		pc=getPc(result_L,i-1);

		Pa=compute_Pa_new<ALPHABET>(tree,fv0,pc,pi,sL,lk_gap);
		PX(i,j)=Pa;

		log_SX(i,j)=-log(double(M(i-1,j)+1))+log(nu)+log(Pa)+max_of_three((double)log_SM(i-1,j),(double)log_SX(i-1,j),(double)log_SY(i-1,j));

		fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,col_gap_L,sR,pi);

		pc=getPc(result_R,j-1);

		Pb=compute_Pb_new<ALPHABET>(tree,fv0,pc,pi,sR,lk_gap);
		PY(i,j)=Pb;

		log_SY(i,j)=-log(double(M(i,j-1)+1))+log(nu)+log(Pb)+max_of_three((double)log_SM(i,j-1),(double)log_SX(i,j-1),(double)log_SY(i,j-1));









		//.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
		TR(i,j)=index_of_max((double)log_SM(i,j),(double)log_SX(i,j),(double)log_SY(i,j));

		random_number = distribution(generator);
		TR(i,j)=index_of_max_2((double)log_SM(i,j),(double)log_SX(i,j),(double)log_SY(i,j),epsilon,random_number);
		//.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

		switch(TR(i,j)){
			case MATCH_STATE:
				M(i,j)=M(i-1,j-1)+1;
				break;

			case GAP_X_STATE:
				M(i,j)=M(i-1,j)+1;
				break;

			case GAP_Y_STATE:
				M(i,j)=M(i,j-1)+1;
				break;

			default:
				error("ERROR in compute_DP_PIP, case not handled");
				exit(EXIT_FAILURE);
		}






	}



}
*/
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_M(	Eigen::SparseMatrix<double,Eigen::RowMajor>*M,
					Eigen::SparseMatrix<double,Eigen::RowMajor>*X,
					Eigen::SparseMatrix<double,Eigen::RowMajor>*Y,
					int i,int j,
					double nu,
					ProgressivePIPResult<ALPHABET> &result_L,
					ProgressivePIPResult<ALPHABET> &result_R,
					PhyTree &tree,
					sequence_t<ALPHABET> sL,
					sequence_t<ALPHABET> sR,
					Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi,
					std::map<std::string,Eigen::VectorXd> &temp_fv_map,
					double lk_gap,
					Eigen::MatrixXd &PM,
					int m){

	double Pab;
	double fv0;
	double val;

	fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,sL,sR,pi);

	Pab=compute_Pab(tree,fv0);

	PM(i,j)=Pab;

	val=-log(double(m))+log(nu)+log(Pab)+max_of_three_2((double)M->coeff(i-1,j-1),(double)X->coeff(i-1,j-1),(double)Y->coeff(i-1,j-1),(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//double computeLK_M_fast(Eigen::SparseMatrix<double,Eigen::RowMajor>*M,
//						Eigen::SparseMatrix<double,Eigen::RowMajor>*X,
//						Eigen::SparseMatrix<double,Eigen::RowMajor>*Y,
//						int i,int j,
//						double nu,
//						PhyTree &tree,
//						sequence_t<ALPHABET> sL,
//						sequence_t<ALPHABET> sR,
//						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi,
//						double lk_gap,
//						Eigen::MatrixXd &PM,
//						int m,
//						Eigen::MatrixXd &matFv){
//
//	double Pab;
//	double fv0;
//	double val;
//
//	fv0=compute_fv_new_fast(tree,sL,sR,matFv,pi);
//
//	Pab=compute_Pab(tree,fv0);
//
//	PM(i,j)=Pab;
//
//	val=-log(double(m))+log(nu)+log(Pab)+max_of_three_2((double)M->coeff(i-1,j-1),(double)X->coeff(i-1,j-1),(double)Y->coeff(i-1,j-1),DBL_EPSILON);
//
//	return val;
//}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_pr_match(PhyTree &tree,
						std::map<std::string,Eigen::VectorXd> &map_L,
						std::map<std::string,Eigen::VectorXd> &map_R,
						std::map<std::string,Eigen::VectorXd> &map0,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double *p0){
	double pr;
	double fv0;
	Eigen::VectorXd fv;

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	MapIterator itL=map_L.find(stringFromSequence<ALPHABET>(sL));
	if(itL == map_L.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sL);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvL=itL->second;

	MapIterator itR=map_R.find(stringFromSequence<ALPHABET>(sR));
	if(itR == map_R.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sR);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvR=itR->second;

	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);


	std::string	s;
	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(sR));

	map0[s]=fv;


	fv0=fv.dot(pi);
	pr=tree.get_iota()*tree.get_beta()*fv0;


	//--------------------------
	/*
	std::cout<<"sL: "<<stringFromSequence(sL)<<"\n";
	std::cout<<"sR: "<<stringFromSequence(sR)<<"\n";
	std::cout<<"iota: "<<tree.get_iota()<<"\n";
	std::cout<<"beta: "<<tree.get_beta()<<"\n";
	std::cout<<"fv: "<<fv0<<"\n";
	std::cout<<"pr: "<<pr<<"\n";
	*/
	//--------------------------

	*p0=pr;

	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

		p_tree=p_tree->getParent();
	}


	return pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Mopt_all_edges(std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						double valM,
						double valX,
						double valY,
						int i,int j,
						double nu,
						PhyTree &tree,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double &lk,
						int m){

//	double Pab;
//	double fv0;
	double val;

//	Eigen::VectorXd fv;

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
	double fv0;
	Eigen::VectorXd fv;

	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(sR));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		MapIterator itL=fv_L.find(stringFromSequence<ALPHABET>(sL));
		if(itL == fv_L.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sL);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvL=itL->second;

		MapIterator itR=fv_R.find(stringFromSequence<ALPHABET>(sR));
		if(itR == fv_R.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sR);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvR=itR->second;

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}else{
		fv=it->second;
	}


	fv0=fv.dot(pi);

	fv_0[s]=fv;

	double pr;

	pr=tree.get_iota()*tree.get_beta()*fv0;


	double p0=pr;

	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

		p_tree=p_tree->getParent();
	}

//	PM(i+1,j+1)=p0;
	lk=p0;

//	val=-log(double(m))+log(nu)+log(Pab)+max_of_three_2(valM,valX,valY,DBL_EPSILON);
	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Mopt_all_edges_local_tree(	double valM,
											double valX,
											double valY,
											double nu,
											PhyTree &tree,
											sequence_t<ALPHABET> &sL,
											sequence_t<ALPHABET> &sR,
											Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
											int m,
											std::map<std::string,Eigen::VectorXd> &fv_0){

	double fv0;
	double pr;
	double val;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;



	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
//	double fv0;
//	Eigen::VectorXd fv;

	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(sR));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		//------------------------------------------------------------------------------------------
		int idx=0;
		fvL=go_down_left(tree,sL,idx);
		idx=0;
		fvR=go_down_right(tree,sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv_0[s]=fv;

	}else{
		fv=it->second;
	}
	//------------------------------------------------------------------------------------------


//	fvL=go_down_left(tree,sL,0);
//	fvR=go_down_right(tree,sR,0);
//
//	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);


	fv0=fv.dot(pi);

	pr=tree.get_iota()*tree.get_beta()*fv0;

//	std::cout<<"prM("<<stringFromSequence(sL)<<":"<<stringFromSequence(sR)<<")"; printf(" %18.16lf\n",pr);

	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
Eigen::VectorXd go_down_s(PhyTree &tree,std::string &s,int &idx){
	Eigen::VectorXd fv;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;

	if(tree.isLeaf()){

		fv=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
		int ii;//=s[idx].value();
		ii=mytable[(int)s[idx]];
		ii=ii<0?ALPHABET::DIM:ii;
		fv[ii]=1.0;
		idx++;

	}else{

		fvL=go_down_s<ALPHABET>(tree[0],s,idx);
		fvR=go_down_s<ALPHABET>(tree[1],s,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}

	return fv;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Mopt_all_edges_local_tree_s(	double valM,
											double valX,
											double valY,
											double nu,
											PhyTree &tree,
											std::string &sL,
											std::string &sR,
											Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
											int m,
											std::map<std::string,Eigen::VectorXd> &fv_0){

	double fv0;
	double pr;
	double val;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;

	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(sR);

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		//------------------------------------------------------------------------------------------
		int idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);
		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv_0[s]=fv;

	}else{
		fv=it->second;
	}
	//------------------------------------------------------------------------------------------

	fv0=fv.dot(pi);

	pr=tree.get_iota()*tree.get_beta()*fv0;

//	std::cout<<"prM("<<stringFromSequence(sL)<<":"<<stringFromSequence(sR)<<")"; printf(" %18.16lf\n",pr);

	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_M_local_tree_s_opt(double valM,
									double valX,
									double valY,
									double nu,
									PhyTree &tree,
									std::string &sL,
									std::string &sR,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									int m,
									std::map<std::string,double> &lkM){


	double pr;
	double val;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(sR);

	MapIterator it=lkM.find(s);
	if(it == lkM.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		double fv0;
		int idx;

		idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);
		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);


		std::cout<<"fvL: "<<fvL<<"\n\n";
		std::cout<<"fvR: "<<fvR<<"\n\n";


		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

		fv0=fv.dot(pi);


		printf("iota %lf beta %lf\n",tree.get_iota(),tree.get_beta());

		std::cout<<"fv: "<<fv<<"\n";

		std::cout<<"fv0: "<<fv0<<"\n";

		std::cout<<"\n";
		std::cout<<"PrL:\n"<<std::endl;
		std::cout<<tree.get_left_child()->get_Pr()<<"\n";
		std::cout<<"PrR:\n"<<std::endl;
		std::cout<<tree.get_right_child()->get_Pr()<<"\n";
		std::cout<<"\n";

		pr=tree.get_iota()*tree.get_beta()*fv0;

		printf("pr %lf\n",pr);
		//------------------------------------------------------------------------------------------

		pr=log(pr);

		lkM[s]=pr;

	}else{
		pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
	std::cout<<"prM("<<sL<<":"<<sR<<")"; printf(" %18.16lf\n",pr);
#endif



	printf("M: m %d nu %lf pr %lf valM %lf valX %lf valY %lf\n",m,nu,pr,valM,valX,valY);

	std::cout<<"L: "<<sL<<"; R: "<<sR<<std::endl;

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
	val=-log(double(m))+log(nu)+pr+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
//@SB
template <class ALPHABET>
double computeLK_M_local_tree_s_opt_SB(PhyTree &tree,
									std::string &sL,
									std::string &sR,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									std::map<std::string,double> &lkM){


	double log_pr;
	double pr;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(sR);

	MapIterator it=lkM.find(s);
	if(it == lkM.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		double fv0;
		int idx;

		idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);
		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

		fv0=fv.dot(pi);

		pr=tree.get_iota()*tree.get_beta()*fv0;
		//------------------------------------------------------------------------------------------

//		lkM[s]=pr;

		log_pr=log(pr);

		lkM[s]= log_pr;

	}else{
		log_pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
	std::cout<<"prM("<<sL<<":"<<sR<<")"; printf(" %18.16lf\n",pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
//	val=1.0/(double(m) * nu * pr + (valM + valX + valY);

//	val=pr;

	return log_pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_M_all_edges_s_opt(double valM,
									double valX,
									double valY,
									double nu,
									PhyTree &tree,
									std::string &sL,
									std::string &sR,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									int m,
									std::map<std::string,double> &lkM){


	double pr;
	double val;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(sR);

	MapIterator it=lkM.find(s);
	if(it == lkM.end()){

		//------------------------------------------------------------------------------------------
		//DOWN
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		double fv0;
		int idx;

		idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);
		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

		fv0=fv.dot(pi);

		pr=tree.get_iota()*tree.get_beta()*fv0;
		//------------------------------------------------------------------------------------------

		//******************************************************************************************
		//UP
		PhyTree *p_tree=&tree;

		while(p_tree->getParent()!=NULL){

			fv=(p_tree->get_Pr()*fv);

			fv0=fv.dot(pi);

			pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

			p_tree=p_tree->getParent();
		}

	//	PM(i+1,j+1)=p0;
//		lk=p0;
		//******************************************************************************************

		pr=log(pr);

		lkM[s]=pr;

	}else{
		pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
	std::cout<<"pr0M("<<stringFromSequence(sL)<<":"<<stringFromSequence(sR)<<")"; printf(" %18.16lf\n",pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
	val=-log(double(m))+log(nu)+pr+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
//@SB
template <class ALPHABET>
double computeLK_M_all_edges_s_opt_SB(PhyTree &tree,
									std::string &sL,
									std::string &sR,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									std::map<std::string,double> &lkM){


	double log_pr;
	double pr;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(sR);

	MapIterator it=lkM.find(s);
	if(it == lkM.end()){

		//------------------------------------------------------------------------------------------
		//DOWN
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		double fv0;
		int idx;

		idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);
		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

		fv0=fv.dot(pi);

		pr=tree.get_iota()*tree.get_beta()*fv0;
		//------------------------------------------------------------------------------------------

		//******************************************************************************************
		//UP
		PhyTree *p_tree=&tree;

		while(p_tree->getParent()!=NULL){

			fv=(p_tree->get_Pr()*fv);

			fv0=fv.dot(pi);

			pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

			p_tree=p_tree->getParent();
		}

	//	PM(i+1,j+1)=p0;
//		lk=p0;
		//******************************************************************************************


//		lkM[s]=pr;

		log_pr=log(pr);

		lkM[s]=log_pr;

	}else{
		log_pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
	std::cout<<"pr0M("<<stringFromSequence(sL)<<":"<<stringFromSequence(sR)<<")"; printf(" %18.16lf\n",pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
//	val=1.0/(double(m) * nu * pr + (valM + valX + valY);

//	val=pr;

	return log_pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Mopt(	std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						double valM,
						double valX,
						double valY,
						int i,int j,
						double nu,
						PhyTree &tree,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double lk_gap,
						Eigen::MatrixXd &PM,
						int m){

	double Pab;
	double fv0;
	double val;

//	fv0=compute_fv_new_fast(fv_array,tree,sL,sR,matFv,pi);
	fv0=compute_fv_new(tree,fv_L,fv_R,fv_0,sL,sR,pi);

	Pab=compute_Pab(tree,fv0);

	PM(i+1,j+1)=Pab;

	val=-log(double(m))+log(nu)+log(Pab)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);


//	std::cout<<"\n-------------\n";
//	std::cout<<"match\n";
//	std::cout<<"fv0: "<<fv0<<"\n";
//	std::cout<<"Pab: "<<Pab<<"\n";
//	std::cout<<"m: "<<m<<"\n";
//	std::cout<<"nu: "<<nu<<"\n";


//	if(Pab<0){
//		perror("ERROR negative Log\n");
//		exit(EXIT_FAILURE);
//	}


	return val;
}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//double computeLK_X(	Eigen::SparseMatrix<double,Eigen::RowMajor>*M,
//					Eigen::SparseMatrix<double,Eigen::RowMajor>*X,
//					Eigen::SparseMatrix<double,Eigen::RowMajor>*Y,
//					int i,int j,
//					double nu,
//					ProgressivePIPResult<ALPHABET> &result_L,
//					ProgressivePIPResult<ALPHABET> &result_R,
//					PhyTree &tree,
//					sequence_t<ALPHABET> sL,
//					sequence_t<ALPHABET> col_gap_R,
//					Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi,
//					std::map<std::string,Eigen::VectorXd> &temp_fv_map,
//					double lk_gap,
//					Eigen::MatrixXd &PX,
//					int m){
//
//	double Pa;
//	double pc;
//	double fv0;
//	double val;
//
//
//	fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,sL,col_gap_R,pi);
//
//	pc=getPc(result_L,i-1);
//
//	Pa=compute_Pa_new<ALPHABET>(tree,fv0,pc,pi,sL,lk_gap);
//
//	PX(i,j)=Pa;
//
//	val=-log(double(m))+log(nu)+log(Pa)+max_of_three_2((double)M->coeff(i-1,j),(double)X->coeff(i-1,j),(double)Y->coeff(i-1,j),DBL_EPSILON);
//
//	return val;
//}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_X_fast(Eigen::SparseMatrix<double,Eigen::RowMajor>*M,
						Eigen::SparseMatrix<double,Eigen::RowMajor>*X,
						Eigen::SparseMatrix<double,Eigen::RowMajor>*Y,
						int i,int j,
						double nu,
						ProgressivePIPResult<ALPHABET> &result_L,
						PhyTree &tree,
						sequence_t<ALPHABET> sL,
						sequence_t<ALPHABET> col_gap_R,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi,
						double lk_gap,
						Eigen::MatrixXd &PX,
						int m,
						Eigen::MatrixXd &matFv){

	double Pa;
	double pc;
	double fv0;
	double val;


	fv0=compute_fv_new_fast(tree,sL,col_gap_R,matFv,pi);

	pc=getPc(result_L,i-1);

	Pa=compute_Pa_new<ALPHABET>(tree,fv0,pc,pi,sL,lk_gap);

	PX(i,j)=Pa;

	val=-log(double(m))+log(nu)+log(Pa)+max_of_three_2((double)M->coeff(i-1,j),(double)X->coeff(i-1,j),(double)Y->coeff(i-1,j),(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//double compute_pr_gapX_2(	PhyTree &tree,
//						std::map<std::string,Eigen::VectorXd> &map_L,
//						std::map<std::string,Eigen::VectorXd> &map_R,
//						std::map<std::string,Eigen::VectorXd> &map0,
//						sequence_t<ALPHABET> &sL,
//						sequence_t<ALPHABET> &sR,
//						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
//						double *pC,
//						double lk_gap){
//
//	double pr;
//	double pL;
//	double p0;
//	double pR;
//	double fv0;
//	Eigen::VectorXd fv;
//
//
//	/*
//	std::cout<<"\n";
//	std::cout<<tree.getName()<<" ("<<tree.get_left_child()->getName()<<","<<tree.get_right_child()->getName()<<")\n";
//	std::cout<<"SL: "<<stringFromSequence(sL)<<"\n";
//	std::cout<<"SR: "<<stringFromSequence(sR)<<"\n";
//	*/
//
//
//	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
//
//	MapIterator itL=map_L.find(stringFromSequence<ALPHABET>(sL));
//	if(itL == map_L.end()){
//		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sL);
//		exit(EXIT_FAILURE);
//	}
//	Eigen::VectorXd &fvL=itL->second;
//
//	MapIterator itR=map_R.find(stringFromSequence<ALPHABET>(sR));
//	if(itR == map_R.end()){
//		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sR);
//		exit(EXIT_FAILURE);
//	}
//	Eigen::VectorXd &fvR=itR->second;
//
//	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
//
//
//
//
//
//
//	std::string	s;
//	s.append(stringFromSequence(sL));
//	s.append(stringFromSequence(sR));
//
//	map0[s]=fv;
//
//
//
//
//
//
//
//
//
//
//	fv0=fv.dot(pi);
//
//
//	if(!tree[1].isLeaf()){
//		pR=lk_gap;
//	}else{
//		pR=0.0;
//	}
//
//	if(tree[0].isLeaf()){
//
//		double freq;
//		if(sL.length()!=1){
//			error("ERROR in compute_Pa");
//			exit(EXIT_FAILURE);
//		}
//
//		freq=pi(sL[0].value());
//
//		pL=freq*tree[0].get_iota() * tree[0].get_beta();
//	}else{
//		pL=0.0;
//	}
//
//
//	p0=tree.get_iota()*tree.get_beta()*fv0;
//	pr=p0 + pL + *pC +pR;
//
//
//
//	*pC=pr;
//
//
//	/*
//	std::cout<<"\n";
//	std::cout<<"p0: "<<p0<<"\n";
//	std::cout<<"pL: "<<pL<<"\n";
//	std::cout<<"pC: "<<pC<<"\n";
//	std::cout<<"pR: "<<pR<<"\n";
//	std::cout<<"\n";
//
//	std::cout<<"PR: "<<pr<<"\n";
//	*/
//
//	PhyTree *p_tree=&tree;
//
//	while(p_tree->getParent()!=NULL){
//
//		fv=(p_tree->get_Pr()*fv);
//
//		fv0=fv.dot(pi);
//
//		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);
//
//		/*
//		std::cout<<p_tree->getName()<<" ("<<p_tree->get_left_child()->getName()<<","<<p_tree->get_right_child()->getName()<<")\n";
//		std::cout<<"PR: "<<pr<<"\n";
//		*/
//
//		p_tree=p_tree->getParent();
//	}
//
//
//	return pr;
//}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Xopt_all_edges(std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						double valM,
						double valX,
						double valY,
						int i,
						double nu,
						ProgressivePIPResult<ALPHABET> &result_L,
						PhyTree &tree,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &col_gap_R,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double &lk,
						int m,
						double lk_gap){

//	double Pa;
	//double pc;
//	double fv0;
	double val;

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
	double fv0;
	Eigen::VectorXd fv;

	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(col_gap_R));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		MapIterator itL=fv_L.find(stringFromSequence<ALPHABET>(sL));
		if(itL == fv_L.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sL);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvL=itL->second;

		MapIterator itR=fv_R.find(stringFromSequence<ALPHABET>(col_gap_R));
		if(itR == fv_R.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(col_gap_R);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvR=itR->second;

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}else{
		fv=it->second;
	}


	fv0=fv.dot(pi);

	fv_0[s]=fv;

	double pC;

	//pc=getPc(result_L,i);
	pC=getPc(result_L,i);

	double pr;
	double pL;
	double p0;
	double pR;
//	double fv0;

	if(!tree[1].isLeaf()){
		pR=lk_gap;
	}else{
		pR=0.0;
	}

//	pR=0.0;

	if(tree[0].isLeaf()){

		double freq;
		if(sL.length()!=1){
			error("ERROR in compute_Pa");
			exit(EXIT_FAILURE);
		}

		freq=pi(sL[0].value());

		pL=freq*tree[0].get_iota() * tree[0].get_beta();
	}else{
		pL=0.0;
	}


	p0=tree.get_iota()*tree.get_beta()*fv0;
	pr=p0 + pL + pC +pR;

	pC=pr;

	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

		p_tree=p_tree->getParent();
	}


	//PX(i+1,j)=Pa;
//	PX(i+1,j)=pC;
	lk=pC;

//	val=-log(double(m))+log(nu)+log(Pa)+max_of_three_2(valM,valX,valY,DBL_EPSILON);
	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//Eigen::VectorXd recursive_fv(PhyTree &tree,Eigen::MatrixXd &matFv,sequence_t<ALPHABET> &colMSA,int &idx){
//	Eigen::VectorXd fv;
//	Eigen::VectorXd fvL;
//	Eigen::VectorXd fvR;
//
//	if(tree.isLeaf()){
//
//		int k;
//		k=colMSA[idx].value();
//
//		if(k<0){
//			k=int(ALPHABET::DIM);
//		}
//
//		fv=matFv.row(k);
//
//		idx=idx+1;
//
//	}else{
//		fvL=recursive_fv(tree[0],matFv,colMSA,idx);
//		fvR=recursive_fv(tree[1],matFv,colMSA,idx);
//
//		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
//	}
//
//	return fv;
//}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
Eigen::VectorXd go_down(PhyTree &tree,sequence_t<ALPHABET> &s,int &idx){
	Eigen::VectorXd fv;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;

	if(tree.isLeaf()){

		fv=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
		int ii=s[idx].value();
		ii=ii<0?ALPHABET::DIM:ii;
		fv[ii]=1.0;

//		std::string c=stringFromSequence(s);

//		std::cout<<"go_down (leaf) at : "<<tree.getName()<<" colMSA: "<<stringFromSequence(s)<<" char["<<idx<<"]"<<c[idx]<<"\n";

//		for(int i=0;i<ALPHABET::DIM+1;i++){
//			std::cout<<fv[i]<<"  ";
//		}
//		std::cout<<"\n";

		idx++;

	}else{

//		std::cout<<"go_down (node): "<<tree.getName()<<"\n";

		fvL=go_down(tree[0],s,idx);
		fvR=go_down(tree[1],s,idx);


		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}

	return fv;
}
////=======================================================================================================
////DP-PIP
//template <class ALPHABET>
//Eigen::VectorXd go_down_s(PhyTree &tree,std::string &s,int &idx){
//	Eigen::VectorXd fv;
//	Eigen::VectorXd fvL;
//	Eigen::VectorXd fvR;
//
//	if(tree.isLeaf()){
//
//		fv=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//		int ii=s[idx].value();
//		ii=ii<0?ALPHABET::DIM:ii;
//		fv[ii]=1.0;
//		idx++;
//
//	}else{
//
//		fvL=go_down_s<ALPHABET>(tree[0],s,idx);
//		fvR=go_down_s<ALPHABET>(tree[1],s,idx);
//
//		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
//
//	}
//
//	return fv;
//}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
Eigen::VectorXd go_down_left(PhyTree &tree,sequence_t<ALPHABET> &sL,int idx){
	Eigen::VectorXd fv;
//	std::cout<<"go_down_left (node): "<<tree.getName()<<"\n";

	fv=go_down(tree[0],sL,idx);

//	for(int i=0;i<ALPHABET::DIM+1;i++){
//		std::cout<<fv[i]<<"  ";
//	}
//	std::cout<<"\n";

	return fv;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
Eigen::VectorXd go_down_right(PhyTree &tree,sequence_t<ALPHABET> &sR,int idx){
	Eigen::VectorXd fv;

//	std::cout<<"go_down_right (node): "<<tree.getName()<<"\n";

	fv=go_down(tree[1],sR,idx);

//	for(int i=0;i<ALPHABET::DIM+1;i++){
//		std::cout<<fv[i]<<"  ";
//	}
//	std::cout<<"\n";

	return fv;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void allgaps(PhyTree &tree,sequence_t<ALPHABET> &s,int &idx,bool &flag){

	if(tree.isLeaf()){

//		std::string c=stringFromSequence<ALPHABET>(s);
//		std::cout<<"allgaps("<<tree.getName()<<")="<<stringFromSequence(s)<<"["<<idx<<"] -> "<<c[idx]<<"\n";

		int ii=s[idx].value();

		idx++;

		if(ii>=0){
			flag=false;
		}

	}else{

//		std::cout<<"allgaps("<<tree.getName()<<")="<<stringFromSequence(s)<<"\n";

		allgaps<ALPHABET>(tree[0],s,idx,flag);
		allgaps<ALPHABET>(tree[1],s,idx,flag);
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void allgaps_s(PhyTree &tree,std::string &s,int &idx,bool &flag){

	if(tree.isLeaf()){
//		int ii;//=s[idx].value();
//		ii=mytable[(int)s[idx]];

		char ch=s[idx];

		idx++;

		if(ch!='-'){
			flag=false;
		}

	}else{
		allgaps_s<ALPHABET>(tree[0],s,idx,flag);
		allgaps_s<ALPHABET>(tree[1],s,idx,flag);
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_lk_down(PhyTree &tree,sequence_t<ALPHABET> &s,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

	double pr;
	int idx;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;
	double fv0;

	if(tree.isLeaf()){

		idx=0;
		fv=go_down(tree,s,idx);
		fv0=fv.dot(pi);
		pr=tree.get_iota()*tree.get_beta()*fv0;

		return pr;

//		return pr=0.0;
	}else{


		idx=0;
		fv=go_down(tree,s,idx);
		fv0=fv.dot(pi);
		pr=tree.get_iota()*tree.get_beta()*fv0;

//		std::cout<<"fv0: "<<fv0<<" ; iota: "<<tree.get_iota()<<" ; beta: "<<tree.get_beta()<<"\n";
//		std::cout<<"compute_lk_down_L("<<tree.getName()<<")="<<stringFromSequence(s)<<" pr: "<<pr<<"\n";

		bool flagL=true;
		bool flagR=true;
		idx=0;
		allgaps(tree[0],s,idx,flagL);
		int ixx=idx;
		allgaps(tree[1],s,idx,flagR);

//		std::cout<<"flagL: "<<flagL<<" ; flagR: "<<flagR<<"\n";

		int len;
		if(flagR){
			std::string sL=stringFromSequence(s);
			len=ixx;
			sL=sL.substr(0,len);
//			std::cout<<"*sL: "<<sL<<"\n";
			sequence_t<ALPHABET> ss=sequenceFromStringPIP<ALPHABET>(sL);
			return pr + compute_lk_down<ALPHABET>(tree[0],ss,pi);
		}

		if(flagL){
			std::string sR=stringFromSequence(s);
			sR=sR.substr(ixx);
//			std::cout<<"*sR: "<<sR<<"\n";
			sequence_t<ALPHABET> ss=sequenceFromStringPIP<ALPHABET>(sR);
			return pr + compute_lk_down<ALPHABET>(tree[1],ss,pi);
		}

//		pr=0.0;
	}

	return pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_lk_down_s(PhyTree &tree,std::string &s,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

	double pr;
	int idx;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;
	double fv0;

	if(tree.isLeaf()){

		idx=0;
		fv=go_down_s<ALPHABET>(tree,s,idx);
		fv0=fv.dot(pi);
		pr=tree.get_iota()*tree.get_beta()*fv0;

		return pr;

	}else{

		idx=0;
		fv=go_down_s<ALPHABET>(tree,s,idx);
		fv0=fv.dot(pi);
		pr=tree.get_iota()*tree.get_beta()*fv0;

		bool flagL=true;
		bool flagR=true;
		idx=0;
		allgaps_s<ALPHABET>(tree[0],s,idx,flagL);
		int ixx=idx;
		allgaps_s<ALPHABET>(tree[1],s,idx,flagR);

//		std::cout<<"flagL: "<<flagL<<" ; flagR: "<<flagR<<"\n";

		int len;
		if(flagR){
			std::string sL;//=stringFromSequence(s);
			len=ixx;
			sL=s.substr(0,len);
//			std::cout<<"*sL: "<<sL<<"\n";
//			sequence_t<ALPHABET> ss=sequenceFromStringPIP<ALPHABET>(sL);
			return pr + compute_lk_down_s<ALPHABET>(tree[0],sL,pi);
		}

		if(flagL){
			std::string sR;//=stringFromSequence(s);
			sR=s.substr(ixx);
//			std::cout<<"*sR: "<<sR<<"\n";
//			sequence_t<ALPHABET> ss=sequenceFromStringPIP<ALPHABET>(sR);
			return pr + compute_lk_down_s<ALPHABET>(tree[1],sR,pi);
		}

//		pr=0.0;
	}

	return pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_lk_gap_down(PhyTree &tree,sequence_t<ALPHABET> &s,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

	double pr=0;
	double pL=0;
	double pR=0;
	int idx;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;
	double fv0;

	if(tree.isLeaf()){
		idx=0;
		fv=go_down(tree,s,idx);
		fv0=fv.dot(pi);
//		pr=tree.get_iota()*tree.get_beta()*fv0;
		pr=tree.get_iota()-tree.get_iota()*tree.get_beta()+tree.get_iota()*tree.get_beta()*fv0;

//		printf("pr(leaf) %18.16lf\n",pr);

		return pr;
	}else{
		idx=0;
		fv=go_down(tree,s,idx);
		fv0=fv.dot(pi);
//		pr=tree.get_iota()*tree.get_beta()*fv0;
		pr=tree.get_iota()-tree.get_iota()*tree.get_beta()+tree.get_iota()*tree.get_beta()*fv0;

//		printf("pr(node) %18.16lf\n",pr);


		bool flagL=true;
		bool flagR=true;
		idx=0;
		allgaps(tree[0],s,idx,flagL);
		int ixx=idx;
		allgaps(tree[1],s,idx,flagR);
		int len;
//		if(flagR){
			std::string sL=stringFromSequence(s);
			len=ixx;
			sL=sL.substr(0,len);
			sequence_t<ALPHABET> ssl=sequenceFromStringPIP<ALPHABET>(sL);
//			return pr + compute_lk_gap_down<ALPHABET>(tree[0],ssl,pi);
			pL=compute_lk_gap_down<ALPHABET>(tree[0],ssl,pi);
//		}

//		if(flagL){
			std::string sR=stringFromSequence(s);
			sR=sR.substr(ixx);
			sequence_t<ALPHABET> ssr=sequenceFromStringPIP<ALPHABET>(sR);
//			return pr + compute_lk_gap_down<ALPHABET>(tree[1],ssr,pi);
			pR=compute_lk_gap_down<ALPHABET>(tree[1],ssr,pi);
//		}
	}

	return pr+pL+pR;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_lk_gap_down_s(PhyTree &tree,std::string &s,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

	double pr=0;
	double pL=0;
	double pR=0;
	int idx;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;
	double fv0;

	if(tree.isLeaf()){
		idx=0;
		fv=go_down_s<ALPHABET>(tree,s,idx);
		fv0=fv.dot(pi);
		pr=tree.get_iota()-tree.get_iota()*tree.get_beta()+tree.get_iota()*tree.get_beta()*fv0;

		return pr;
	}else{
		idx=0;
		fv=go_down_s<ALPHABET>(tree,s,idx);
		fv0=fv.dot(pi);
		pr=tree.get_iota()-tree.get_iota()*tree.get_beta()+tree.get_iota()*tree.get_beta()*fv0;

		bool flagL=true;
		bool flagR=true;
		idx=0;
		allgaps_s<ALPHABET>(tree[0],s,idx,flagL);
		int ixx=idx;
		allgaps_s<ALPHABET>(tree[1],s,idx,flagR);
		int len;

		std::string sL;//=stringFromSequence(s);
		len=ixx;
		sL=s.substr(0,len);
//		sequence_t<ALPHABET> ssl=sequenceFromStringPIP<ALPHABET>(sL);
		pL=compute_lk_gap_down_s<ALPHABET>(tree[0],sL,pi);

		std::string sR;//=stringFromSequence(s);
		sR=s.substr(ixx);
//		sequence_t<ALPHABET> ssr=sequenceFromStringPIP<ALPHABET>(sR);
		pR=compute_lk_gap_down_s<ALPHABET>(tree[1],sR,pi);
	}

	return pr+pL+pR;
}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//double nnsoancora(PhyTree &tree,sequence_t<ALPHABET> &s,int &idx,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){
//
//	double pr;
//	if(tree.isLeaf()){
//
//		int ii=s[idx].value();
//		Eigen::VectorXd fv=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//		ii=ii<0?ALPHABET::DIM:ii;
//		fv[ii]=1.0;
//		std::string c=stringFromSequence<ALPHABET>(s);
//		std::cout<<"nnsoancora("<<tree.getName()<<")="<<stringFromSequence(s)<<"["<<idx<<"] -> "<<c[idx]<<"\n";
//		std::cout<<fv.transpose()<<"\n";
//
//		idx++;
//
//		double fv0=fv.dot(pi);
//		pr=tree.get_iota()*tree.get_beta()*fv0;
//
//		return pr;
//
//	}else{
//
//		std::cout<<"nnsoancora("<<tree.getName()<<")="<<stringFromSequence(s)<<"\n";
//
//		int ixx=0;
//		bool flagL=true;
//		allgaps(tree[0],s,ixx,flagL);
//		bool flagR=true;
//		allgaps(tree[1],s,ixx,flagR);
//
//		std::cout<<"flagL: "<<flagL<<" ; flagR: "<<flagR<<"\n";
//
//		if(flagR){
//			nnsoancora<ALPHABET>(tree[0],s,idx,pi);
//		}
//
//		if(flagL){
//			nnsoancora<ALPHABET>(tree[1],s,idx,pi);
//		}
//
////		std::cout<<tree.getName()<<" idx:{"<<idx<<"}\n";
//
//	}
//
//	return pr;
//
//}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Xopt_all_edges_local_tree(	double valM,
											double valX,
											double valY,
											double nu,
											PhyTree &tree,
											sequence_t<ALPHABET> &sL,
											sequence_t<ALPHABET> &col_gap_R,
											Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
											int m,
											std::map<std::string,Eigen::VectorXd> &fv_0,
											std::map<std::string,double> &fv_X){

	double fv0;
	double pr;
	double val;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;
//	int idx;



	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
//	double fv0;
//	Eigen::VectorXd fv;

	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(col_gap_R));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		//------------------------------------------------------------------------------------------
		int idx=0;
		fvL=go_down_left(tree,sL,idx);

		idx=0;
		fvR=go_down_right(tree,col_gap_R,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv_0[s]=fv;

	}else{
		fv=it->second;
	}
	//------------------------------------------------------------------------------------------

//	idx=0;
//	fvL=go_down_left(tree,sL,idx);
//
//	idx=0;
//	fvR=go_down_right(tree,col_gap_R,0);
//
//	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	fv0=fv.dot(pi);

	pr=tree.get_iota()*tree.get_beta()*fv0;

//	std::cout<<"prX("<<stringFromSequence(sL)<<")"; printf(" %18.16lf\n",pr);

	double pL;

	typedef typename std::map<std::string,double>::iterator MapIterator_p;
	std::string sLs=stringFromSequence<ALPHABET>(sL);
	MapIterator_p itp=fv_X.find(sLs);
	if(itp == fv_X.end()){

		//------------------------------------------------------------------------------------------
		pL=compute_lk_down<ALPHABET>(tree[0],sL,pi);
		//------------------------------------------------------------------------------------------

		fv_X[sLs]=pL;

	}else{
		pL=itp->second;
	}

//	pL=compute_lk_down<ALPHABET>(tree[0],sL,pi);

//	std::cout<<"prL("<<stringFromSequence(sL)<<")"; printf(" %18.16lf\n",pL);

	pr+=pL;

	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Xopt_all_edges_local_tree_s(	double valM,
											double valX,
											double valY,
											double nu,
											PhyTree &tree,
											std::string &sL,
											std::string &col_gap_R,
											Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
											int m,
											std::map<std::string,Eigen::VectorXd> &fv_0,
											std::map<std::string,double> &fv_X){

	double fv0;
	double pr;
	double val;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;

	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(col_gap_R);

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		//------------------------------------------------------------------------------------------
		int idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],col_gap_R,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv_0[s]=fv;

	}else{
		fv=it->second;
	}
	//------------------------------------------------------------------------------------------

	fv0=fv.dot(pi);

	pr=tree.get_iota()*tree.get_beta()*fv0;

//	std::cout<<"prX("<<stringFromSequence(sL)<<")"; printf(" %18.16lf\n",pr);

	double pL;

	typedef typename std::map<std::string,double>::iterator MapIterator_p;
//	std::string sLs=stringFromSequence<ALPHABET>(sL);
	MapIterator_p itp=fv_X.find(sL);
	if(itp == fv_X.end()){

		//------------------------------------------------------------------------------------------
		pL=compute_lk_down_s<ALPHABET>(tree[0],sL,pi);
		//------------------------------------------------------------------------------------------

		fv_X[sL]=pL;

	}else{
		pL=itp->second;
	}

//	std::cout<<"prL("<<stringFromSequence(sL)<<")"; printf(" %18.16lf\n",pL);

	pr+=pL;

	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_X_local_tree_s_opt(double valM,
									double valX,
									double valY,
									double nu,
									PhyTree &tree,
									std::string &sL,
									std::string &col_gap_R,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									int m,
									std::map<std::string,double> &lkX){


	double pr;
	double val;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(col_gap_R);

	MapIterator it=lkX.find(s);
	if(it == lkX.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		int idx;
		double fv0;

		idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],col_gap_R,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		fv0=fv.dot(pi);


		std::cout<<"fvL: "<<fvL<<"\n\n";
		std::cout<<"fvR: "<<fvR<<"\n\n";

		printf("iota %lf beta %lf\n",tree.get_iota(),tree.get_beta());

		std::cout<<"fv: "<<fv<<"\n";



		std::cout<<"\n";
		std::cout<<"PrL:\n"<<std::endl;
		std::cout<<tree.get_left_child()->get_Pr()<<"\n";
		std::cout<<"PrR:\n"<<std::endl;
		std::cout<<tree.get_right_child()->get_Pr()<<"\n";
		std::cout<<"\n";



		pr=tree.get_iota()*tree.get_beta()*fv0;

		printf("pr %lf\n",pr);

#ifdef VERBOSE
		std::cout<<"prX("<<sL<<")"; printf(" %18.16lf\n",pr);
#endif

		double pL;

//		typedef typename std::map<std::string,double>::iterator MapIterator_p;
//		MapIterator_p itp=fv_X.find(sL);
//		if(itp == fv_X.end()){

		//------------------------------------------------------------------------------------------
		pL=compute_lk_down_s<ALPHABET>(tree[0],sL,pi);
		//------------------------------------------------------------------------------------------

//			fv_X[sL]=pL;
//
//		}else{
//			pL=itp->second;
//		}

#ifdef VERBOSE
		std::cout<<"pL("<<sL<<")"; printf(" %18.16lf\n",pL);
#endif

		pr+=pL;
		//------------------------------------------------------------------------------------------

		pr=log(pr);

		lkX[s]=pr;

	}else{
		pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"prXL("<<sL<<")"; printf(" %18.16lf\n",pr);
#endif


		printf("X: m %d nu %lf pr %lf valM %lf valX %lf valY %lf\n",m,nu,pr,valM,valX,valY);

		std::cout<<"L: "<<sL<<"; R: "<<col_gap_R<<std::endl;

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
	val=-log(double(m))+log(nu)+pr+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_X_local_tree_s_opt_SB(PhyTree &tree,
									std::string &sL,
									std::string &col_gap_R,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									std::map<std::string,double> &lkX){


	double log_pr;
	double pr;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(col_gap_R);

	MapIterator it=lkX.find(s);
	if(it == lkX.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		int idx;
		double fv0;

		idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],col_gap_R,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		fv0=fv.dot(pi);

		pr=tree.get_iota()*tree.get_beta()*fv0;

#ifdef VERBOSE
		std::cout<<"prX("<<sL<<")"; printf(" %18.16lf\n",log_pr);
#endif

		double pL;

//		typedef typename std::map<std::string,double>::iterator MapIterator_p;
//		MapIterator_p itp=fv_X.find(sL);
//		if(itp == fv_X.end()){

		//------------------------------------------------------------------------------------------
		pL=compute_lk_down_s<ALPHABET>(tree[0],sL,pi);
		//------------------------------------------------------------------------------------------

//			fv_X[sL]=pL;
//
//		}else{
//			pL=itp->second;
//		}

#ifdef VERBOSE
		std::cout<<"pL("<<sL<<")"; printf(" %18.16lf\n",pL);
#endif

		pr+=pL;
		//------------------------------------------------------------------------------------------

//		lkX[s]=pr;

		log_pr=log(pr);

		lkX[s]=log_pr;

	}else{
		log_pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"prXL("<<sL<<")"; printf(" %18.16lf\n",log_pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
//	val=1.0/(double(m) * nu * pr + (valM + valX + valY);

//	val=pr;

	return log_pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_X_all_edges_s_opt(double valM,
									double valX,
									double valY,
									double nu,
									PhyTree &tree,
									std::string &sL,
									std::string &col_gap_R,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									int m,
									std::map<std::string,double> &lkX){


	double pr;
	double val;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(col_gap_R);

	MapIterator it=lkX.find(s);
	if(it == lkX.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		int idx;
		double fv0;

		idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],col_gap_R,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		fv0=fv.dot(pi);

		pr=tree.get_iota()*tree.get_beta()*fv0;

#ifdef VERBOSE
		std::cout<<"prX("<<sL<<")"; printf(" %18.16lf\n",pr);
#endif

		double pL;

		//------------------------------------------------------------------------------------------
		pL=compute_lk_down_s<ALPHABET>(tree[0],sL,pi);
		//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"pL("<<sL<<")"; printf(" %18.16lf\n",pL);
#endif

		pr+=pL;
		//------------------------------------------------------------------------------------------


		//******************************************************************************************
		PhyTree *p_tree=&tree;

		while(p_tree->getParent()!=NULL){

			fv=(p_tree->get_Pr()*fv);

			fv0=fv.dot(pi);

			pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

			p_tree=p_tree->getParent();
		}
		//******************************************************************************************

		pr=log(pr);

		lkX[s]=pr;

	}else{
		pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"prXL("<<sL<<")"; printf(" %18.16lf\n",pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
	val=-log(double(m))+log(nu)+pr+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_X_all_edges_s_opt_SB(PhyTree &tree,
									std::string &sL,
									std::string &col_gap_R,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									std::map<std::string,double> &lkX){


	double log_pr;
	double pr;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(sL);
	s.append(col_gap_R);

	MapIterator it=lkX.find(s);
	if(it == lkX.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		int idx;
		double fv0;

		idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],sL,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],col_gap_R,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		fv0=fv.dot(pi);

		pr=tree.get_iota()*tree.get_beta()*fv0;

#ifdef VERBOSE
		std::cout<<"prX("<<sL<<")"; printf(" %18.16lf\n",pr);
#endif

		double pL;

		//------------------------------------------------------------------------------------------
		pL=compute_lk_down_s<ALPHABET>(tree[0],sL,pi);
		//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"pL("<<sL<<")"; printf(" %18.16lf\n",pL);
#endif

		pr+=pL;
		//------------------------------------------------------------------------------------------


		//******************************************************************************************
		PhyTree *p_tree=&tree;

		while(p_tree->getParent()!=NULL){

			fv=(p_tree->get_Pr()*fv);

			fv0=fv.dot(pi);

			pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

			p_tree=p_tree->getParent();
		}
		//******************************************************************************************


//		lkX[s]=pr;
		log_pr=log(pr);

		lkX[s]=log_pr;

	}else{
		log_pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"prXL("<<sL<<")"; printf(" %18.16lf\n",pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
//	val=1.0/(double(m) * nu * pr + (valM + valX + valY);

//	val=pr;

	return log_pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Xopt(	std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						double valM,
						double valX,
						double valY,
						int i,int j,
						double nu,
						ProgressivePIPResult<ALPHABET> &result_L,
						PhyTree &tree,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &col_gap_R,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double lk_gap,
						Eigen::MatrixXd &PX,
						int m){

	double Pa;
	double pc;
	double fv0;
	double val;

//	fv0=compute_fv_new_fast(fv_array,tree,sL,col_gap_R,matFv,pi);
	fv0=compute_fv_new(tree,fv_L,fv_R,fv_0,sL,col_gap_R,pi);

	pc=getPc(result_L,i);

	Pa=compute_Pa_new<ALPHABET>(tree,fv0,pc,pi,sL,lk_gap);

	PX(i+1,j)=Pa;

	val=-log(double(m))+log(nu)+log(Pa)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);


//	std::cout<<"\n-------------\n";
//	std::cout<<"gapx\n";
//	std::cout<<"fv0: "<<fv0<<"\n";
//	std::cout<<"pc: "<<pc<<"\n";
//	std::cout<<"Pa: "<<Pa<<"\n";
//	std::cout<<"m: "<<m<<"\n";
//	std::cout<<"nu: "<<nu<<"\n";
//	std::cout<<"lk_gap: "<<lk_gap<<"\n";


//	if(Pa<0){
//		perror("ERROR negative Log\n");
//		exit(EXIT_FAILURE);
//	}


	return val;
}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//double computeLK_Y(	Eigen::SparseMatrix<double,Eigen::RowMajor>*M,
//					Eigen::SparseMatrix<double,Eigen::RowMajor>*X,
//					Eigen::SparseMatrix<double,Eigen::RowMajor>*Y,
//					int i,int j,
//					double nu,
//					ProgressivePIPResult<ALPHABET> &result_L,
//					ProgressivePIPResult<ALPHABET> &result_R,
//					PhyTree &tree,
//					sequence_t<ALPHABET> col_gap_L,
//					sequence_t<ALPHABET> sR,
//					Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi,
//					std::map<std::string,Eigen::VectorXd> &temp_fv_map,
//					double lk_gap,
//					Eigen::MatrixXd &PY,
//					int m){
//
//	double Pb;
//	double pc;
//	double fv0;
//	double val;
//
//	fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,col_gap_L,sR,pi);
//
//	pc=getPc(result_R,j);
//
//	Pb=compute_Pb_new<ALPHABET>(tree,fv0,pc,pi,sR,lk_gap);
//
//	PY(i,j)=Pb;
//
//	val=-log(double(m))+log(nu)+log(Pb)+max_of_three_2((double)M->coeff(i,j-1),(double)X->coeff(i,j-1),(double)Y->coeff(i,j-1),(double)DBL_EPSILON);
//
//	return val;
//}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//double computeLK_Y_fast(Eigen::SparseMatrix<double,Eigen::RowMajor>*M,
//						Eigen::SparseMatrix<double,Eigen::RowMajor>*X,
//						Eigen::SparseMatrix<double,Eigen::RowMajor>*Y,
//						int i,int j,
//						double nu,
//						ProgressivePIPResult<ALPHABET> &result_R,
//						PhyTree &tree,
//						sequence_t<ALPHABET> col_gap_L,
//						sequence_t<ALPHABET> sR,
//						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi,
//						double lk_gap,
//						Eigen::MatrixXd &PY,
//						int m,
//						Eigen::MatrixXd &matFv){
//
//	double Pb;
//	double pc;
//	double fv0;
//	double val;
//
//	fv0=compute_fv_new_fast(tree,col_gap_L,sR,matFv,pi);
//
//	pc=getPc(result_R,j);
//
//	Pb=compute_Pb_new<ALPHABET>(tree,fv0,pc,pi,sR,lk_gap);
//
//	PY(i,j)=Pb;
//
//	val=-log(double(m))+log(nu)+log(Pb)+max_of_three_2((double)M->coeff(i,j-1),(double)X->coeff(i,j-1),(double)Y->coeff(i,j-1),(double)DBL_EPSILON);
//
//	return val;
//}
////=======================================================================================================
////DP-PIP
//template <class ALPHABET>
//double compute_pr_gapY_2(	PhyTree &tree,
//						std::map<std::string,Eigen::VectorXd> &map_L,
//						std::map<std::string,Eigen::VectorXd> &map_R,
//						std::map<std::string,Eigen::VectorXd> &map0,
//						sequence_t<ALPHABET> &sL,
//						sequence_t<ALPHABET> &sR,
//						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
//						double *pC,
//						double lk_gap){
//
//	double pr;
//	double pL;
//	double p0;
//	double pR;
//	double fv0;
//	Eigen::VectorXd fv;
//
//	/*
//	std::cout<<"\n";
//	std::cout<<tree.getName()<<" ("<<tree.get_left_child()->getName()<<","<<tree.get_right_child()->getName()<<")\n";
//	std::cout<<"SL: "<<stringFromSequence(sL)<<"\n";
//	std::cout<<"SR: "<<stringFromSequence(sR)<<"\n";
//	*/
//
//	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
//
//	MapIterator itL=map_L.find(stringFromSequence<ALPHABET>(sL));
//	if(itL == map_L.end()){
//		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sL);
//		exit(EXIT_FAILURE);
//	}
//	Eigen::VectorXd &fvL=itL->second;
//
//	MapIterator itR=map_R.find(stringFromSequence<ALPHABET>(sR));
//	if(itR == map_R.end()){
//		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sR);
//		exit(EXIT_FAILURE);
//	}
//	Eigen::VectorXd &fvR=itR->second;
//
//	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
//
//
//
//
//
//
//
//
//	std::string	s;
//	s.append(stringFromSequence(sL));
//	s.append(stringFromSequence(sR));
//
//	map0[s]=fv;
//
//
//
//
//
//
//
//
//	fv0=fv.dot(pi);
//
//
//	if(!tree[0].isLeaf()){
//		pL=lk_gap;
//	}else{
//		pL=0.0;
//	}
//
//	if(tree[1].isLeaf()){
//
//		double freq;
//		if(sR.length()!=1){
//			error("ERROR in compute_Pa");
//			exit(EXIT_FAILURE);
//		}
//
//		freq=pi(sR[0].value());
//
//		pR=freq*tree[1].get_iota() * tree[1].get_beta();
//	}else{
//		pR=0.0;
//	}
//
//
//	p0=tree.get_iota()*tree.get_beta()*fv0;
//
//	pr=p0 + pL + *pC +pR;
//
//
//	*pC=pr;
//
//
//	/*
//	std::cout<<"\n";
//	std::cout<<"p0: "<<p0<<"\n";
//	std::cout<<"pL: "<<pL<<"\n";
//	std::cout<<"pC: "<<pC<<"\n";
//	std::cout<<"pR: "<<pR<<"\n";
//	std::cout<<"\n";
//
//	std::cout<<"PR: "<<pr<<"\n";
//	*/
//
//
//	PhyTree *p_tree=&tree;
//
//	while(p_tree->getParent()!=NULL){
//
//		fv=(p_tree->get_Pr()*fv);
//
//		fv0=fv.dot(pi);
//
//		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);
//
//		/*
//		std::cout<<p_tree->getName()<<" ("<<p_tree->get_left_child()->getName()<<","<<p_tree->get_right_child()->getName()<<")\n";
//		std::cout<<"PR: "<<pr<<"\n";
//		*/
//
//		p_tree=p_tree->getParent();
//	}
//
//
//	return pr;
//}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Yopt_all_edges(std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						double valM,
						double valX,
						double valY,
						int j,
						double nu,
						ProgressivePIPResult<ALPHABET> &result_R,
						PhyTree &tree,
						sequence_t<ALPHABET> &col_gap_L,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double &lk,
						int m,
						double lk_gap){

//	double Pb;
//	double pc;
//	double fv0;
	double val;

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
	double fv0;
	Eigen::VectorXd fv;

	s.append(stringFromSequence(col_gap_L));
	s.append(stringFromSequence(sR));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		MapIterator itL=fv_L.find(stringFromSequence<ALPHABET>(col_gap_L));
		if(itL == fv_L.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(col_gap_L);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvL=itL->second;

		MapIterator itR=fv_R.find(stringFromSequence<ALPHABET>(sR));
		if(itR == fv_R.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sR);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvR=itR->second;

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}else{
		fv=it->second;
	}


	fv0=fv.dot(pi);

	fv_0[s]=fv;

	double pC;

	//pc=getPc(result_R,j);
	pC=getPc(result_R,j);

	double pr;
	double pL;
	double p0;
	double pR;
//	double fv0;


	if(!tree[0].isLeaf()){
		pL=lk_gap;
	}else{
		pL=0.0;
	}

	pL=0.0;

	if(tree[1].isLeaf()){

		double freq;
		if(sR.length()!=1){
			error("ERROR in compute_Pa");
			exit(EXIT_FAILURE);
		}

		freq=pi(sR[0].value());

		pR=freq*tree[1].get_iota() * tree[1].get_beta();
	}else{
		pR=0.0;
	}


	p0=tree.get_iota()*tree.get_beta()*fv0;

	pr=p0 + pL + pC +pR;


	pC=pr;

	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

		p_tree=p_tree->getParent();
	}

	//PY(i,j+1)=Pb;
//	PY(i,j+1)=pC;
	lk=pC;

//	val=-log(double(m))+log(nu)+log(Pb)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);


	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Yopt_all_edges_local_tree(double valM,
											double valX,
											double valY,
											double nu,
											PhyTree &tree,
											sequence_t<ALPHABET> &col_gap_L,
											sequence_t<ALPHABET> &sR,
											Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
											int m,
											std::map<std::string,Eigen::VectorXd> &fv_0,
											std::map<std::string,double> &fv_Y){

	double fv0;
	double pr;
	double val;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;

	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
//	double fv0;
//	Eigen::VectorXd fv;

	s.append(stringFromSequence(col_gap_L));
	s.append(stringFromSequence(sR));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		//------------------------------------------------------------------------------------------
		int idx=0;
		fvL=go_down_left(tree,col_gap_L,idx);

		idx=0;
		fvR=go_down_right(tree,sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv_0[s]=fv;

	}else{
		fv=it->second;
	}
	//------------------------------------------------------------------------------------------


//	fvL=go_down_left(tree,col_gap_L,0);
//	fvR=go_down_right(tree,sR,0);
//
//	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	fv0=fv.dot(pi);

	pr=tree.get_iota()*tree.get_beta()*fv0;

//	std::cout<<"prY("<<stringFromSequence(sR)<<")"; printf(" %18.16lf\n",pr);

	double pR;
	typedef typename std::map<std::string,double>::iterator MapIterator_p;
	std::string sRs=stringFromSequence<ALPHABET>(sR);
	MapIterator_p itp=fv_Y.find(sRs);
	if(itp == fv_Y.end()){

		//------------------------------------------------------------------------------------------
		pR=compute_lk_down<ALPHABET>(tree[1],sR,pi);
		//------------------------------------------------------------------------------------------

		fv_Y[sRs]=pR;

	}else{
		pR=itp->second;
	}

//	pR=compute_lk_down<ALPHABET>(tree[1],sR,pi);

//	std::cout<<"prR("<<stringFromSequence(sR)<<")"; printf(" %18.16lf\n",pR);

	pr+=pR;

	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Yopt_all_edges_local_tree_s(double valM,
											double valX,
											double valY,
											double nu,
											PhyTree &tree,
											std::string &col_gap_L,
											std::string &sR,
											Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
											int m,
											std::map<std::string,Eigen::VectorXd> &fv_0,
											std::map<std::string,double> &fv_Y){

	double fv0;
	double pr;
	double val;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;

	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;

	s.append(col_gap_L);
	s.append(sR);

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		//------------------------------------------------------------------------------------------
		int idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],col_gap_L,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv_0[s]=fv;

	}else{
		fv=it->second;
	}
	//------------------------------------------------------------------------------------------

	fv0=fv.dot(pi);

	pr=tree.get_iota()*tree.get_beta()*fv0;

//	std::cout<<"prY("<<stringFromSequence(sR)<<")"; printf(" %18.16lf\n",pr);

	double pR;
	typedef typename std::map<std::string,double>::iterator MapIterator_p;
//	std::string sRs=stringFromSequence<ALPHABET>(sR);
	MapIterator_p itp=fv_Y.find(sR);
	if(itp == fv_Y.end()){

		//------------------------------------------------------------------------------------------
		pR=compute_lk_down_s<ALPHABET>(tree[1],sR,pi);
		//------------------------------------------------------------------------------------------

		fv_Y[sR]=pR;

	}else{
		pR=itp->second;
	}

//	std::cout<<"prR("<<stringFromSequence(sR)<<")"; printf(" %18.16lf\n",pR);

	pr+=pR;

	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Y_local_tree_s_opt(double valM,
									double valX,
									double valY,
									double nu,
									PhyTree &tree,
									std::string &col_gap_L,
									std::string &sR,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									int m,
									std::map<std::string,double> &lkY){


	double pr;
	double val;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(col_gap_L);
	s.append(sR);

	MapIterator it=lkY.find(s);
	if(it == lkY.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		double fv0;
		int idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],col_gap_L,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv0=fv.dot(pi);

		std::cout<<"fvL: "<<fvL<<"\n\n";
		std::cout<<"fvR: "<<fvR<<"\n\n";


		printf("iota %lf beta %lf\n",tree.get_iota(),tree.get_beta());

		std::cout<<"fv: "<<fv<<"\n";



		std::cout<<"\n";
		std::cout<<"PrL:\n"<<std::endl;
		std::cout<<tree.get_left_child()->get_Pr()<<"\n";
		std::cout<<"PrR:\n"<<std::endl;
		std::cout<<tree.get_right_child()->get_Pr()<<"\n";
		std::cout<<"\n";


			pr=tree.get_iota()*tree.get_beta()*fv0;


			printf("pr %lf\n",pr);

#ifdef VERBOSE
		std::cout<<"prY("<<sR<<")"; printf(" %18.16lf\n",pr);
#endif


			double pR;
//			typedef typename std::map<std::string,double>::iterator MapIterator_p;
//		//	std::string sRs=stringFromSequence<ALPHABET>(sR);
//			MapIterator_p itp=fv_Y.find(sR);
//			if(itp == fv_Y.end()){

			//------------------------------------------------------------------------------------------
			pR=compute_lk_down_s<ALPHABET>(tree[1],sR,pi);
			//------------------------------------------------------------------------------------------

//				fv_Y[sR]=pR;

//			}else{
//				pR=itp->second;
//			}

#ifdef VERBOSE
		std::cout<<"pR("<<sR<<")"; printf(" %18.16lf\n",pR);
#endif
			pr+=pR;

			pr=log(pr);

		lkY[s]=pr;

	}else{
		pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"prYR("<<sR<<")"; printf(" %18.16lf\n",pr);
#endif



		printf("Y: m %d nu %lf pr %lf valM %lf valX %lf valY %lf\n",m,nu,pr,valM,valX,valY);

		std::cout<<"L: "<<col_gap_L<<"; R: "<<sR<<std::endl;

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
	val=-log(double(m))+log(nu)+pr+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Y_local_tree_s_opt_SB(PhyTree &tree,
									std::string &col_gap_L,
									std::string &sR,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									std::map<std::string,double> &lkY){


	double log_pr;
	double pr;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(col_gap_L);
	s.append(sR);

	MapIterator it=lkY.find(s);
	if(it == lkY.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		double fv0;
		int idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],col_gap_L,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv0=fv.dot(pi);

			pr=tree.get_iota()*tree.get_beta()*fv0;

#ifdef VERBOSE
		std::cout<<"prY("<<sR<<")"; printf(" %18.16lf\n",pr);
#endif


			double pR;
//			typedef typename std::map<std::string,double>::iterator MapIterator_p;
//		//	std::string sRs=stringFromSequence<ALPHABET>(sR);
//			MapIterator_p itp=fv_Y.find(sR);
//			if(itp == fv_Y.end()){

			//------------------------------------------------------------------------------------------
			pR=compute_lk_down_s<ALPHABET>(tree[1],sR,pi);
			//------------------------------------------------------------------------------------------

//				fv_Y[sR]=pR;

//			}else{
//				pR=itp->second;
//			}

#ifdef VERBOSE
		std::cout<<"pR("<<sR<<")"; printf(" %18.16lf\n",pR);
#endif
			pr+=pR;

//		lkY[s]=pr;

		log_pr=log(pr);

		lkY[s]=log_pr;

	}else{
		log_pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"prYR("<<sR<<")"; printf(" %18.16lf\n",pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
//	val=1.0/(double(m) * nu * pr + (valM + valX + valY);

//	val=pr;

	return log_pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Y_all_edges_s_opt(double valM,
									double valX,
									double valY,
									double nu,
									PhyTree &tree,
									std::string &col_gap_L,
									std::string &sR,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									int m,
									std::map<std::string,double> &lkY){


	double pr;
	double val;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(col_gap_L);
	s.append(sR);

	MapIterator it=lkY.find(s);
	if(it == lkY.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		double fv0;
		int idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],col_gap_L,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv0=fv.dot(pi);

		pr=tree.get_iota()*tree.get_beta()*fv0;

#ifdef VERBOSE
		std::cout<<"prY("<<sR<<")"; printf(" %18.16lf\n",pr);
#endif


		double pR;

		//------------------------------------------------------------------------------------------
		pR=compute_lk_down_s<ALPHABET>(tree[1],sR,pi);
		//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"pR("<<sR<<")"; printf(" %18.16lf\n",pR);
#endif

		pr+=pR;

		//*******************************************************************************************
		PhyTree *p_tree=&tree;

		while(p_tree->getParent()!=NULL){

			fv=(p_tree->get_Pr()*fv);

			fv0=fv.dot(pi);

			pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

			p_tree=p_tree->getParent();
		}
		//*******************************************************************************************

		pr=log(pr);

		lkY[s]=pr;

	}else{
		pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"prYR("<<sR<<")"; printf(" %18.16lf\n",pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
	val=-log(double(m))+log(nu)+pr+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Y_all_edges_s_opt_SB(PhyTree &tree,
									std::string &col_gap_L,
									std::string &sR,
									Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
									std::map<std::string,double> &lkY){


	double log_pr;
	double pr;
	//------------------------------------------------------------------------------------------
	typedef typename std::map<std::string,double>::iterator MapIterator;
	std::string s;

	s.append(col_gap_L);
	s.append(sR);

	MapIterator it=lkY.find(s);
	if(it == lkY.end()){

		//------------------------------------------------------------------------------------------
		Eigen::VectorXd fvL;
		Eigen::VectorXd fvR;
		Eigen::VectorXd fv;
		double fv0;
		int idx=0;
		fvL=go_down_s<ALPHABET>(tree[0],col_gap_L,idx);

		idx=0;
		fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
		//------------------------------------------------------------------------------------------

		fv0=fv.dot(pi);

		pr=tree.get_iota()*tree.get_beta()*fv0;

#ifdef VERBOSE
		std::cout<<"prY("<<sR<<")"; printf(" %18.16lf\n",pr);
#endif


		double pR;

		//------------------------------------------------------------------------------------------
		pR=compute_lk_down_s<ALPHABET>(tree[1],sR,pi);
		//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"pR("<<sR<<")"; printf(" %18.16lf\n",pR);
#endif

		pr+=pR;

		//*******************************************************************************************
		PhyTree *p_tree=&tree;

		while(p_tree->getParent()!=NULL){

			fv=(p_tree->get_Pr()*fv);

			fv0=fv.dot(pi);

			pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

			p_tree=p_tree->getParent();
		}
		//*******************************************************************************************

//		lkY[s]=pr;

		log_pr=log(pr);

		lkY[s]=log_pr;

	}else{
		log_pr=it->second;
	}
	//------------------------------------------------------------------------------------------

#ifdef VERBOSE
		std::cout<<"prYR("<<sR<<")"; printf(" %18.16lf\n",pr);
#endif

//	val=-log(double(m))+log(nu)+log(pr)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);
//	val=1.0/(double(m) * nu * pr + (valM + valX + valY);

//	val=pr;

	return log_pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Yopt(	std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						double valM,
						double valX,
						double valY,
						int i,int j,
						double nu,
						ProgressivePIPResult<ALPHABET> &result_R,
						PhyTree &tree,
						sequence_t<ALPHABET> &col_gap_L,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double lk_gap,
						Eigen::MatrixXd &PY,
						int m){

	double Pb;
	double pc;
	double fv0;
	double val;


//	fv0=compute_fv_new_fast(fv_array,tree,col_gap_L,sR,matFv,pi);
	fv0=compute_fv_new(tree,fv_L,fv_R,fv_0,col_gap_L,sR,pi);

	pc=getPc(result_R,j);

	Pb=compute_Pb_new<ALPHABET>(tree,fv0,pc,pi,sR,lk_gap);

	PY(i,j+1)=Pb;

	val=-log(double(m))+log(nu)+log(Pb)+max_of_three_2(valM,valX,valY,(double)DBL_EPSILON);

//	std::cout<<"\n-------------\n";
//	std::cout<<"gapy\n";
//	std::cout<<"fv0: "<<fv0<<"\n";
//	std::cout<<"pc: "<<pc<<"\n";
//	std::cout<<"Pb: "<<Pb<<"\n";
//	std::cout<<"m: "<<m<<"\n";
//	std::cout<<"nu: "<<nu<<"\n";
//	std::cout<<"lk_gap: "<<lk_gap<<"\n";


//	if(Pb<0){
//		perror("ERROR negative Log\n");
//		exit(EXIT_FAILURE);
//	}




	return val;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
Eigen::VectorXd recursive_fv(PhyTree &tree,Eigen::MatrixXd &matFv,sequence_t<ALPHABET> &colMSA,int &idx){
	Eigen::VectorXd fv;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;

	if(tree.isLeaf()){

		int k;
		k=colMSA[idx].value();

		if(k<0){
			k=int(ALPHABET::DIM);
		}

		fv=matFv.row(k);

		idx=idx+1;

	}else{
		fvL=recursive_fv(tree[0],matFv,colMSA,idx);
		fvR=recursive_fv(tree[1],matFv,colMSA,idx);

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
	}

	return fv;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_pr_gapX_2(	PhyTree &tree,
						std::map<std::string,Eigen::VectorXd> &map_L,
						std::map<std::string,Eigen::VectorXd> &map_R,
						std::map<std::string,Eigen::VectorXd> &map0,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double *pC,
						double lk_gap){

	double pr;
	double pL;
	double p0;
	double pR;
	double fv0;
	Eigen::VectorXd fv;


	/*
	std::cout<<"\n";
	std::cout<<tree.getName()<<" ("<<tree.get_left_child()->getName()<<","<<tree.get_right_child()->getName()<<")\n";
	std::cout<<"SL: "<<stringFromSequence(sL)<<"\n";
	std::cout<<"SR: "<<stringFromSequence(sR)<<"\n";
	*/


	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;

	MapIterator itL=map_L.find(stringFromSequence<ALPHABET>(sL));
	if(itL == map_L.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sL);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvL=itL->second;

	MapIterator itR=map_R.find(stringFromSequence<ALPHABET>(sR));
	if(itR == map_R.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sR);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvR=itR->second;

	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);






	std::string	s;
	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(sR));

	map0[s]=fv;










	fv0=fv.dot(pi);


	if(!tree[1].isLeaf()){
		pR=lk_gap;
	}else{
		pR=0.0;
	}

	if(tree[0].isLeaf()){

		double freq;
		if(sL.length()!=1){
			error("ERROR in compute_Pa");
			exit(EXIT_FAILURE);
		}

		freq=pi(sL[0].value());

		pL=freq*tree[0].get_iota() * tree[0].get_beta();
	}else{
		pL=0.0;
	}


	p0=tree.get_iota()*tree.get_beta()*fv0;
	pr=p0 + pL + *pC +pR;



	*pC=pr;


	/*
	std::cout<<"\n";
	std::cout<<"p0: "<<p0<<"\n";
	std::cout<<"pL: "<<pL<<"\n";
	std::cout<<"pC: "<<pC<<"\n";
	std::cout<<"pR: "<<pR<<"\n";
	std::cout<<"\n";

	std::cout<<"PR: "<<pr<<"\n";
	*/

	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

		/*
		std::cout<<p_tree->getName()<<" ("<<p_tree->get_left_child()->getName()<<","<<p_tree->get_right_child()->getName()<<")\n";
		std::cout<<"PR: "<<pr<<"\n";
		*/

		p_tree=p_tree->getParent();
	}


	return pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_pr_gapY_2(	PhyTree &tree,
						std::map<std::string,Eigen::VectorXd> &map_L,
						std::map<std::string,Eigen::VectorXd> &map_R,
						std::map<std::string,Eigen::VectorXd> &map0,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						double *pC,
						double lk_gap){

	double pr;
	double pL;
	double p0;
	double pR;
	double fv0;
	Eigen::VectorXd fv;

	/*
	std::cout<<"\n";
	std::cout<<tree.getName()<<" ("<<tree.get_left_child()->getName()<<","<<tree.get_right_child()->getName()<<")\n";
	std::cout<<"SL: "<<stringFromSequence(sL)<<"\n";
	std::cout<<"SR: "<<stringFromSequence(sR)<<"\n";
	*/

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;

	MapIterator itL=map_L.find(stringFromSequence<ALPHABET>(sL));
	if(itL == map_L.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sL);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvL=itL->second;

	MapIterator itR=map_R.find(stringFromSequence<ALPHABET>(sR));
	if(itR == map_R.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sR);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvR=itR->second;

	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);








	std::string	s;
	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(sR));

	map0[s]=fv;








	fv0=fv.dot(pi);


	if(!tree[0].isLeaf()){
		pL=lk_gap;
	}else{
		pL=0.0;
	}

	if(tree[1].isLeaf()){

		double freq;
		if(sR.length()!=1){
			error("ERROR in compute_Pa");
			exit(EXIT_FAILURE);
		}

		freq=pi(sR[0].value());

		pR=freq*tree[1].get_iota() * tree[1].get_beta();
	}else{
		pR=0.0;
	}


	p0=tree.get_iota()*tree.get_beta()*fv0;

	pr=p0 + pL + *pC +pR;


	*pC=pr;


	/*
	std::cout<<"\n";
	std::cout<<"p0: "<<p0<<"\n";
	std::cout<<"pL: "<<pL<<"\n";
	std::cout<<"pC: "<<pC<<"\n";
	std::cout<<"pR: "<<pR<<"\n";
	std::cout<<"\n";

	std::cout<<"PR: "<<pr<<"\n";
	*/


	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

		/*
		std::cout<<p_tree->getName()<<" ("<<p_tree->get_left_child()->getName()<<","<<p_tree->get_right_child()->getName()<<")\n";
		std::cout<<"PR: "<<pr<<"\n";
		*/

		p_tree=p_tree->getParent();
	}


	return pr;
}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//static ProgressivePIPResult<ALPHABET> compute_DP_PIP(ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,std::ostream& fileTr){
//
//
//	ProgressivePIPResult<ALPHABET> result;
//
//	int h=get_length_seq(result_L.MSA)+1;
//	int w=get_length_seq(result_R.MSA)+1;
//
//	//-------------------------------
////	PrintVector(result_L.MSA);
////	PrintVector(result_R.MSA);
//	//-------------------------------
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	int d_binary=2; //
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogM = initialize_MatrixSparse3D(h,w,d_binary);
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogX = initialize_MatrixSparse3D(h,w,d_binary);
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogY = initialize_MatrixSparse3D(h,w,d_binary);
//
//	int d=(h-1)+(w-1)+1;
//	Eigen::SparseMatrix<int,Eigen::RowMajor>** TR = initialize_MatrixSparse3D_int(h,w,d);
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	Eigen::MatrixXd PX(h,w);
//	Eigen::MatrixXd PY(h,w);
//	Eigen::MatrixXd PM(h,w);
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();
//
//	double pc0;
//	double fv0;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	sequence_t<ALPHABET> sL;
//	sequence_t<ALPHABET> sR;
//	sequence_t<ALPHABET> col_gap_L;
//	sequence_t<ALPHABET> col_gap_R;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	col_gap_L=create_col_MSA_gap(result_L.MSA);
//	col_gap_R=create_col_MSA_gap(result_R.MSA);
//
//	std::map<std::string,Eigen::VectorXd> temp_fv_map;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	double lk_gap;
//	double pc0_subtree;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//std::cout<<"random generator ON\n";
//	unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
//
////	seed=1636973879;
//	//std::cout<<"seed: "<<seed<<"\n";
//
//	std::default_random_engine generator(seed);
////	std::default_random_engine generator(1);
//	std::uniform_real_distribution<double> distribution(0.0,1.0);
//
//
//
//
////	double random_number;
////	for(int i=0;i<1000;i++){
////		random_number=distribution(generator);
////		std::cout<<"r = "<<random_number<<"\n";
////	}
////	exit(EXIT_SUCCESS);
//
//
//	//.-----.------.------.//
////	std::cout<<"random generator OFF\n";
////	unsigned seed = 0;
////	std::default_random_engine generator(seed);
////	std::uniform_real_distribution<double> distribution(0.0,1.0);
////	double random_number;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	double epsilon=DBL_EPSILON;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	if(!tree[0].isLeaf()){
//		if(result_L.Pc.size()!=(h-1)){
//			error("DIMENSION wrong\n");
//		}
//	}
//	if(!tree[1].isLeaf()){
//		if(result_R.Pc.size()!=(w-1)){
//			error("DIMENSION wrong\n");
//		}
//	}
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	std::vector< std::pair<int,int> > list_m_1;
////	std::vector< std::pair<int,int> > list_m_2;
////	std::vector< std::pair<int,int> > list_x_1;
////	std::vector< std::pair<int,int> > list_x_2;
////	std::vector< std::pair<int,int> > list_y_1;
////	std::vector< std::pair<int,int> > list_y_2;
////	std::vector< std::pair<int,int> > list_tr;
//
//	std::set< std::pair<int,int> > list_m_1;
//	std::set< std::pair<int,int> > list_x_1;
//	std::set< std::pair<int,int> > list_y_1;
//	std::set< std::pair<int,int> > list_m_2;
//	std::set< std::pair<int,int> > list_x_2;
//	std::set< std::pair<int,int> > list_y_2;
//	std::set< std::pair<int,int> > list_tr;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,col_gap_L,col_gap_R,pi);
//
//	lk_gap=result_L.lk_gap+result_R.lk_gap;
//	pc0_subtree=result_L.pc0+result_R.pc0;
//
//	result.lk_gap=0.0;//lk_gap+tree.get_iota()*tree.get_beta()*fv0;
//
//	pc0=compute_Pe_new(tree,fv0,pc0_subtree);
//
//	result.pc0=pc0;
//
//	(*LogM[0]).coeffRef(0,0)=nu*(pc0-1.0);
//	(*LogX[0]).coeffRef(0,0)=nu*(pc0-1.0);
//	(*LogY[0]).coeffRef(0,0)=nu*(pc0-1.0);
//
//
//	(*TR[0]).coeffRef(0,0)=STOP_STATE;
//
////	list_m_1.push_back(std::pair<int,int>(0,0));
////	list_x_1.push_back(std::pair<int,int>(0,0));
////	list_y_1.push_back(std::pair<int,int>(0,0));
//
//	list_m_1.insert(std::pair<int,int>(0,0));
//	list_x_1.insert(std::pair<int,int>(0,0));
//	list_y_1.insert(std::pair<int,int>(0,0));
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	typedef typename std::vector<std::pair<int,int> > ::const_iterator it_pair;
//	typedef typename std::set< std::pair<int,int> > ::const_iterator it_pair;
//
//	double max_of_3;
//	double max_lk=-INFINITY;
//	int level_max_lk;
//	double val;
//	int m_binary_this;
//	int m_binary_prev;
//
//
//	int counter=0;
//	int max_counter=10;
//	bool flag_exit=false;
//
//	for(int m=1;m<d;m++){
//
//		if(flag_exit){
//			break;
//		}
//
//
//		m_binary_this=m%2;
//		m_binary_prev=(m+1)%2;
//
////		next_nonzero_elements(&list_m_1,&list_x_1,&list_y_1,&list_m_2,&list_x_2,&list_y_2,h,w);
////
////		std::sort(list_m_2.begin(),list_m_2.end());
////		std::sort(list_x_2.begin(),list_x_2.end());
////		std::sort(list_y_2.begin(),list_y_2.end());
////
////		list_m_2.erase(std::unique(list_m_2.begin(),list_m_2.end()),list_m_2.end());
////		list_x_2.erase(std::unique(list_x_2.begin(),list_x_2.end()),list_x_2.end());
////		list_y_2.erase(std::unique(list_y_2.begin(),list_y_2.end()),list_y_2.end());
////
////		std::swap(list_m_1,list_m_2);
////		std::swap(list_x_1,list_x_2);
////		std::swap(list_y_1,list_y_2);
//
//		next_nonzero_elements_set(list_m_1,list_x_1,list_y_1,list_m_2,list_x_2,list_y_2,h,w);
//
//		list_tr.clear();
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_m_1.begin();it!=list_m_1.end();it++){
//			sL=create_col_MSA(result_L.MSA,it->first-1);
//			sR=create_col_MSA(result_R.MSA,it->second-1);
//
//			//-----------------------------------------------------------
////			std::cout<<"M"<<"("<<m<<")"<<"\n";
////			std::cout<<"it->first: "<<it->first<<"\n";
////			std::cout<<"it->second: "<<it->second<<"\n";
////			std::cout<<"seq: "<<stringFromSequence<ALPHABET>(sL)<<"\n";
////			std::cout<<"seq: "<<stringFromSequence<ALPHABET>(sR)<<"\n\n";
//			//-----------------------------------------------------------
//
//			val=computeLK_M(LogM[m_binary_prev],
//							LogX[m_binary_prev],
//							LogY[m_binary_prev],
//							it->first,it->second,
//							nu,
//							result_L,result_R,tree,
//							sL,sR,
//							pi,
//							temp_fv_map,
//							lk_gap,
//							PM,
//							m);
//
//			(*LogM[m_binary_this]).coeffRef(it->first,it->second)=val;
//
////			list_tr.push_back(std::pair<int,int>(it->first,it->second));
//			list_tr.insert(std::pair<int,int>(it->first,it->second));
//		}
//
//
//
//
//
//		//-----------------------------------------------------------
////		std::cout<<"M:\n";
////		std::cout<<"level: "<<m<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
////				printf("%+18.16f  ",LogM[m_binary_this]->coeff(j,k));
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
//		//-----------------------------------------------------------
//
//
//
//
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_x_1.begin();it!=list_x_1.end();it++){
//			sL=create_col_MSA(result_L.MSA,it->first-1);
//
//			//-----------------------------------------------------------
////			std::cout<<"X"<<"("<<m<<")"<<"\n";
////			std::cout<<"it->first: "<<it->first<<"\n";
////			std::cout<<"it->second: "<<it->second<<"\n";
////			std::cout<<"seq: "<<stringFromSequence<ALPHABET>(sL)<<"\n\n";
//			//-----------------------------------------------------------
//
//			val=computeLK_X(LogM[m_binary_prev],
//							LogX[m_binary_prev],
//							LogY[m_binary_prev],
//							it->first,it->second,
//							nu,
//							result_L,result_R,tree,
//							sL,col_gap_R,
//							pi,
//							temp_fv_map,
//							lk_gap,
//							PX,
//							m);
//
//			(*LogX[m_binary_this]).coeffRef(it->first,it->second)=val;
//
////			list_tr.push_back(std::pair<int,int>(it->first,it->second));
//			list_tr.insert(std::pair<int,int>(it->first,it->second));
//		}
//
//
//
//
//		//-----------------------------------------------------------
////		std::cout<<"X:\n";
////		std::cout<<"level: "<<m<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
////				printf("%+18.16f  ",LogX[m_binary_this]->coeff(j,k));
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
//		//-----------------------------------------------------------
//
//
//
//
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_y_1.begin();it!=list_y_1.end();it++){
//			sR=create_col_MSA(result_R.MSA,it->second-1);
//
//			//-----------------------------------------------------------
////			std::cout<<"Y"<<"("<<m<<")"<<"\n";
////			std::cout<<"it->first: "<<it->first<<"\n";
////			std::cout<<"it->second: "<<it->second<<"\n";
////			std::cout<<"seq: "<<stringFromSequence<ALPHABET>(sR)<<"\n\n";
//			//-----------------------------------------------------------
//
//			val=computeLK_Y(LogM[m_binary_prev],
//							LogX[m_binary_prev],
//							LogY[m_binary_prev],
//							it->first,it->second,
//							nu,
//							result_L,result_R,tree,
//							col_gap_L,sR,
//							pi,
//							temp_fv_map,
//							lk_gap,
//							PY,
//							m);
//
//			(*LogY[m_binary_this]).coeffRef(it->first,it->second)=val;
//
////			list_tr.push_back(std::pair<int,int>(it->first,it->second));
//			list_tr.insert(std::pair<int,int>(it->first,it->second));
//		}
//
//
//
//
//
//
//		//-----------------------------------------------------------
////		std::cout<<"Y:\n";
////		std::cout<<"level: "<<m<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
////				printf("%+18.16f  ",LogY[m_binary_this]->coeff(j,k));
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
//		//-----------------------------------------------------------
//
//
//
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////		std::sort(list_tr.begin(),list_tr.end());
////		list_tr.erase(std::unique(list_tr.begin(),list_tr.end()),list_tr.end());
//
//		for(it_pair it=list_tr.begin();it!=list_tr.end();it++){
//
//			if(TR[m]->coeff(it->first,it->second)!=0){
//				std::cout<<"already assigned!!!\n";
//				exit(EXIT_FAILURE);
//			}
//
//			double mval=fabs((double)LogM[m_binary_this]->coeff(it->first,it->second))<epsilon?-INFINITY:(double)LogM[m_binary_this]->coeff(it->first,it->second);
//			double xval=fabs((double)LogX[m_binary_this]->coeff(it->first,it->second))<epsilon?-INFINITY:(double)LogX[m_binary_this]->coeff(it->first,it->second);
//			double yval=fabs((double)LogY[m_binary_this]->coeff(it->first,it->second))<epsilon?-INFINITY:(double)LogY[m_binary_this]->coeff(it->first,it->second);
//
//
//
//
//			//.-.-.-.-.-.-.-.-.
////			if( (result_R.MSA.at(0).first == "t1") & (m==8) & (it->first == 7) & (it->second==4) ){
////
////				(*TR[m]).coeffRef(it->first,it->second)=3;//index_of_max_4(mval,xval,yval,epsilon,generator,distribution);
////
////			}
//			//.-.-.-.-.-.-.-.-.
//
//
//
//
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////			random_number = distribution(generator);
//
//			(*TR[m]).coeffRef(it->first,it->second)=index_of_max_3(mval,xval,yval,epsilon,generator,distribution);
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////			(*TR[m]).coeffRef(it->first,it->second)=index_of_max(mval,xval,yval);
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//			if( (it->first==(h-1)) & (it->second==(w-1)) ){
//
//
//
//
//
////				if(result_R.MSA.at(0).first == "t1"){
////					//______________________________________________
////					//______________________________________________
////					if(m==9){
////					max_of_3=max_of_three_2(mval,xval,yval,epsilon);
////					max_lk=max_of_3;
////					level_max_lk=9;
////					}
////					//______________________________________________
////					//______________________________________________
////				}else{
//
//				max_of_3=max_of_three_2(mval,xval,yval,epsilon);
//
//				if(max_of_3>max_lk){
//					max_lk=max_of_3;
//					level_max_lk=m;
//				}else{
//					counter++;
//					if(counter>max_counter){
//						flag_exit=true;
//						break;
//					}
//				}
//
//
//				//std::cout<<m<<"\t"<<max_of_3<<"\n";
//
//
//
////				}
//
//
//				//--------------------------------------------------
////				std::cout<<"level: "<<m<<" -> ";
////				std::cout<<mval<<",";
////				std::cout<<xval<<",";
////				std::cout<<yval<<" -> ";
////				std::cout<<TR[m]->coeff(h-1,w-1)<<"\n";
//				//--------------------------------------------------
//
//
//
//
//
//
//
//			}
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//		}
//
//
//
//		//-----------------------------------------------------------
//		//-----------------------------------------------------------
//		//-----------------------------------------------------------
//		//-----------------------------------------------------------
//		//-----------------------------------------------------------
////		if( (result_R.MSA.at(0).first == "t1") & (m==8)){
////
////			if(TR[m]->coeff(7,4)==3){
////				flag_MSA_che_cerco=true;
////			}
////
////		}
//		//-----------------------------------------------------------
//		//-----------------------------------------------------------
//		//-----------------------------------------------------------
//		//-----------------------------------------------------------
//		//-----------------------------------------------------------
//
//
//
//
//		//-----------------------------------------------------------
////		std::cout<<"TR:\n";
////		std::cout<<"level: "<<m<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
////				printf("%d  ",TR[m]->coeff(j,k));
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
//		//-----------------------------------------------------------
//
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_m_1.begin();it!=list_m_1.end();it++){
//			(*LogM[m_binary_prev]).coeffRef(it->first-1,it->second-1)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first-1,it->second-1)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first-1,it->second-1)=0.0;
//			(*LogM[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//		}
//		for(it_pair it=list_x_1.begin();it!=list_x_1.end();it++){
//			(*LogM[m_binary_prev]).coeffRef(it->first-1,it->second)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first-1,it->second)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first-1,it->second)=0.0;
//			(*LogM[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//		}
//		for(it_pair it=list_y_1.begin();it!=list_y_1.end();it++){
//			(*LogM[m_binary_prev]).coeffRef(it->first,it->second-1)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first,it->second-1)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first,it->second-1)=0.0;
//			(*LogM[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//		}
//
//
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
////				printf("%+18.16f  ",LogM[m_binary_prev]->coeff(j,k));
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
////				printf("%+18.16f  ",LogX[m_binary_prev]->coeff(j,k));
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
////				printf("%+18.16f  ",LogY[m_binary_prev]->coeff(j,k));
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
//
//
//
//
//
//
////		LogM[m_binary_prev]->setZero();
////		LogX[m_binary_prev]->setZero();
////		LogY[m_binary_prev]->setZero();
//
////		for(it_pair it=list_m_1.begin();it!=list_m_1.end();it++){
////			printf("%f \n",LogM[m_binary_prev]->coeff(it->first-1,it->second-1));
////			printf("%f \n",LogX[m_binary_prev]->coeff(it->first-1,it->second-1));
////			printf("%f \n",LogY[m_binary_prev]->coeff(it->first-1,it->second-1));
////			printf("%f \n",LogM[m_binary_prev]->coeff(it->first,it->second));
////			printf("%f \n",LogX[m_binary_prev]->coeff(it->first,it->second));
////			printf("%f \n",LogY[m_binary_prev]->coeff(it->first,it->second));
////		}
////		for(it_pair it=list_x_1.begin();it!=list_x_1.end();it++){
////			printf("%f \n",LogM[m_binary_prev]->coeff(it->first-1,it->second));
////			printf("%f \n",LogX[m_binary_prev]->coeff(it->first-1,it->second));
////			printf("%f \n",LogY[m_binary_prev]->coeff(it->first-1,it->second));
////			printf("%f \n",LogM[m_binary_prev]->coeff(it->first,it->second));
////			printf("%f \n",LogX[m_binary_prev]->coeff(it->first,it->second));
////			printf("%f \n",LogY[m_binary_prev]->coeff(it->first,it->second));
////		}
////		for(it_pair it=list_y_1.begin();it!=list_y_1.end();it++){
////			printf("%f \n",LogM[m_binary_prev]->coeff(it->first,it->second-1));
////			printf("%f \n",LogX[m_binary_prev]->coeff(it->first,it->second-1));
////			printf("%f \n",LogY[m_binary_prev]->coeff(it->first,it->second-1));
////			printf("%f \n",LogM[m_binary_prev]->coeff(it->first,it->second));
////			printf("%f \n",LogX[m_binary_prev]->coeff(it->first,it->second));
////			printf("%f \n",LogY[m_binary_prev]->coeff(it->first,it->second));
////		}
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//
//
//
//	}
//
//
//
//
//
//	//-----------------------------------------------------------
////	std::cout<<"max_lk_level: "<<level_max_lk<<"\n";
//	//-----------------------------------------------------------
//
//
//
//
//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	double max_lk=-INFINITY;
////	int level;
////	std::vector< std::pair<int,int> > list_tr_1;
////	for(int m=d-1;m>=std::max(h,w);m--){
////		if(TR[m]->coeff(h-1,w-1)>0){
////			list_tr_1.push_back(std::pair<int,int>(m,TR[m]->coeff(h-1,w-1)));
////			if( (LogM[m]->coeff(h-1,w-1)<0.0) & (LogM[m]->coeff(h-1,w-1)>max_lk) ){
////				max_lk=LogM[m]->coeff(h-1,w-1);
////				level=m;
////			}
////			if( (LogX[m]->coeff(h-1,w-1)<0.0) & (LogX[m]->coeff(h-1,w-1)>max_lk) ){
////				max_lk=LogX[m]->coeff(h-1,w-1);
////				level=m;
////			}
////			if( (LogY[m]->coeff(h-1,w-1)<0.0) & (LogY[m]->coeff(h-1,w-1)>max_lk) ){
////				max_lk=LogY[m]->coeff(h-1,w-1);
////				level=m;
////			}
////		}
////	}
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//
//
//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	for(int i=0;i<d;i++){
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
////				std::cout<<TR[i]->coeff(j,k)<<"  ";
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";
////	}
////	std::cout<<"\n";
////	std::cout<<"\n";
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//
//
//
//
//
//	//-----------------------------------------------------------
////	std::cout<<"\n";
////	std::cout<<level_max_lk<<":"<<max_lk<<":"<<"\n";
//	//-----------------------------------------------------------
//
//
//
//	result.score=max_lk;
//
//	//-----------------------------------------------------------
////	PrintVector(result_L.MSA);
////	PrintVector(result_R.MSA);
////	printf("max_lk: %20.18f\n",max_lk);
////	if(flag_MSA_che_cerco){
////		printf("ECCOLA QUI\n\n");
////	}
//	//-----------------------------------------------------------
//
//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	sequence_t<ALPHABET> traceback_path(level_max_lk,ALPHABET::unknow);
//
//	int id1=h-1;
//	int id2=w-1;
//
//	for(int i=level_max_lk;i>0;i--){
//		switch(TR[i]->coeff(id1,id2)){
//	        case MATCH_STATE:
//	            id1=id1-1;
//	            id2=id2-1;
//	            traceback_path[i-1]=ALPHABET::match;
//	            break;
//	        case GAP_X_STATE:
//	            id1=id1-1;
//	            traceback_path[i-1]=ALPHABET::gapX;
//	            break;
//	        case GAP_Y_STATE:
//	            id2=id2-1;
//	            traceback_path[i-1]=ALPHABET::gapY;
//	            break;
//	        default:
//	        	error("ERROR in alignment_reconstruction !!!");
//	            exit(EXIT_FAILURE);
//	    }
//	}
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	result.traceback_path=traceback_path;
//
//	fill_Pc_new3(result,traceback_path,PM,PX,PY);
//
//	result.MSA=build_MSA_PIP<ALPHABET>(traceback_path,result_L.MSA,result_R.MSA,fileTr);
//
//	update_fv_map(result,temp_fv_map,result.MSA);
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	delete_MatrixSparse3D(LogM,d_binary);
//	delete_MatrixSparse3D(LogX,d_binary);
//	delete_MatrixSparse3D(LogY,d_binary);
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	return result;
//}
//=======================================================================================================
////DP-PIP
//template <class ALPHABET>
//static ProgressivePIPResult<ALPHABET> compute_DP_PIP_fast(ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,Eigen::MatrixXd &matFv,std::ostream& fileTr){
//
//	//*************************************************************************************
//	//*************************************************************************************
////	std::cout<<tree.getName()<<" : "<<tree[0].getName()<<" ; "<<tree[1].getName()<<"\n";
////
////	Eigen::VectorXd fv_tmp;
////	int idx=0;
////	std::string ss;
////	if(tree.getName()=="V3"){
////		ss="AC";
////	}else if(tree.getName()=="V2"){
////		ss="ACG";
////	}else if(tree.getName()=="V1"){
////		ss="ACGT";
////	}else if(tree.getName()=="V5"){
////		ss="TA";
////	}else if(tree.getName()=="V4"){
////		ss="CTA";
////	}else if(tree.getName()=="V0"){
////		ss="ACGTCTA";
////	}
////
////	sequence_t<ALPHABET> colMSA=sequenceFromString<ALPHABET>(ss);
////
////	fv_tmp=recursive_fv(tree,matFv,colMSA,idx);
////	std::cout<<"fv_tmp\n";
////	for(int k=0;k<5;k++){
////		std::cout<<fv_tmp(k)<<"\n";
////	}
////	std::cout<<"\n";
//	//*************************************************************************************
//	//*************************************************************************************
//
//	ProgressivePIPResult<ALPHABET> result;
//
//	int h=get_length_seq(result_L.MSA)+1;
//	int w=get_length_seq(result_R.MSA)+1;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	int d_binary=2; //
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogM = initialize_MatrixSparse3D(h,w,d_binary);
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogX = initialize_MatrixSparse3D(h,w,d_binary);
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogY = initialize_MatrixSparse3D(h,w,d_binary);
//
//	int d=(h-1)+(w-1)+1;
//	Eigen::SparseMatrix<int,Eigen::RowMajor>** TR = initialize_MatrixSparse3D_int(h,w,d);
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	Eigen::MatrixXd PX(h,w);
//	Eigen::MatrixXd PY(h,w);
//	Eigen::MatrixXd PM(h,w);
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();
//
//	double pc0;
//	double fv0;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	sequence_t<ALPHABET> sL;
//	sequence_t<ALPHABET> sR;
//	sequence_t<ALPHABET> col_gap_L;
//	sequence_t<ALPHABET> col_gap_R;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	col_gap_L=create_col_MSA_gap(result_L.MSA);
//	col_gap_R=create_col_MSA_gap(result_R.MSA);
//
//	std::map<std::string,Eigen::VectorXd> temp_fv_map;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	double lk_gap;
//	double pc0_subtree;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//std::cout<<"random generator ON\n";
//	unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
//	std::default_random_engine generator(seed);
////	std::default_random_engine generator(1);
//	std::uniform_real_distribution<double> distribution(0.0,1.0);
//	//.-----.------.------.//
////	std::cout<<"random generator OFF\n";
////	unsigned seed = 0;
////	std::default_random_engine generator(seed);
////	std::uniform_real_distribution<double> distribution(0.0,1.0);
////	double random_number;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	double epsilon=DBL_EPSILON;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	if(!tree[0].isLeaf()){
//		if(result_L.Pc.size()!=(h-1)){
//			error("DIMENSION wrong\n");
//		}
//	}
//	if(!tree[1].isLeaf()){
//		if(result_R.Pc.size()!=(w-1)){
//			error("DIMENSION wrong\n");
//		}
//	}
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	std::set< std::pair<int,int> > list_m_1;
//	std::set< std::pair<int,int> > list_x_1;
//	std::set< std::pair<int,int> > list_y_1;
//	std::set< std::pair<int,int> > list_m_2;
//	std::set< std::pair<int,int> > list_x_2;
//	std::set< std::pair<int,int> > list_y_2;
//	std::set< std::pair<int,int> > list_tr;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,col_gap_L,col_gap_R,pi);
//	fv0=compute_fv_new_fast(tree,col_gap_L,col_gap_R,matFv,pi);
//
//	lk_gap=result_L.lk_gap+result_R.lk_gap;
//	pc0_subtree=result_L.pc0+result_R.pc0;
//
//	result.lk_gap=0.0;//lk_gap+tree.get_iota()*tree.get_beta()*fv0;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	pc0=compute_Pe_new(tree,fv0,pc0_subtree);
//	pc0=compute_pr_gap(tree,result_L,result_R,result,col_gap_L,col_gap_R,pi,pc0_subtree,lk_gap);
////	result.pc0=pc0;
//	result.pc0=pc0_subtree;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//
//
//	(*LogM[0]).coeffRef(0,0)=nu*(pc0-1.0);
//	(*LogX[0]).coeffRef(0,0)=nu*(pc0-1.0);
//	(*LogY[0]).coeffRef(0,0)=nu*(pc0-1.0);
//
//
//	(*TR[0]).coeffRef(0,0)=STOP_STATE;
//
//	list_m_1.insert(std::pair<int,int>(0,0));
//	list_x_1.insert(std::pair<int,int>(0,0));
//	list_y_1.insert(std::pair<int,int>(0,0));
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	typedef typename std::set< std::pair<int,int> > ::const_iterator it_pair;
//
//	double max_of_3;
//	double max_lk=-INFINITY;
//	int level_max_lk;
//	double val;
//	int m_binary_this;
//	int m_binary_prev;
//
//	for(int m=1;m<d;m++){
//
//		m_binary_this=m%2;
//		m_binary_prev=(m+1)%2;
//
//		next_nonzero_elements_set(list_m_1,list_x_1,list_y_1,list_m_2,list_x_2,list_y_2,h,w);
//
//		list_tr.clear();
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_m_1.begin();it!=list_m_1.end();it++){
//			sL=create_col_MSA(result_L.MSA,it->first-1);
//			sR=create_col_MSA(result_R.MSA,it->second-1);
//
//			val=computeLK_M_fast(LogM[m_binary_prev],
//							LogX[m_binary_prev],
//							LogY[m_binary_prev],
//							it->first,it->second,
//							nu,
//							tree,
//							sL,sR,
//							pi,
//							lk_gap,
//							PM,
//							m,
//							matFv);
//
//			(*LogM[m_binary_this]).coeffRef(it->first,it->second)=val;
//
//			list_tr.insert(std::pair<int,int>(it->first,it->second));
//		}
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_x_1.begin();it!=list_x_1.end();it++){
//			sL=create_col_MSA(result_L.MSA,it->first-1);
//
//			val=computeLK_X_fast(LogM[m_binary_prev],
//							LogX[m_binary_prev],
//							LogY[m_binary_prev],
//							it->first,it->second,
//							nu,
//							result_L,tree,
//							sL,col_gap_R,
//							pi,
//							lk_gap,
//							PX,
//							m,
//							matFv);
//
//			(*LogX[m_binary_this]).coeffRef(it->first,it->second)=val;
//
//			list_tr.insert(std::pair<int,int>(it->first,it->second));
//		}
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_y_1.begin();it!=list_y_1.end();it++){
//			sR=create_col_MSA(result_R.MSA,it->second-1);
//
//			val=computeLK_Y_fast(LogM[m_binary_prev],
//							LogX[m_binary_prev],
//							LogY[m_binary_prev],
//							it->first,it->second,
//							nu,
//							result_R,tree,
//							col_gap_L,sR,
//							pi,
//							lk_gap,
//							PY,
//							m,
//							matFv);
//
//			(*LogY[m_binary_this]).coeffRef(it->first,it->second)=val;
//
//			list_tr.insert(std::pair<int,int>(it->first,it->second));
//		}
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_tr.begin();it!=list_tr.end();it++){
//
//			if(TR[m]->coeff(it->first,it->second)!=0){
//				std::cout<<"already assigned!!!\n";
//				exit(EXIT_FAILURE);
//			}
//
//			double mval=fabs((double)LogM[m_binary_this]->coeff(it->first,it->second))<epsilon?-INFINITY:(double)LogM[m_binary_this]->coeff(it->first,it->second);
//			double xval=fabs((double)LogX[m_binary_this]->coeff(it->first,it->second))<epsilon?-INFINITY:(double)LogX[m_binary_this]->coeff(it->first,it->second);
//			double yval=fabs((double)LogY[m_binary_this]->coeff(it->first,it->second))<epsilon?-INFINITY:(double)LogY[m_binary_this]->coeff(it->first,it->second);
//
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////			random_number = distribution(generator);
//			(*TR[m]).coeffRef(it->first,it->second)=index_of_max_3(mval,xval,yval,epsilon,generator,distribution);
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//			if( (it->first==(h-1)) & (it->second==(w-1)) ){
//
//				max_of_3=max_of_three_2(mval,xval,yval,epsilon);
//
//				if(max_of_3>max_lk){
//					max_lk=max_of_3;
//					level_max_lk=m;
//				}
//
//			}
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//		}
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_m_1.begin();it!=list_m_1.end();it++){
//			(*LogM[m_binary_prev]).coeffRef(it->first-1,it->second-1)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first-1,it->second-1)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first-1,it->second-1)=0.0;
//			(*LogM[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//		}
//		for(it_pair it=list_x_1.begin();it!=list_x_1.end();it++){
//			(*LogM[m_binary_prev]).coeffRef(it->first-1,it->second)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first-1,it->second)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first-1,it->second)=0.0;
//			(*LogM[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//		}
//		for(it_pair it=list_y_1.begin();it!=list_y_1.end();it++){
//			(*LogM[m_binary_prev]).coeffRef(it->first,it->second-1)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first,it->second-1)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first,it->second-1)=0.0;
//			(*LogM[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogX[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//			(*LogY[m_binary_prev]).coeffRef(it->first,it->second)=0.0;
//		}
//
//	}
//
//	result.score=max_lk;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	sequence_t<ALPHABET> traceback_path(level_max_lk,ALPHABET::unknow);
//
//	int id1=h-1;
//	int id2=w-1;
//
//	for(int i=level_max_lk;i>0;i--){
//		switch(TR[i]->coeff(id1,id2)){
//	        case MATCH_STATE:
//	            id1=id1-1;
//	            id2=id2-1;
//	            traceback_path[i-1]=ALPHABET::match;
//	            break;
//	        case GAP_X_STATE:
//	            id1=id1-1;
//	            traceback_path[i-1]=ALPHABET::gapX;
//	            break;
//	        case GAP_Y_STATE:
//	            id2=id2-1;
//	            traceback_path[i-1]=ALPHABET::gapY;
//	            break;
//	        default:
//	        	error("ERROR in alignment_reconstruction !!!");
//	            exit(EXIT_FAILURE);
//	    }
//	}
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	result.traceback_path=traceback_path;
//
//	fill_Pc_new3(result,traceback_path,PM,PX,PY);
//
//	result.MSA=build_MSA_PIP<ALPHABET>(traceback_path,result_L.MSA,result_R.MSA,fileTr);
//
//	//update_fv_map(result,temp_fv_map,result.MSA);
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	delete_MatrixSparse3D(LogM,d_binary);
//	delete_MatrixSparse3D(LogX,d_binary);
//	delete_MatrixSparse3D(LogY,d_binary);
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	return result;
//}
//=======================================================================================================
//DP-PIP
bool checkboundary(int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int h,int w){

	if( (up_corner_i  >=0) & (up_corner_i  <h) &\
	   (up_corner_j  >=0) & (up_corner_j  <w) &\
	   (bot_corner_i >=0) & (bot_corner_i <h) &\
	   (bot_corner_j >=0) & (bot_corner_j <w)){
		return true;
	}

	return false;
}
//=======================================================================================================
//DP-PIP
void set_indexes_match(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int level,int h,int w){

	if(level==0){
		up_corner_i=0;
		up_corner_j=0;
		bot_corner_i=0;
		bot_corner_j=0;
	}else{
		up_corner_i=1;
		up_corner_j=level;
		bot_corner_i=level;
		bot_corner_j=1;
	}

}
//=======================================================================================================
//DP-PIP
void set_indexes_match_new(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int level,int h,int w){

	if(level==0){
		up_corner_i=0;
		up_corner_j=0;
		bot_corner_i=0;
		bot_corner_j=0;
	}else{
		up_corner_i=1+level-std::min(w-1,level);
		up_corner_j=std::min(w-1,level);
		bot_corner_i=std::min(h-1,level);
		bot_corner_j=1+level-std::min(h-1,level);
	}

}
//=======================================================================================================
//DP-PIP
void set_indexes_gapx(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int level,int h,int w){

	if(level==0){
		up_corner_i=0;
		up_corner_j=0;
		bot_corner_i=0;
		bot_corner_j=0;
	}else{
		up_corner_i=1;
		up_corner_j=level-1;
		bot_corner_i=level;
		bot_corner_j=0;
	}

//	up_corner_i=1;
//	up_corner_j=std::min(level,h-1)-1;
//	bot_corner_i=std::min(level,w-1);
//	bot_corner_j=0;

}
//=======================================================================================================
//DP-PIP
void set_indexes_gapx_new(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int level,int h,int w){

	if(level==0){
		up_corner_i=0;
		up_corner_j=0;
		bot_corner_i=0;
		bot_corner_j=0;
	}else{
		up_corner_i=1+level-1-std::min(w-1,level-1);
		up_corner_j=std::min(w-1,level-1);
		bot_corner_i=std::min(h-1,level);
		bot_corner_j=level-std::min(h-1,level);
	}

}
//=======================================================================================================
//DP-PIP
void set_indexes_gapy(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int level,int h,int w){

	if(level==0){
		up_corner_i=0;
		up_corner_j=0;
		bot_corner_i=0;
		bot_corner_j=0;
	}else{
		up_corner_i=0;
		up_corner_j=level;
		bot_corner_i=level-1;
		bot_corner_j=1;
	}

//	up_corner_i=0;
//	up_corner_j=std::min(level,h-1);
//	bot_corner_i=std::min(level,w-1)-1;
//	bot_corner_j=1;

}
//=======================================================================================================
//DP-PIP
void set_indexes_gapy_new(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int level,int h,int w){

	if(level==0){
		up_corner_i=0;
		up_corner_j=0;
		bot_corner_i=0;
		bot_corner_j=0;
	}else{
		up_corner_i=level-std::min(w-1,level);
		up_corner_j=std::min(w-1,level);
		bot_corner_i=std::min(h-1,level-1);
		bot_corner_j=1+level-1-std::min(h-1,level-1);
	}

}
//=======================================================================================================
//DP-PIP
void reset_corner(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int h,int w){
	int delta;

	if(up_corner_j>=w){
		delta=up_corner_j-w+1;
		up_corner_j-=delta;
		up_corner_i+=delta;
	}
	if(bot_corner_i>=h){
		delta=bot_corner_i-h+1;
		bot_corner_i-=delta;
		bot_corner_j+=delta;
	}

}
//=======================================================================================================
//DP-PIP
void set_indexes_tr(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int level,int h,int w){

//	int up_corner_i_m;
	int up_corner_i_x;
	int up_corner_i_y;

//	int up_corner_j_m;
	int up_corner_j_x;
	int up_corner_j_y;

//	int bot_corner_i_m;
	int bot_corner_i_x;
	int bot_corner_i_y;

//	int bot_corner_j_m;
	int bot_corner_j_x;
	int bot_corner_j_y;


//	set_indexes_match(up_corner_i_m,up_corner_j_m,bot_corner_i_m,bot_corner_j_m,level);
//	reset_corner(up_corner_i_m,up_corner_j_m,bot_corner_i_m,bot_corner_j_m,h,w);

	set_indexes_gapx(up_corner_i_x,up_corner_j_x,bot_corner_i_x,bot_corner_j_x,level,h,w);
	reset_corner(up_corner_i_x,up_corner_j_x,bot_corner_i_x,bot_corner_j_x,h,w);

	set_indexes_gapy(up_corner_i_y,up_corner_j_y,bot_corner_i_y,bot_corner_j_y,level,h,w);
	reset_corner(up_corner_i_y,up_corner_j_y,bot_corner_i_y,bot_corner_j_y,h,w);


	int delta_i,delta_j;

	delta_i=bot_corner_i_x-up_corner_i_y;
	delta_j=up_corner_j_y-bot_corner_j_x;

	if(delta_i>delta_j){
		up_corner_i=up_corner_i_y;
		up_corner_j=up_corner_j_y;
		bot_corner_i=up_corner_i_y+delta_i;
		bot_corner_j=up_corner_j_y-delta_i;
	}else{
		up_corner_i=bot_corner_i_x-delta_j;
		up_corner_j=bot_corner_j_x+delta_j;
		bot_corner_i=bot_corner_i_x;
		bot_corner_j=bot_corner_j_x;
	}


}
//=======================================================================================================
//DP-PIP
void set_indexes_tr_new(int &up_corner_i,int &up_corner_j,int &bot_corner_i, int &bot_corner_j,int level,int h,int w){

	int up_corner_i_x;
	int up_corner_i_y;

	int up_corner_j_x;
	int up_corner_j_y;

	int bot_corner_i_x;
	int bot_corner_i_y;

	int bot_corner_j_x;
	int bot_corner_j_y;

	set_indexes_gapx_new(up_corner_i_x,up_corner_j_x,bot_corner_i_x,bot_corner_j_x,level,h,w);

	set_indexes_gapy_new(up_corner_i_y,up_corner_j_y,bot_corner_i_y,bot_corner_j_y,level,h,w);

	int delta_i,delta_j;

	delta_i=bot_corner_i_x-up_corner_i_y;
	delta_j=up_corner_j_y-bot_corner_j_x;

	if(delta_i>delta_j){
		up_corner_i=up_corner_i_y;
		up_corner_j=up_corner_j_y;
		bot_corner_i=up_corner_i_y+delta_i;
		bot_corner_j=up_corner_j_y-delta_i;
	}else{
		up_corner_i=bot_corner_i_x-delta_j;
		up_corner_j=bot_corner_j_x+delta_j;
		bot_corner_i=bot_corner_i_x;
		bot_corner_j=bot_corner_j_x;
	}

}
//=======================================================================================================
//DP-PIP
void indexes(int level,int h,int w){

	int up_corner_i;
	int up_corner_j;
	int bot_corner_i;
	int bot_corner_j;

	int lw,lh;
//	int delta;

	//match
//	up_corner_i=1;
//	up_corner_j=(level-1)+1;
//	bot_corner_i=(level-1)+1;
//	bot_corner_j=1;

	set_indexes_match(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,level,h,w);

//	printf("match(prima) : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

//	if(up_corner_j>=w){
//		delta=up_corner_j-w+1;
//		up_corner_j-=delta;
//		up_corner_i+=delta;
//	}
//	if(bot_corner_i>=h){
//		delta=bot_corner_i-h+1;
//		bot_corner_i-=delta;
//		bot_corner_j+=delta;
//	}

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

//	printf("match(dopo) : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

	if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

		printf("match : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

		lh=bot_corner_i-up_corner_i+1;
		lw=1;
		for(int i=0;i<lh;i++){
			for(int j=0;j<lw;j++){
				printf("(%d %d) ",up_corner_i+i,up_corner_j-j);
			}
			lw++;
			printf("\n");
		}

	}

	//gapx
//	up_corner_i=1;
//	up_corner_j=(level-1);
//	bot_corner_i=(level-1)+1;
//	bot_corner_j=0;

	set_indexes_gapx(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,level,h,w);

//	printf("gapx(prima) : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

//	if(up_corner_j>=w){
//		delta=up_corner_j-w+1;
//		up_corner_j-=delta;
//		up_corner_i+=delta;
//	}
//	if(bot_corner_i>=h){
//		delta=bot_corner_i-h+1;
//		bot_corner_i-=delta;
//		bot_corner_j+=delta;
//	}

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

//	printf("gapx(dopo) : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

	if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

		printf("gapx : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

		lh=bot_corner_i-up_corner_i+1;
		lw=1;
		for(int i=0;i<lh;i++){
			for(int j=0;j<lw;j++){
				printf("(%d %d) ",up_corner_i+i,up_corner_j-j);
			}
			lw++;
			printf("\n");
		}

	}

	//gapy
//	up_corner_i=0;
//	up_corner_j=(level-1)+1;
//	bot_corner_i=(level-1);
//	bot_corner_j=1;

	set_indexes_gapy(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,level,h,w);

//	printf("gapy(prima) : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

//	if(up_corner_j>=w){
//		delta=up_corner_j-w+1;
//		up_corner_j-=delta;
//		up_corner_i+=delta;
//	}
//	if(bot_corner_i>=h){
//		delta=bot_corner_i-h+1;
//		bot_corner_i-=delta;
//		bot_corner_j+=delta;
//	}

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

//	printf("gapy(dopo) : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

	if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

		printf("gapy : (%d %d)->(%d %d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);

		lh=bot_corner_i-up_corner_i+1;
		lw=1;
		for(int i=0;i<lh;i++){
			for(int j=0;j<lw;j++){
				printf("(%d %d) ",up_corner_i+i,up_corner_j-j);
			}
			lw++;
			printf("\n");
		}

	}

}
//=======================================================================================================
//DP-PIP
void ind2sub(int &i,int &j,int s,int h,int w){

	j=s%w;
	i=(s-j)/w;

}
//=======================================================================================================
//DP-PIP
void sub2ind(int i,int j,int &s,int h,int w){

	s=i*w+j;

}
//=======================================================================================================
//DP-PIP
bool is_inside(int x0,int y0,int xf,int yf,int xt,int yt){

	if((xt<x0) || (yt>y0) || (xt>xf) || (yt<yf)){

		return false;
	}

	if( (y0-yt)>(xt-x0) ){
		return false;
	}

	return true;
}
//=======================================================================================================
//DP-PIP
int get_prev_linear_indices_M(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){

	int idx;

	set_indexes_match(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

//		std::cout<<"up_corner_i: "<<up_corner_i<<"\n";
//		std::cout<<"up_corner_j: "<<up_corner_j<<"\n";
//		std::cout<<"bot_corner_i: "<<bot_corner_i<<"\n";
//		std::cout<<"bot_corner_j: "<<bot_corner_j<<"\n";


		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);
	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int get_linear_indices_M_new(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){

	int idx;

	set_indexes_match_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);
	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int get_prev_linear_indices_X(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){

	int idx;

	set_indexes_gapx(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

//		std::cout<<"up_corner_i: "<<up_corner_i<<"\n";
//		std::cout<<"up_corner_j: "<<up_corner_j<<"\n";
//		std::cout<<"bot_corner_i: "<<bot_corner_i<<"\n";
//		std::cout<<"bot_corner_j: "<<bot_corner_j<<"\n";


		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);
	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int get_linear_indices_X_new(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){

	int idx;

	set_indexes_gapx_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);
	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int get_prev_linear_indices_Y(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){

	int idx;

	set_indexes_gapy(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

//		std::cout<<"up_corner_i: "<<up_corner_i<<"\n";
//		std::cout<<"up_corner_j: "<<up_corner_j<<"\n";
//		std::cout<<"bot_corner_i: "<<bot_corner_i<<"\n";
//		std::cout<<"bot_corner_j: "<<bot_corner_j<<"\n";


		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);
	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int get_linear_indices_Y_new(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){

	int idx;

	set_indexes_gapy_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);
	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int get_this_linear_indices_M(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){
	int idx;

	set_indexes_match(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

//		std::cout<<"MATCH indices\n";
//		std::cout<<"up_corner_i: "<<up_corner_i<<"\n";
//		std::cout<<"up_corner_j: "<<up_corner_j<<"\n";
//		std::cout<<"bot_corner_i: "<<bot_corner_i<<"\n";
//		std::cout<<"bot_corner_j: "<<bot_corner_j<<"\n\n";

		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);

	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int get_this_linear_indices_X(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){
	int idx;

	set_indexes_gapx(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

//		std::cout<<"GAPX indices\n";
//		std::cout<<"up_corner_i: "<<up_corner_i<<"\n";
//		std::cout<<"up_corner_j: "<<up_corner_j<<"\n";
//		std::cout<<"bot_corner_i: "<<bot_corner_i<<"\n";
//		std::cout<<"bot_corner_j: "<<bot_corner_j<<"\n\n";

		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);

	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int get_this_linear_indices_Y(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){
	int idx;

	set_indexes_gapy(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

	if(is_inside(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,nx,ny)){

//		std::cout<<"GAPY indices\n";
//		std::cout<<"up_corner_i: "<<up_corner_i<<"\n";
//		std::cout<<"up_corner_j: "<<up_corner_j<<"\n";
//		std::cout<<"bot_corner_i: "<<bot_corner_i<<"\n";
//		std::cout<<"bot_corner_j: "<<bot_corner_j<<"\n\n";

		int dx,sx;

		dx=nx-up_corner_i+1;

		sx=((dx+1)*dx/2)-1;

		idx=sx+(ny-up_corner_j);

	}else{
		idx=-999;
	}

	return idx;

}
//=======================================================================================================
//DP-PIP
int linear_indices_TR(int nx,int ny,int up_corner_i,int up_corner_j,int bot_corner_i,int bot_corner_j,int m,int h,int w){

	set_indexes_tr(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

	reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);


//	std::cout<<"TR indices\n";
//	std::cout<<"up_corner_i: "<<up_corner_i<<"\n";
//	std::cout<<"up_corner_j: "<<up_corner_j<<"\n";
//	std::cout<<"bot_corner_i: "<<bot_corner_i<<"\n";
//	std::cout<<"bot_corner_j: "<<bot_corner_j<<"\n";
//	std::cout<<"\n";

	int idx;
	int dx,sx;

	dx=nx-up_corner_i+1;

	sx=((dx+1)*dx/2)-1;

	idx=sx+(ny-up_corner_j);


	return idx;

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Mopt_all_edges_Pc(std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						int i,int j,
						PhyTree &tree,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						int m){

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
	double fv0;
	Eigen::VectorXd fv;

	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(sR));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		MapIterator itL=fv_L.find(stringFromSequence<ALPHABET>(sL));
		if(itL == fv_L.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sL);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvL=itL->second;

		MapIterator itR=fv_R.find(stringFromSequence<ALPHABET>(sR));
		if(itR == fv_R.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sR);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvR=itR->second;

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}else{
		fv=it->second;
	}


	fv0=fv.dot(pi);

	fv_0[s]=fv;

	double pr;

	pr=tree.get_iota()*tree.get_beta()*fv0;


	double p0=pr;

	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		pr+=(p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);

		p_tree=p_tree->getParent();
	}

	return p0;

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Xopt_all_edges_Pc(std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						int i,
						ProgressivePIPResult<ALPHABET> &result_L,
						PhyTree &tree,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &col_gap_R,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						int m){

//	double val;

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
	double fv0;
	Eigen::VectorXd fv;

	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(col_gap_R));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		MapIterator itL=fv_L.find(stringFromSequence<ALPHABET>(sL));
		if(itL == fv_L.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sL);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvL=itL->second;

		MapIterator itR=fv_R.find(stringFromSequence<ALPHABET>(col_gap_R));
		if(itR == fv_R.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(col_gap_R);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvR=itR->second;

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}else{
		fv=it->second;
	}


	fv0=fv.dot(pi);

	fv_0[s]=fv;

	double pC;

	pC=getPc(result_L,i);

	double pr;
	double pL;
	double p0;
	double pR;

//	if(!tree[1].isLeaf()){
//		pR=lk_gap;
//	}else{
//		pR=0.0;
//	}

	pR=0.0;

	if(tree[0].isLeaf()){

		double freq;
		if(sL.length()!=1){
			error("ERROR in compute_Pa");
			exit(EXIT_FAILURE);
		}

		freq=pi(sL[0].value());

		pL=freq*tree[0].get_iota() * tree[0].get_beta();
	}else{
		pL=0.0;
	}


	p0=tree.get_iota()*tree.get_beta()*fv0;
	pr=p0 + pL + pC +pR;

	return pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double computeLK_Yopt_all_edges_Pc(std::map<std::string,Eigen::VectorXd> &fv_L,
						std::map<std::string,Eigen::VectorXd> &fv_R,
						std::map<std::string,Eigen::VectorXd> &fv_0,
						int j,
						ProgressivePIPResult<ALPHABET> &result_R,
						PhyTree &tree,
						sequence_t<ALPHABET> &col_gap_L,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
						int m){

//	double val;

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
	double fv0;
	Eigen::VectorXd fv;

	s.append(stringFromSequence(col_gap_L));
	s.append(stringFromSequence(sR));

	MapIterator it=fv_0.find(s);
	if(it == fv_0.end()){

		MapIterator itL=fv_L.find(stringFromSequence<ALPHABET>(col_gap_L));
		if(itL == fv_L.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(col_gap_L);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvL=itL->second;

		MapIterator itR=fv_R.find(stringFromSequence<ALPHABET>(sR));
		if(itR == fv_R.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sR);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvR=itR->second;

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}else{
		fv=it->second;
	}


	fv0=fv.dot(pi);

	fv_0[s]=fv;

	double pC;

	pC=getPc(result_R,j);

	double pr;
	double pL;
	double p0;
	double pR;

//	if(!tree[0].isLeaf()){
//		pL=lk_gap;
//	}else{
//		pL=0.0;
//	}

	pL=0.0;

	if(tree[1].isLeaf()){

		double freq;
		if(sR.length()!=1){
			error("ERROR in compute_Pa");
			exit(EXIT_FAILURE);
		}

		freq=pi(sR[0].value());

		pR=freq*tree[1].get_iota() * tree[1].get_beta();
	}else{
		pR=0.0;
	}


	p0=tree.get_iota()*tree.get_beta()*fv0;

	pr=p0 + pL + pC +pR;

	return pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void fill_Pc_new5(	ProgressivePIPResult<ALPHABET> &result_L,
							ProgressivePIPResult<ALPHABET> &result_R,
							ProgressivePIPResult<ALPHABET> &result,
							Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,
							PhyTree &tree,
							sequence_t<ALPHABET>tracepath,
							int h,int w){

	int len=tracepath.length();
	result.Pc.setZero(len);

//	Eigen::VectorXd Pc=Eigen::VectorXd::Zero(len);

	double pc;

	sequence_t<ALPHABET> sL;
	sequence_t<ALPHABET> sR;
	sequence_t<ALPHABET> col_gap_L;
	sequence_t<ALPHABET> col_gap_R;

	col_gap_L=create_col_MSA_gap(result_L.MSA);
	col_gap_R=create_col_MSA_gap(result_R.MSA);

	int coordSeq_1=0;
	int coordSeq_2=0;
	int m=1;
	for(int i=0;i<len;i++){
		if(tracepath[i]==ALPHABET::match){

			sL=create_col_MSA(result_L.MSA,coordSeq_1);
			sR=create_col_MSA(result_R.MSA,coordSeq_2);

			pc=computeLK_Mopt_all_edges_Pc(result_L.fv_map,
								result_R.fv_map,
								result.fv_map,
								coordSeq_1,coordSeq_2,
								tree,
								sL,sR,
								pi,
								m);



//			std::cout<<"pc: "<<pc<<"("<<coordSeq_1<<","<<coordSeq_2<<")\n";



			coordSeq_1++;
			coordSeq_2++;

		}else if(tracepath[i]==ALPHABET::gapX){

			sL=create_col_MSA(result_L.MSA,coordSeq_1);

			pc=computeLK_Xopt_all_edges_Pc(result_L.fv_map,
								result_R.fv_map,
								result.fv_map,
								coordSeq_1,
								result_L,tree,
								sL,col_gap_R,
								pi,
								m);

			coordSeq_1++;

		}else if(tracepath[i]==ALPHABET::gapY){

			sR=create_col_MSA(result_R.MSA,coordSeq_2);

			pc=computeLK_Yopt_all_edges_Pc(result_L.fv_map,
								result_R.fv_map,
								result.fv_map,
								coordSeq_2,
								result_R,tree,
								col_gap_L,sR,
								pi,
								m);

			coordSeq_2++;

		}else{
			error("ERROR in fill_Pc_new5");
			exit(EXIT_FAILURE);
		}

		result.Pc[i]=pc;
//		Pc[i]=pc;
		m++;

//		std::cout<<"diff: "<<Pc[i]-result.Pc[i]<<"\n";

	}


}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static void fill_Pc_new4(ProgressivePIPResult<ALPHABET> &result,sequence_t<ALPHABET>tracepath,double **PM,double **PX,double **PY,int h,int w,int m){

	int idx;
	int up_corner_i_m,up_corner_j_m,bot_corner_i_m,bot_corner_j_m;
	int up_corner_i_x,up_corner_j_x,bot_corner_i_x,bot_corner_j_x;
	int up_corner_i_y,up_corner_j_y,bot_corner_i_y,bot_corner_j_y;

	int len=tracepath.length();

//	int id1=PM.rows()-1;
//	int id2=PM.cols()-1;
	int id1=h-1;
	int id2=w-1;

	result.Pc.setZero(len);

	int depth=m;

	for(int i=len-1;i>=0;i--){

		set_indexes_match_new(up_corner_i_m,up_corner_j_m,bot_corner_i_m,bot_corner_j_m,depth,h,w);
		set_indexes_gapx_new(up_corner_i_x,up_corner_j_x,bot_corner_i_x,bot_corner_j_x,depth,h,w);
		set_indexes_gapy_new(up_corner_i_y,up_corner_j_y,bot_corner_i_y,bot_corner_j_y,depth,h,w);

		if(tracepath[i]==ALPHABET::match){
			idx=get_linear_indices_M_new(id1,id2,up_corner_i_m,up_corner_j_m,bot_corner_i_m,bot_corner_j_m,depth,h,w);
			result.Pc[i]=(double)PM[depth][idx];
//			result.Pc[i]=(double)PM(id1,id2);


//			std::cout<<"**M** m: "<<depth<<" i: "<<id1<<" j: "<<id2<<" idx: "<<idx<<" lk: ";
//			printf("%18.16f\n",(double)PM[depth][idx]);

			id1=id1-1;
			id2=id2-1;
		}else if(tracepath[i]==ALPHABET::gapX){
			idx=get_linear_indices_X_new(id1,id2,up_corner_i_x,up_corner_j_x,bot_corner_i_x,bot_corner_j_x,depth,h,w);
			result.Pc[i]=(double)PX[depth][idx];
//			result.Pc[i]=(double)PX(id1,id2);


//			std::cout<<"(upi: "<<up_corner_i_x<<"; upj: "<<up_corner_j_x<<";boi: "<<bot_corner_i_x<<";boj: "<<bot_corner_j_x<<";m: "<<depth<<";h: "<<h<<";w: "<<w<<")\n";
//			std::cout<<"**X** m: "<<depth<<" i: "<<id1<<" j: "<<id2<<" idx: "<<idx<<" lk: ";
//			printf("%18.16f\n",(double)PX[depth][idx]);

			id1=id1-1;
		}else if(tracepath[i]==ALPHABET::gapY){
			idx=get_linear_indices_Y_new(id1,id2,up_corner_i_y,up_corner_j_y,bot_corner_i_y,bot_corner_j_y,depth,h,w);
			result.Pc[i]=(double)PY[depth][idx];
//			result.Pc[i]=(double)PY(id1,id2);


//			std::cout<<"(upi: "<<up_corner_i_y<<"; upj: "<<up_corner_j_y<<";boi: "<<bot_corner_i_y<<";boj: "<<bot_corner_j_y<<";m: "<<depth<<";h: "<<h<<";w: "<<w<<")\n";
//			std::cout<<"**Y** m: "<<depth<<" i: "<<id1<<" j: "<<id2<<" idx: "<<idx<<" lk: ";
//			printf("%18.16f\n",(double)PY[depth][idx]);



			id2=id2-1;
		}else{
			error("ERROR in fill_Pc_new4");
			exit(EXIT_FAILURE);
		}
		depth--;
	}

}
//=======================================================================================================
//DP-PIP
double **calloc2Ddouble(int height,int width){
  double **mat;
  int j;

  if ((mat=(double **)calloc(height,sizeof(double *)))!=NULL){
    for(j=0;j<height;j++){
      if((mat[j]=(double *)calloc(width,sizeof(double)))==NULL){
	exit(1);
      }
    }
  }else{
    exit(1);
  }

  return mat;
}
/* *************************************************************************************************************** */
/*
 * @param array
 * @param height
 */
void dealloc2Ddouble(double **array,int height){
  int i;

  for(i=(height-1);i>=0;i--){
    free(array[i]);
  }
  free(array);
}
/* *************************************************************************************************************** */
/*
 * @param array
 * @param height
 */
void dealloc2Dint(int **array,int height){
  int i;

  for(i=(height-1);i>=0;i--){
    free(array[i]);
  }
  free(array);
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
int sequence2int(sequence_t<ALPHABET> &s){

	double d=0.0;

	int f;
	for(int k=0;k<s.length();k++){
		f=mytable[s[k].asChar()];
		d+=f*std::pow(double(ALPHABET::DIM+1),double(k));
	}

	return int(d);
}
////=======================================================================================================
////DP-PIP
//template <class ALPHABET>
//static ProgressivePIPResult<ALPHABET> compute_DP_PIP_optimized_2(ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,std::ostream& fileTr){
//
//	int up_corner_i;
//	int up_corner_j;
//	int bot_corner_i;
//	int bot_corner_j;
//	int lw,lh;
//
//	ProgressivePIPResult<ALPHABET> result;
//
//	int h=get_length_seq(result_L.MSA)+1;
//	int w=get_length_seq(result_R.MSA)+1;
//
//	int d=(h-1)+(w-1)+1;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	Eigen::MatrixXd PX=Eigen::MatrixXd::Zero(h,w);
//	Eigen::MatrixXd PY=Eigen::MatrixXd::Zero(h,w);
//	Eigen::MatrixXd PM=Eigen::MatrixXd::Zero(h,w);
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();
//
//	double pc0;
//	double fv0;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	sequence_t<ALPHABET> sL;
//	sequence_t<ALPHABET> sR;
//	sequence_t<ALPHABET> col_gap_L;
//	sequence_t<ALPHABET> col_gap_R;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	col_gap_L=create_col_MSA_gap(result_L.MSA);
//	col_gap_R=create_col_MSA_gap(result_R.MSA);
//
//	std::map<std::string,Eigen::VectorXd> temp_fv_map;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	double lk_gap;
//	double pc0_subtree;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	std::cout<<"random generator ON\n";
//	unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
//	std::default_random_engine generator(seed);
////	std::default_random_engine generator(1);
//	std::uniform_real_distribution<double> distribution(0.0,1.0);
//	//.-----.------.------.//
////	std::cout<<"random generator OFF\n";
////	unsigned seed = 0;
////	std::default_random_engine generator(seed);
////	std::uniform_real_distribution<double> distribution(0.0,1.0);
////	double random_number;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	double epsilon=DBL_EPSILON;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	if(!tree[0].isLeaf()){
//		if(result_L.Pc.size()!=(h-1)){
//			error("DIMENSION wrong\n");
//		}
//	}
//	if(!tree[1].isLeaf()){
//		if(result_R.Pc.size()!=(w-1)){
//			error("DIMENSION wrong\n");
//		}
//	}
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	fv0=compute_fv_new_fast(tree,col_gap_L,col_gap_R,matFv,pi);
//	fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,col_gap_L,col_gap_R,pi);
//
////	lk_gap=result_L.lk_gap+result_R.lk_gap;
//	pc0_subtree=result_L.pc0+result_R.pc0;
//
////	result.lk_gap=0.0;//lk_gap+tree.get_iota()*tree.get_beta()*fv0;
//
//	pc0=compute_Pe_new(tree,fv0,pc0_subtree);
//
//	result.pc0=pc0;
//
//	double** LogM = new double*[2];
//	double** LogX = new double*[2];
//	double** LogY = new double*[2];
//	int** TR = new int*[d];
//
//	LogM[0] = new double[int((w*(h+1))/2)];
//	LogX[0] = new double[int((w*(h+1))/2)];
//	LogY[0] = new double[int((w*(h+1))/2)];
//	LogM[1] = new double[int((w*(h+1))/2)];
//	LogX[1] = new double[int((w*(h+1))/2)];
//	LogY[1] = new double[int((w*(h+1))/2)];
//
//	LogM[0][0]=nu*(pc0-1.0);
//	LogX[0][0]=nu*(pc0-1.0);
//	LogY[0][0]=nu*(pc0-1.0);
//
//	TR[0] = new int[1]();
//	TR[0][0]=STOP_STATE;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	typedef typename std::set< std::pair<int,int> > ::const_iterator it_pair;
//
//	double max_of_3;
//	double max_lk=-INFINITY;
//	int level_max_lk=-INFINITY;
//	double val;
//	int m_binary_this;
//	int m_binary_prev;
//
//	int size_m;
//	int size_x;
//	int size_y;
//
//	double valM;
//	double valX;
//	double valY;
//
//	int idx;
//	int idxX,idxY;
//
////	int coordSeq_1;
////	int coordSeq_2;
//	int ix;
//	int jy;
////	int coordTriangle_prev_i;
////	int coordTriangle_prev_j;
//
//
//	int counter=0;
//	int max_counter=10;
//	bool flag_exit=false;
//	int last_d=d-1;
//
//	for(int m=1;m<d;m++){
//
//		if(flag_exit){
//			break;
//		}
//
//		m_binary_this=m%2;
//		m_binary_prev=(m+1)%2;
//
//		TR[m] = new int[h*w](); /*TODO: optimize size TR*/
//		memset(TR[m],0,h*w);
//
//		//***************************************************************************************
//		//***************************************************************************************
////		set_indexes_match(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
////		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);
//
//		set_indexes_match_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//
//		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){
//
//			lw=0;
//			for(int i=up_corner_i;i<=bot_corner_i;i++){
//				ix=i;
//				sL=create_col_MSA(result_L.MSA,ix-1);
//				for(int j=0;j<=lw;j++){
//					jy=up_corner_j-j;
//
////					coordSeq_1=ix-1;
////					coordSeq_2=jy-1;
////					coordTriangle_prev_i=ix-1;
////					coordTriangle_prev_j=jy-1;
//
//					sR=create_col_MSA(result_R.MSA,jy-1);
//
//					idx=get_linear_indices_M_new(ix-1,jy-1,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valM=LogM[m_binary_prev][idx];
//					}else{
//						valM=-INFINITY;
//					}
//
//					idx=get_linear_indices_X_new(ix-1,jy-1,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valX=LogX[m_binary_prev][idx];
//					}else{
//						valX=-INFINITY;
//					}
//
//					idx=get_linear_indices_Y_new(ix-1,jy-1,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valY=LogY[m_binary_prev][idx];
//					}else{
//						valY=-INFINITY;
//					}
//
//					val=computeLK_Mopt_all_edges(result_L.fv_map,
//										result_R.fv_map,
//										temp_fv_map,
//										valM,
//										valX,
//										valY,
//										ix-1,jy-1,
//										nu,
//										tree,
//										sL,sR,
//										pi,
//										PM,
//										m);
//
//					idx=get_linear_indices_M_new(ix,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//
//					LogM[m_binary_this][idx]=val;
//
//				}
//				lw++;
//			}
//
//		}
//		//***************************************************************************************
//		//***************************************************************************************
////		set_indexes_gapx(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
////		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);
//
//		set_indexes_gapx_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//
//		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){
//
//			lw=0;
//			for(int i=up_corner_i;i<=bot_corner_i;i++){
//				ix=i;
//				sL=create_col_MSA(result_L.MSA,ix-1);
//				for(int j=0;j<=lw;j++){
//					jy=up_corner_j-j;
//
////					coordSeq_1=ix-1;
////					coordSeq_2=jy;
////					coordTriangle_prev_i=ix-1;
////					coordTriangle_prev_j=jy;
//
//
//
//					idx=get_linear_indices_M_new(ix-1,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valM=LogM[m_binary_prev][idx];
//					}else{
//						valM=-INFINITY;
//					}
//
//					idx=get_linear_indices_X_new(ix-1,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valX=LogX[m_binary_prev][idx];
//					}else{
//						valX=-INFINITY;
//					}
//
//					idx=get_linear_indices_Y_new(ix-1,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valY=LogY[m_binary_prev][idx];
//					}else{
//						valY=-INFINITY;
//					}
//
//					val=computeLK_Xopt_all_edges(result_L.fv_map,
//										result_R.fv_map,
//										temp_fv_map,
//										valM,
//										valX,
//										valY,
//										ix-1,jy,
//										nu,
//										result_L,tree,
//										sL,col_gap_R,
//										pi,
//										PX,
//										m);
//
//					idx=get_linear_indices_X_new(ix,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//
//					LogX[m_binary_this][idx]=val;
//
//				}
//				lw++;
//			}
//
//		}
//		//***************************************************************************************
//		//***************************************************************************************
////		set_indexes_gapy(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
////		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);
//
//		set_indexes_gapy_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//
//		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){
//
//			lw=0;
//			for(int i=up_corner_i;i<=bot_corner_i;i++){
//				ix=i;
//				for(int j=0;j<=lw;j++){
//					jy=up_corner_j-j;
//
////					coordSeq_1=ix;
////					coordSeq_2=jy-1;
////					coordTriangle_prev_i=ix;
////					coordTriangle_prev_j=jy-1;
//
//					sR=create_col_MSA(result_R.MSA,jy-1);
//
//					idx=get_linear_indices_M_new(ix,jy-1,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valM=LogM[m_binary_prev][idx];
//					}else{
//						valM=-INFINITY;
//					}
//
//					idx=get_linear_indices_X_new(ix,jy-1,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valX=LogX[m_binary_prev][idx];
//					}else{
//						valX=-INFINITY;
//					}
//
//					idx=get_linear_indices_Y_new(ix,jy-1,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
//					if(idx>=0){
//						valY=LogY[m_binary_prev][idx];
//					}else{
//						valY=-INFINITY;
//					}
//
//					val=computeLK_Yopt_all_edges(result_L.fv_map,
//										result_R.fv_map,
//										temp_fv_map,
//										valM,
//										valX,
//										valY,
//										ix,jy-1,
//										nu,
//										result_R,tree,
//										col_gap_L,sR,
//										pi,
//										PY,
//										m);
//
//					idx=get_linear_indices_Y_new(ix,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//
//					LogY[m_binary_this][idx]=val;
//
//				}
//				lw++;
//			}
//
//		}
//		//***************************************************************************************
//		//***************************************************************************************
////		set_indexes_tr(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
////		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);
//
//		set_indexes_tr_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//
//		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){
//
//			lw=0;
//			for(int i=up_corner_i;i<=bot_corner_i;i++){
//				for(int j=0;j<=lw;j++){
//
//					ix=i;
//					jy=up_corner_j-j;
//
//					double mval;
//					double xval;
//					double yval;
//
//					idx=get_this_linear_indices_M(ix,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//					if(idx>=0){
//						mval=LogM[m_binary_this][idx];
//					}else{
//						mval=-INFINITY;
//					}
//
//					idx=get_this_linear_indices_X(ix,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//					if(idx>=0){
//						xval=LogX[m_binary_this][idx];
//					}else{
//						xval=-INFINITY;
//					}
//
//					idx=get_this_linear_indices_Y(ix,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//					if(idx>=0){
//						yval=LogY[m_binary_this][idx];
//					}else{
//						yval=-INFINITY;
//					}
//
//					mval=fabs(mval)<epsilon?-INFINITY:mval;
//					xval=fabs(xval)<epsilon?-INFINITY:xval;
//					yval=fabs(yval)<epsilon?-INFINITY:yval;
//
//					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//					//(*TR[m]).coeffRef(first,second)=index_of_max_3(mval,xval,yval,epsilon,generator,distribution);
//					//sub2ind(first,second,idx,h,w);
//
//					int ttrr;
//
//					ttrr=index_of_max_3(mval,xval,yval,epsilon,generator,distribution);
//
//					idx=linear_indices_TR(ix,jy,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
//
//					if(TR[m][idx]!=0){
//						std::cout<<"already assigned!!!\n";
//						exit(EXIT_FAILURE);
//					}
//
//					TR[m][idx]=ttrr;
//
//					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//					if( (ix==(h-1)) & (jy==(w-1)) ){
//
//						max_of_3=max_of_three_2(mval,xval,yval,epsilon);
//
////						if(max_of_3>max_lk){
////							max_lk=max_of_3;
////							level_max_lk=m;
////						}
//
//						if(max_of_3>max_lk){ //TODO: random choice between equal max
//							max_lk=max_of_3;
//							level_max_lk=m;
//						}else{
//							counter++;
//							if(counter>max_counter){
//								flag_exit=true;
//								last_d=m;
//								break;
//							}
//						}
//
//
//					}
//					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//				}
//				lw++;
//			}
//
//		}
//	}
//
//	result.score=max_lk;
//
//
//
//
//
//
//	std::cout<<result.score<<"\n";
//
//
//
//
//
//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	sequence_t<ALPHABET> traceback_path(level_max_lk,ALPHABET::unknow);
//
//	int id1=h-1;
//	int id2=w-1;
//
//	for(int lev=level_max_lk;lev>0;lev--){
//		set_indexes_tr(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,lev,h,w);
//		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);
//		idx=linear_indices_TR(id1,id2,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,lev,h,w);
//
//		switch(TR[lev][idx]){
//	        case MATCH_STATE:
//	            id1=id1-1;
//	            id2=id2-1;
//	            traceback_path[lev-1]=ALPHABET::match;
//	            break;
//	        case GAP_X_STATE:
//	            id1=id1-1;
//	            traceback_path[lev-1]=ALPHABET::gapX;
//	            break;
//	        case GAP_Y_STATE:
//	            id2=id2-1;
//	            traceback_path[lev-1]=ALPHABET::gapY;
//	            break;
//	        default:
//	        	error("ERROR in alignment_reconstruction !!!");
//	            exit(EXIT_FAILURE);
//	    }
//	}
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	result.traceback_path=traceback_path;
//
//	fill_Pc_new3(result,traceback_path,PM,PX,PY);
//
//	result.MSA=build_MSA_PIP<ALPHABET>(traceback_path,result_L.MSA,result_R.MSA,fileTr);
//
//	update_fv_map(result,temp_fv_map,result.MSA);
//
//	free(LogM[1]);
//	free(LogM[0]);
//	free(LogM);
//
//	free(LogX[1]);
//	free(LogX[0]);
//	free(LogX);
//
//	free(LogY[1]);
//	free(LogY[0]);
//	free(LogY);
//
//	for(int i=last_d;i>=0;i--){
//		free(TR[i]);
//	}
//	free(TR);
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	return result;
//}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double getPc(ProgressivePIPResult<ALPHABET> &result,int idx){

	if(result.Pc.rows() * result.Pc.cols() == 0){
		return 0.0;
	}else{
		if(idx<0 || idx>=result.Pc.size()){
			std::cout<<"idx="<<idx<<"\n";
			error("ERROR in getPc: out of boundary !!!");
			exit(EXIT_FAILURE);
		}
		return result.Pc[idx];
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_pr_gap_local_tree(	PhyTree &tree,
						sequence_t<ALPHABET> &sL,
						sequence_t<ALPHABET> &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

//	double pr;
//	double pL;
//	double p0;
//	double pR;
//	double fv0;
//	Eigen::VectorXd fv;
//
//
//	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
//
//	MapIterator itL=map_L.find(stringFromSequence<ALPHABET>(sL));
//	if(itL == map_L.end()){
//		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sL);
//		exit(EXIT_FAILURE);
//	}
//	Eigen::VectorXd &fvL=itL->second;
//
//	MapIterator itR=map_R.find(stringFromSequence<ALPHABET>(sR));
//	if(itR == map_R.end()){
//		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sR);
//		exit(EXIT_FAILURE);
//	}
//	Eigen::VectorXd &fvR=itR->second;
//
//	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);
//
//	std::string	s;
//	s.append(stringFromSequence(sL));
//	s.append(stringFromSequence(sR));
//
//	map0[s]=fv;
//
//	fv0=fv.dot(pi);
//
//	if(tree[0].isLeaf()){
//
//		if(sL.length()!=1){
//			error("ERROR in compute_pr_gap");
//			exit(EXIT_FAILURE);
//		}
//
//		pL=tree[0].get_iota() - tree[0].get_iota() * tree[0].get_beta();
//	}else{
//		pL=0.0;
//	}
//
//	if(tree[1].isLeaf()){
//
//		if(sR.length()!=1){
//			error("ERROR in compute_pr_gap");
//			exit(EXIT_FAILURE);
//		}
//
//		pR=tree[1].get_iota() - tree[1].get_iota() * tree[1].get_beta();
//	}else{
//		pR=0.0;
//	}
//
//	if(tree.getParent()==NULL){
//		p0=tree.get_iota()*fv0;
//	}else{
//		p0=tree.get_iota()-tree.get_iota()*tree.get_beta()+tree.get_iota()*tree.get_beta()*fv0;
//	}
//
//	pr=p0 + pL + pC +pR;
//
//	pC=pr;
//
//	return pr;

//------------------------------------------------------------------------------------------------

	double fv0;
	double pr;
//	double val;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;
	int idx;

	idx=0;
	fvL=go_down_left(tree,sL,idx);

	idx=0;
	fvR=go_down_right(tree,sR,idx);

	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	fv0=fv.dot(pi);

//	pr=tree.get_iota()*tree.get_beta()*fv0;
	pr=tree.get_iota()*fv0;

	double pL,pR;
	pL=compute_lk_gap_down<ALPHABET>(tree[0],sL,pi);
	pR=compute_lk_gap_down<ALPHABET>(tree[1],sR,pi);

//	std::cout<<"pr("<<tree.getName()<<")"; printf(" %18.16lf\n",pr);
//	std::cout<<"prL("<<tree.getName()<<")"; printf(" %18.16lf\n",pL);
//	std::cout<<"prR("<<tree.getName()<<")"; printf(" %18.16lf\n",pR);

	pr=pr+pL+pR;


	return pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_pr_gap_local_tree_s(PhyTree &tree,
						std::string &sL,
						std::string &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

	double fv0;
	double pr;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;
	int idx;

	idx=0;
	fvL=go_down_s<ALPHABET>(tree[0],sL,idx);

	idx=0;
	fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	fv0=fv.dot(pi);

	pr=tree.get_iota()*fv0;

	double pL,pR;
	pL=compute_lk_gap_down_s<ALPHABET>(tree[0],sL,pi);
	pR=compute_lk_gap_down_s<ALPHABET>(tree[1],sR,pi);

	pr=pr+pL+pR;

	return pr;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_pr_gap_all_edges_s(	PhyTree &tree,
						std::string &sL,
						std::string &sR,
						Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

	double fv0;
	double pr;
	Eigen::VectorXd fvL;
	Eigen::VectorXd fvR;
	Eigen::VectorXd fv;
	int idx;

	idx=0;
	fvL=go_down_s<ALPHABET>(tree[0],sL,idx);

	idx=0;
	fvR=go_down_s<ALPHABET>(tree[1],sR,idx);

	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	fv0=fv.dot(pi);

//	pr=tree.get_iota()*fv0;
	if(tree.getParent()==NULL){
		pr=(tree.get_iota()*fv0);
	}else{
		pr=(tree.get_iota() - tree.get_iota()*tree.get_beta() + tree.get_iota()*tree.get_beta()*fv0);
	}


	double pL,pR;
	pL=compute_lk_gap_down_s<ALPHABET>(tree[0],sL,pi);
	pR=compute_lk_gap_down_s<ALPHABET>(tree[1],sR,pi);

#ifdef VERBOSE
	printf("pco(pr): %18.16lf\n",pr);
	printf("pc0(pL): %18.16lf\n",pL);
	printf("pc0(pR): %18.16lf\n",pR);
#endif

	pr=pr+pL+pR;

	//*************************************************************************************************
	PhyTree *p_tree=&tree;

	while(p_tree->getParent()!=NULL){

		fv=(p_tree->get_Pr()*fv);

		fv0=fv.dot(pi);

		if(p_tree->getParent()->getParent()==NULL){
			pr+=(p_tree->getParent()->get_iota()*fv0);
		}else{
			pr+=(p_tree->getParent()->get_iota() - p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta() + p_tree->getParent()->get_iota()*p_tree->getParent()->get_beta()*fv0);
		}

		p_tree=p_tree->getParent();
	}
	//*************************************************************************************************

#ifdef VERBOSE
	printf("pco(pr0): %18.16lf\n",pr);
#endif


	return pr;
}
//=======================================================================================================
//DP-PIP
std::string dec2bin(int v,int len){
	std::string bin;
	int oneorzero;

	for(int i=len;i>0;i--) {
		oneorzero = v % 2;
		if (oneorzero == 1) {
			bin = "A" + bin;
		}
		else {
			bin = "-" + bin;
		}
		v /= 2;

	}

	return bin;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void test_computeLK_Xopt_all_edges_local_tree(PhyTree &tree,const ModelFactory<ALPHABET> *model_factory){

	double tau;
	double nu;
	double val;
	int m;
	double valM,valX,valY;
	sequence_t<ALPHABET> sL;

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	tau=tree.computeLength();
	nu=model_factory->lambda*(tau+1/model_factory->mu);

	std::cout<<"****************************************\n";
	std::cout<<"TEST at :"<<tree.getName()<<"\n";

	int size;
	int len;
	int slen;
	//t0
//	if(tree.getName()=="V3"){
//		size=1;
//		len=1;
//		slen=1;
//	}else if (tree.getName()=="V2") {
//		size=1;
//		len=4;
//		slen=2;
//	}else if (tree.getName()=="V1") {
//		size=1;
//		len=8;
//		slen=3;
//	}else if (tree.getName()=="V5") {
//		size=1;
//		len=1;
//		slen=1;
//	}else if (tree.getName()=="V4") {
//		size=2;
//		len=1;
//		slen=1;
//	}else if (tree.getName()=="V0") {
//		size=3;
//		len=16;
//		slen=4;
//	}

	//t1
	if(tree.getName()=="V2"){
		size=1;
		len=1;
		slen=1;
	}else if (tree.getName()=="V1") {
		size=1;
		len=4;
		slen=2;
	}else if (tree.getName()=="V5") {
		size=1;
		len=1;
		slen=1;
	}else if (tree.getName()=="V4") {
		size=2;
		len=1;
		slen=1;
	}else if (tree.getName()=="V3") {
		size=3;
		len=1;
		slen=1;
	}else if (tree.getName()=="V0") {
		size=4;
		len=8;
		slen=3;
	}



	sequence_t<ALPHABET> col_gap_R(size,ALPHABET::GAP);

	valM=-1.0;
	valX=-1.0;
	valY=-1.0;

	m=1;

	for(int i=1;i<=len;i++){
		sL=sequenceFromStringPIP<ALPHABET>(dec2bin(i,slen));
		val=computeLK_Xopt_all_edges_local_tree(valM,valX,valY,nu,tree,sL,col_gap_R,pi,m);
	}
	std::cout<<"****************************************\n";
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void test_computeLK_Yopt_all_edges_local_tree(PhyTree &tree,const ModelFactory<ALPHABET> *model_factory){

	double tau;
	double nu;
	double val;
	int m;
	double valM,valX,valY;
	sequence_t<ALPHABET> sR;

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	tau=tree.computeLength();
	nu=model_factory->lambda*(tau+1/model_factory->mu);

	std::cout<<"****************************************\n";
	std::cout<<"TEST at :"<<tree.getName()<<"\n";

	int size;
	int len;
	int slen;
	//t0
//	if(tree.getName()=="V3"){
//		size=1;
//		len=1;
//		slen=1;
//	}else if (tree.getName()=="V2") {
//		size=2;
//		len=1;
//		slen=1;
//	}else if (tree.getName()=="V1") {
//		size=3;
//		len=1;
//		slen=1;
//	}else if (tree.getName()=="V5") {
//		size=1;
//		len=1;
//		slen=1;
//	}else if (tree.getName()=="V4") {
//		size=1;
//		len=4;
//		slen=2;
//	}else if (tree.getName()=="V0") {
//		size=4;
//		len=8;
//		slen=3;
//	}

	//t1
	if(tree.getName()=="V2"){
		size=1;
		len=1;
		slen=1;
	}else if (tree.getName()=="V1") {
		size=2;
		len=1;
		slen=1;
	}else if (tree.getName()=="V5") {
		size=1;
		len=1;
		slen=1;
	}else if (tree.getName()=="V4") {
		size=1;
		len=4;
		slen=2;
	}else if (tree.getName()=="V3") {
		size=1;
		len=8;
		slen=3;
	}else if (tree.getName()=="V0") {
		size=3;
		len=16;
		slen=4;
	}

	sequence_t<ALPHABET> col_gap_L(size,ALPHABET::GAP);

	valM=-1.0;
	valX=-1.0;
	valY=-1.0;

	m=1;

	for(int i=1;i<=len;i++){
		sR=sequenceFromStringPIP<ALPHABET>(dec2bin(i,slen));
		val=computeLK_Yopt_all_edges_local_tree(valM,valX,valY,nu,tree,col_gap_L,sR,pi,m);
	}
	std::cout<<"****************************************\n";
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static std::vector<ProgressivePIPResult<ALPHABET>> compute_DP_PIP_optimized_2(ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,PhyTree &tree,const ModelFactory<ALPHABET> *model_factory,double gamma_rate,int num_subopt){

	double tau;
	double nu;

	//@gamma_distribution
	double lambda_gamma=model_factory->lambda*gamma_rate;
	double mu_gamma=model_factory->mu*gamma_rate;;

	tau=tree.computeLength();
	nu=lambda_gamma*(tau+1/mu_gamma);
	tree.set_tau(tau);
	tree.set_nu(nu);
	//@gamma_distribution
	tree.set_iota_local(tau,mu_gamma);
	tree.set_beta_local(tau,mu_gamma);

	int up_corner_i;
	int up_corner_j;
	int bot_corner_i;
	int bot_corner_j;
	int lw;
	int h,w;

	ProgressivePIPResult<ALPHABET> result;

	h=get_length_seq_s<ALPHABET>(result_L.MSAs)+1;
	w=get_length_seq_s<ALPHABET>(result_R.MSAs)+1;
	int d=(h-1)+(w-1)+1;

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	double pc0;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	std::string sLs;
	std::string sRs;
	std::string col_gap_Ls;
	std::string col_gap_Rs;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	col_gap_Ls=create_col_MSA_gap_s(result_L.MSAs.size());
	col_gap_Rs=create_col_MSA_gap_s(result_R.MSAs.size());
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	std::cout<<"random generator ON\n";
	unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
	std::default_random_engine generator(seed);
	std::uniform_real_distribution<double> distribution(0.0,1.0);
	//.-----.------.------.//
//	std::cout<<"random generator OFF\n";
//	unsigned seed = 0;
//	std::default_random_engine generator(seed);
//	std::uniform_real_distribution<double> distribution(0.0,1.0);
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	double epsilon=DBL_EPSILON;

	pc0=compute_pr_gap_local_tree_s<ALPHABET>(tree,
									col_gap_Ls,
									col_gap_Rs,
									pi);
#ifdef VERBOSE
	printf("pc0 %18.16lf\n\n",pc0);
#endif

	double** LogM = new double*[2];
	double** LogX = new double*[2];
	double** LogY = new double*[2];

	int** TR = new int*[d];

	LogM[0] = new double[int((w*(h+1))/2)];
	LogX[0] = new double[int((w*(h+1))/2)];
	LogY[0] = new double[int((w*(h+1))/2)];
	LogM[1] = new double[int((w*(h+1))/2)];
	LogX[1] = new double[int((w*(h+1))/2)];
	LogY[1] = new double[int((w*(h+1))/2)];

	LogM[0][0]=nu*(pc0-1.0);
	LogX[0][0]=nu*(pc0-1.0);
	LogY[0][0]=nu*(pc0-1.0);

	TR[0] = new int[1]();
	TR[0][0]=STOP_STATE;

	double max_of_3;
	double max_lk=-INFINITY;
	int level_max_lk=INT_MIN;
	double val;
	int m_binary_this;
	int m_binary_prev;

	double valM;
	double valX;
	double valY;

	int idx;

	int coordSeq_1;
	int coordSeq_2;
	int coordTriangle_this_i;
	int coordTriangle_this_j;
	int coordTriangle_prev_i;
	int coordTriangle_prev_j;

	int counter=0;

	double *scores = new double[num_subopt];

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	int max_counter=5;
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	bool flag_exit=false;
	int last_d=d-1;

	std::map<std::string,double> lkM;
	std::map<std::string,double> lkX;
	std::map<std::string,double> lkY;
	for(int m=1;m<d;m++){

		if(flag_exit){
			break;
		}

		m_binary_this=m%2;
		m_binary_prev=(m+1)%2;

		TR[m] = new int[int((w*(h+1))/2)](); /*TODO: optimize size TR*/
		memset(TR[m],0,int((w*(h+1))/2)*sizeof(TR[m][0]));
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_match_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;
				coordSeq_1=coordTriangle_this_i-1;
				coordTriangle_prev_i=coordTriangle_this_i-1;
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordSeq_2=coordTriangle_this_j-1;
					coordTriangle_prev_j=coordTriangle_this_j-1;

					sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}

					val=computeLK_M_local_tree_s_opt<ALPHABET>(	valM,
																valX,
																valY,
																nu,
																tree,
																sLs,sRs,
																pi,
																m,
																lkM);

					idx=get_linear_indices_M_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogM[m_binary_this][idx]=val;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_gapx_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;
				coordTriangle_prev_i=coordTriangle_this_i-1;
				coordSeq_1=coordTriangle_this_i-1;

				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordTriangle_prev_j=coordTriangle_this_j;

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}

					val=computeLK_X_local_tree_s_opt<ALPHABET>(valM,
															valX,
															valY,
															nu,
															tree,
															sLs,col_gap_Rs,
															pi,
															m,
															lkX);

					idx=get_linear_indices_X_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogX[m_binary_this][idx]=val;

				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_gapy_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				coordTriangle_this_i=i;
				coordTriangle_prev_i=coordTriangle_this_i;
				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordSeq_2=coordTriangle_this_j-1;
					coordTriangle_prev_j=coordTriangle_this_j-1;

					sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}

					val=computeLK_Y_local_tree_s_opt<ALPHABET>(valM,
															valX,
															valY,
															nu,
															tree,
															col_gap_Ls,sRs,
															pi,
															m,
															lkY);

					idx=get_linear_indices_Y_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogY[m_binary_this][idx]=val;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_tr_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;

					double mval;
					double xval;
					double yval;

					idx=get_this_linear_indices_M(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						mval=LogM[m_binary_this][idx];
					}else{
						mval=-INFINITY;
					}

					idx=get_this_linear_indices_X(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						xval=LogX[m_binary_this][idx];
					}else{
						xval=-INFINITY;
					}

					idx=get_this_linear_indices_Y(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						yval=LogY[m_binary_this][idx];
					}else{
						yval=-INFINITY;
					}

					mval=fabs(mval)<epsilon?-INFINITY:mval;
					xval=fabs(xval)<epsilon?-INFINITY:xval;
					yval=fabs(yval)<epsilon?-INFINITY:yval;

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
					int ttrr;

					ttrr=index_of_max_3(mval,xval,yval,epsilon,generator,distribution);

					idx=linear_indices_TR(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					if(TR[m][idx]!=0){
						std::cout<<"already assigned!!!\n";
						exit(EXIT_FAILURE);
					}

					TR[m][idx]=ttrr;

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
					if( (coordTriangle_this_i==(h-1)) & (coordTriangle_this_j==(w-1)) ){

						max_of_3=max_of_three_2(mval,xval,yval,epsilon);

						if(max_of_3>max_lk){ //TODO: random choice between equal max
							max_lk=max_of_3;
							level_max_lk=m;
						}else{
							counter++;
							if(counter>max_counter){
								flag_exit=true;
								last_d=m;
								break;
							}
						}

					}
					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

				}
				lw++;
			}

		}


	}

	result.score=max_lk;

	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	int start_depth;
	int minL= h-1>w-1 ? h-1 : w-1;
	int maxL=d-1;
	int deltaL;
	int left,right;
	int depth;


	//TODO: controllare max_count perche' magari nn ci sono abbastanza layer...

	bool CENTER = true;

	if(CENTER){
		deltaL=std::floor((num_subopt-1)/2);
		left= level_max_lk-deltaL>minL ? level_max_lk-deltaL : minL;
		right= left+num_subopt-1<maxL ? left+num_subopt-1 : maxL;
		num_subopt = right-left +1;
		start_depth=left;
	}else{
		start_depth=level_max_lk;
		right= maxL < start_depth+num_subopt-1 ? maxL : start_depth+num_subopt-1;
		num_subopt= right - start_depth +1;
	}

	std::vector<ProgressivePIPResult<ALPHABET>> result_v;
	for(int k=0;k<num_subopt;k++){
		ProgressivePIPResult<ALPHABET> result;
		result.score=scores[k];

		depth=start_depth+k;

		sequence_t<ALPHABET> traceback_path(depth,ALPHABET::unknow);
		int id1=h-1;
		int id2=w-1;
		for(int lev=depth;lev>0;lev--){
			set_indexes_tr_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,lev,h,w);
			idx=linear_indices_TR(id1,id2,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,lev,h,w);
			switch(TR[lev][idx]){
				case MATCH_STATE:
					id1=id1-1;
					id2=id2-1;
					traceback_path[lev-1]=ALPHABET::match;
					break;
				case GAP_X_STATE:
					id1=id1-1;
					traceback_path[lev-1]=ALPHABET::gapX;
					break;
				case GAP_Y_STATE:
					id2=id2-1;
					traceback_path[lev-1]=ALPHABET::gapY;
					break;
				default:
					error("ERROR in alignment_reconstruction !!!");
					exit(EXIT_FAILURE);
			}
		}
		result.traceback_path=traceback_path;

		result.MSAs=build_MSA_PIP_s<ALPHABET>(traceback_path,result_L.MSAs,result_R.MSAs);

		result_v.push_back(result);
	}
	delete scores;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	free(LogM[1]);
	free(LogM[0]);
	free(LogM);

	free(LogX[1]);
	free(LogX[0]);
	free(LogX);

	free(LogY[1]);
	free(LogY[0]);
	free(LogY);

	for(int i=last_d;i>=0;i--){
		free(TR[i]);
	}
	free(TR);
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	return result_v;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static std::vector<ProgressivePIPResult<ALPHABET>> compute_DP_PIP_optimized_3(ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,PhyTree &tree,const ModelFactory<ALPHABET> *model_factory,double tau,double nu,double gamma_rate,int num_subopt,bool local){

//	double tau;
//	double nu;

	//@gamma_distribution
	double lambda_gamma=model_factory->lambda*gamma_rate;
	double mu_gamma=model_factory->mu*gamma_rate;

	if(local){
		tau=tree.computeLength();
		nu=lambda_gamma*(tau+1/mu_gamma);
		tree.set_tau(tau);
		tree.set_nu(nu);
		//@gamma_distribution
		tree.set_iota_local(tau,mu_gamma);
		tree.set_beta_local(tau,mu_gamma);
	}


	printf("tau %lf\n",tau);

	std::cout<<"Tree:\n";
	tree.print_br();
	std::cout<<"\n";



	int up_corner_i;
	int up_corner_j;
	int bot_corner_i;
	int bot_corner_j;
	int lw;
	int h,w;

	h=get_length_seq_s<ALPHABET>(result_L.MSAs)+1;
	w=get_length_seq_s<ALPHABET>(result_R.MSAs)+1;
	int d=(h-1)+(w-1)+1;

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	double pc0;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	std::string sLs;
	std::string sRs;
	std::string col_gap_Ls;
	std::string col_gap_Rs;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	col_gap_Ls=create_col_MSA_gap_s(result_L.MSAs.size());
	col_gap_Rs=create_col_MSA_gap_s(result_R.MSAs.size());
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	std::cout<<"random generator ON\n";
	unsigned int seed = std::chrono::system_clock::now().time_since_epoch().count();
	std::default_random_engine generator(seed);
	std::uniform_real_distribution<double> distribution(0.0,1.0);
	//.-----.------.------.//
//	std::cout<<"random generator OFF\n";
//	unsigned seed = 0;
//	std::default_random_engine generator(seed);
//	std::uniform_real_distribution<double> distribution(0.0,1.0);
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	double epsilon=DBL_EPSILON;

	if(local){
		pc0=compute_pr_gap_local_tree_s<ALPHABET>(tree,
										col_gap_Ls,
										col_gap_Rs,
										pi);
	}else{
		pc0=compute_pr_gap_all_edges_s<ALPHABET>(tree,
										col_gap_Ls,
										col_gap_Rs,
										pi);
	}

#ifdef VERBOSE
	printf("pc0 %18.16lf\n",pc0);
#endif

	double** LogM = new double*[2];
	double** LogX = new double*[2];
	double** LogY = new double*[2];

	int** TR = new int*[d];

	LogM[0] = new double[int((w*(h+1))/2)];
	LogX[0] = new double[int((w*(h+1))/2)];
	LogY[0] = new double[int((w*(h+1))/2)];
	LogM[1] = new double[int((w*(h+1))/2)];
	LogX[1] = new double[int((w*(h+1))/2)];
	LogY[1] = new double[int((w*(h+1))/2)];

	LogM[0][0]=nu*(pc0-1.0);
	LogX[0][0]=nu*(pc0-1.0);
	LogY[0][0]=nu*(pc0-1.0);

	TR[0] = new int[1]();
	TR[0][0]=STOP_STATE;

	double max_of_3;
	double max_lk=-INFINITY;
	int level_max_lk=INT_MIN;
	double val;
	int m_binary_this;
	int m_binary_prev;

	double valM;
	double valX;
	double valY;

	int idx;

	int coordSeq_1;
	int coordSeq_2;
	int coordTriangle_this_i;
	int coordTriangle_this_j;
	int coordTriangle_prev_i;
	int coordTriangle_prev_j;

	int counter=0;

	double *scores = new double[num_subopt];

	bool CENTER = true;

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	int max_counter;
	if(CENTER){
//		max_counter= floor(num_subopt/2) < 1 ? 1 :floor(num_subopt/2) ;

		max_counter=num_subopt-1;
	}else{
		max_counter=num_subopt-1;
	}
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	bool flag_exit=false;
	int last_d=d-1;
	int size_tr,tr_up_i,tr_up_j,tr_down_i,tr_down_j;
	std::map<std::string,double> lkM;
	std::map<std::string,double> lkX;
	std::map<std::string,double> lkY;
	for(int m=1;m<d;m++){

		printf("m %d of %d\n",m,d);

		if(flag_exit){
			break;
		}

		m_binary_this=m%2;
		m_binary_prev=(m+1)%2;
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_match_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;
				coordSeq_1=coordTriangle_this_i-1;
				coordTriangle_prev_i=coordTriangle_this_i-1;
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordSeq_2=coordTriangle_this_j-1;
					coordTriangle_prev_j=coordTriangle_this_j-1;
					sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}




					if(std::isinf(valM) && std::isinf(valX) && std::isinf(valY)){
						printf("M\n");
						printf("(%d;%d) -> (%d;%d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);
						printf("coor_i %d coord_j %d this_i %d this_j %d\n",coordTriangle_prev_i,coordTriangle_prev_j,coordTriangle_this_i,coordTriangle_this_j);
						perror("max_of_three_2: all inf\n");
						exit(EXIT_FAILURE);
					}





					if(local){
						val=computeLK_M_local_tree_s_opt<ALPHABET>(	valM,
																	valX,
																	valY,
																	nu,
																	tree,
																	sLs,sRs,
																	pi,
																	m,
																	lkM);
					}else{
						val=computeLK_M_all_edges_s_opt<ALPHABET>(	valM,
																valX,
																valY,
																nu,
																tree,
																sLs,sRs,
																pi,
																m,
																lkM);
					}


					if(std::isinf(val)){
						printf("M: val is inf\n");
						exit(EXIT_FAILURE);
					}

					if(std::isnan(val)){
						printf("M: val is nan\n");
						exit(EXIT_FAILURE);
					}


					idx=get_linear_indices_M_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogM[m_binary_this][idx]=val;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_gapx_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
		tr_down_i=bot_corner_i;
		tr_down_j=bot_corner_j;
		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;
				coordTriangle_prev_i=coordTriangle_this_i-1;
				coordSeq_1=coordTriangle_this_i-1;
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordTriangle_prev_j=coordTriangle_this_j;

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}





					if(std::isinf(valM) && std::isinf(valX) && std::isinf(valY)){
						printf("X\n");
						printf("(%d;%d) -> (%d;%d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);
						printf("coor_i %d coord_j %d this_i %d this_j %d\n",coordTriangle_prev_i,coordTriangle_prev_j,coordTriangle_this_i,coordTriangle_this_j);
						perror("max_of_three_2: all inf\n");
						exit(EXIT_FAILURE);
					}






					if(local){
						val=computeLK_X_local_tree_s_opt<ALPHABET>(valM,
																valX,
																valY,
																nu,
																tree,
																sLs,col_gap_Rs,
																pi,
																m,
																lkX);
					}else{
						val=computeLK_X_all_edges_s_opt<ALPHABET>(valM,
															valX,
															valY,
															nu,
															tree,
															sLs,col_gap_Rs,
															pi,
															m,
															lkX);
					}


					if(std::isinf(val)){
						printf("X: val is inf\n");
						exit(EXIT_FAILURE);
					}

					if(std::isnan(val)){
						printf("X: val is nan\n");
						exit(EXIT_FAILURE);
					}

					idx=get_linear_indices_X_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogX[m_binary_this][idx]=val;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_gapy_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
		tr_up_i=up_corner_i;
		tr_up_j=up_corner_j;
		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				coordTriangle_this_i=i;
				coordTriangle_prev_i=coordTriangle_this_i;
				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordTriangle_prev_j=coordTriangle_this_j-1;
					coordSeq_2=coordTriangle_this_j-1;
					sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}






					if(std::isinf(valM) && std::isinf(valX) && std::isinf(valY)){
						printf("Y\n");
						printf("(%d;%d) -> (%d;%d)\n",up_corner_i,up_corner_j,bot_corner_i,bot_corner_j);
						printf("coor_i %d coord_j %d this_i %d this_j %d\n",coordTriangle_prev_i,coordTriangle_prev_j,coordTriangle_this_i,coordTriangle_this_j);
						perror("max_of_three_2: all inf\n");
						exit(EXIT_FAILURE);
					}




					if(local){
						val=computeLK_Y_local_tree_s_opt<ALPHABET>(valM,
																valX,
																valY,
																nu,
																tree,
																col_gap_Ls,sRs,
																pi,
																m,
																lkY);
					}else{
						val=computeLK_Y_all_edges_s_opt<ALPHABET>(valM,
															valX,
															valY,
															nu,
															tree,
															col_gap_Ls,sRs,
															pi,
															m,
															lkY);
					}

					if(std::isinf(val)){
						printf("Y: val is inf\n");
						exit(EXIT_FAILURE);
					}


					if(std::isnan(val)){
						printf("Y: val is nan\n");
						exit(EXIT_FAILURE);
					}


					idx=get_linear_indices_Y_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogY[m_binary_this][idx]=val;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		size_tr=int(ceil((tr_down_i-tr_up_i+1)*(tr_up_j-tr_down_j+1+1)/2));
		TR[m] = new int[size_tr](); /*TODO: optimize size TR*/
		memset(TR[m],0,size_tr*sizeof(TR[m][0]));
		set_indexes_tr_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				coordTriangle_this_i=i;
				for(int j=0;j<=lw;j++){
					coordTriangle_this_j=up_corner_j-j;

					double mval;
					double xval;
					double yval;

					idx=get_this_linear_indices_M(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						mval=LogM[m_binary_this][idx];
					}else{
						mval=-INFINITY;
					}

					idx=get_this_linear_indices_X(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						xval=LogX[m_binary_this][idx];
					}else{
						xval=-INFINITY;
					}

					idx=get_this_linear_indices_Y(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						yval=LogY[m_binary_this][idx];
					}else{
						yval=-INFINITY;
					}

					mval=fabs(mval)<epsilon?-INFINITY:mval;
					xval=fabs(xval)<epsilon?-INFINITY:xval;
					yval=fabs(yval)<epsilon?-INFINITY:yval;

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
					int ttrr;

					ttrr=index_of_max_3(mval,xval,yval,epsilon,generator,distribution);

					idx=linear_indices_TR(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					if(TR[m][idx]!=0){
						std::cout<<"already assigned!!!\n";
						exit(EXIT_FAILURE);
					}

					TR[m][idx]=ttrr;

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
					if( (coordTriangle_this_i==(h-1)) & (coordTriangle_this_j==(w-1)) ){

						max_of_3=max_of_three_2(mval,xval,yval,epsilon);

						if(max_of_3>max_lk){ //TODO: random choice between equal max
							max_lk=max_of_3;
							level_max_lk=m;
							counter=0;
							scores[counter]=max_lk;
						}else{
							counter++;
							scores[counter]=max_of_3;
							if(counter>=max_counter){
								flag_exit=true;
								last_d=m;
								break;
							}
						}
					}
					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
				}
				lw++;
			}
		}
	}
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	int start_depth;
	int minL= h-1>w-1 ? h-1 : w-1;
	int maxL=d-1;
	int deltaL;
	int left,right;
	int depth;

	//TODO: controllare max_count perche' magari nn ci sono abbastanza layer...
//	if(CENTER){
//		deltaL=std::floor((num_subopt-1)/2);
//		left= level_max_lk-deltaL>minL ? level_max_lk-deltaL : minL;
//		right= left+num_subopt-1<maxL ? left+num_subopt-1 : maxL;
//		num_subopt = right-left +1;
//		start_depth=left;
//	}else{
//		start_depth=level_max_lk;
//		right= maxL < start_depth+num_subopt-1 ? maxL : start_depth+num_subopt-1;
//		num_subopt= right - start_depth +1;
//	}

	start_depth=level_max_lk;
	left= level_max_lk;
	right=left+num_subopt-1;

	if(right>(d-1)){
		right=d-1;
		left=right-num_subopt+1;
		start_depth=left;
	}

//	printf("start_depth %d\n",start_depth);
//	printf("left %d right %d max index %d\n",left,right,d-1);
//	printf("num_subopt %d\n",num_subopt);
//	printf("max_count %d\n",max_counter);






	std::vector<ProgressivePIPResult<ALPHABET>> result_v;
	for(int k=0;k<num_subopt;k++){
		ProgressivePIPResult<ALPHABET> result;
		result.score=scores[k];

		depth=start_depth+k;

		sequence_t<ALPHABET> traceback_path(depth,ALPHABET::unknow);
		int id1=h-1;
		int id2=w-1;
		for(int lev=depth;lev>0;lev--){
			set_indexes_tr_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,lev,h,w);
			idx=linear_indices_TR(id1,id2,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,lev,h,w);
			switch(TR[lev][idx]){
				case MATCH_STATE:
					id1=id1-1;
					id2=id2-1;
					traceback_path[lev-1]=ALPHABET::match;
					break;
				case GAP_X_STATE:
					id1=id1-1;
					traceback_path[lev-1]=ALPHABET::gapX;
					break;
				case GAP_Y_STATE:
					id2=id2-1;
					traceback_path[lev-1]=ALPHABET::gapY;
					break;
				default:
					error("ERROR in alignment_reconstruction !!!");
					exit(EXIT_FAILURE);
			}
		}
		result.traceback_path=traceback_path;
		result.MSAs=build_MSA_PIP_s<ALPHABET>(traceback_path,result_L.MSAs,result_R.MSAs);
		result_v.push_back(result);
	}
	delete scores;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	free(LogM[1]);
	free(LogM[0]);
	free(LogM);

	free(LogX[1]);
	free(LogX[0]);
	free(LogX);

	free(LogY[1]);
	free(LogY[0]);
	free(LogY);

	for(int i=last_d;i>=0;i--){
		free(TR[i]);
	}
	free(TR);
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	return result_v;
}
//=======================================================================================================
//DP-PIP
double bettersum(double x,double y){
// Kahan and Babuska summation, Neumaier variant
// A. Neumaier.
// Rundungsfehleranalyse einiger Verfahren zur Summation endlicher Summen.
// Math. Mechanik, 54:3951, 1974.

	double c;
	double t;

	t= x + y;

	if ( fabs(x) >= fabs(y) ){
		c = ( (x-t) + y );
	}else{
		c = ( (y-t) + x);
	}

	return t + c;
}
//=======================================================================================================
//DP-PIP
double get_scale_factor(double m,double x,double y){

	double s;

	if(m==0.0){
		if(x==0.0){
			s=y;
		}else if(y==0.0){
			s=x;
		}else{
			s= (x>y) ? x : y;
		}
	}else if(x==0.0){
		if(m==0.0){
			s=y;
		}else if(y==0.0){
			s=m;
		}else{
			s= (m>y) ? m : y;
		}
	}else if(y==0.0){
		if(m==0.0){
			s=x;
		}else if(x==0.0){
			s=m;
		}else{
			s= (m>x) ? m : x;
		}
	}else{
		s= (m>x) ? m : x;
		s= (s>y) ? s : y;
	}

	return (-s);
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void forward_SB(	PhyTree &tree,
									long double*** LogM,
									long double*** LogX,
									long double*** LogY,
									int h,int w,int d,
									double nu,
									ProgressivePIPResult<ALPHABET> &result_L,
									ProgressivePIPResult<ALPHABET> &result_R,
									const ModelFactory<ALPHABET> *model_factory,
									std::map<std::string,double> &lkM,
									std::map<std::string,double> &lkX,
									std::map<std::string,double> &lkY,
									bool local){

	int up_corner_i;
	int up_corner_j;
	int bot_corner_i;
	int bot_corner_j;

	int lw;

	std::string sLs;
	std::string sRs;
	std::string col_gap_Ls;
	std::string col_gap_Rs;

	double log_pr,Log_pr;
	double valM;
	double valX;
	double valY;

	int coordSeq_1;
	int coordSeq_2;
	int coordTriangle_this_i;
	int coordTriangle_this_j;
	int coordTriangle_prev_i;
	int coordTriangle_prev_j;

	double pc0;

	double log1;
	double log2;
	double log3;
	double e1,e2,e3,etot;

//	int m_binary_this;
//	int m_binary_prev;

	//*******************************************************************************************************//
	col_gap_Ls=create_col_MSA_gap_s(result_L.MSAs.size());
	col_gap_Rs=create_col_MSA_gap_s(result_R.MSAs.size());

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	if(local){
		pc0=compute_pr_gap_local_tree_s<ALPHABET>(tree,
										col_gap_Ls,
										col_gap_Rs,
										pi);
	}else{
		pc0=compute_pr_gap_all_edges_s<ALPHABET>(tree,
										col_gap_Ls,
										col_gap_Rs,
										pi);
	}

//	LogM[0][0][0]=exp(nu*(pc0-1.0));
//	LogX[0][0][0]=exp(nu*(pc0-1.0));
//	LogY[0][0][0]=exp(nu*(pc0-1.0));

//	LogM[0][0][0]=1.0;
	LogM[0][0][0]=nu*(pc0-1.0);

	double scale_factor;

	for(int m=1;m<d;m++){

//		m_binary_this=m%2;
//		m_binary_prev=(m+1)%2;

		//***************************************************************************************
		//***************************************************************************************
		set_indexes_match_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;
				coordSeq_1=coordTriangle_this_i-1;
				coordTriangle_prev_i=coordTriangle_this_i-1;
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordSeq_2=coordTriangle_this_j-1;
					coordTriangle_prev_j=coordTriangle_this_j-1;
					sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

//					valM=LogM[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
//					valX=LogX[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
//					valY=LogY[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
					valM=LogM[m-1][coordTriangle_prev_i][coordTriangle_prev_j];
					valX=LogX[m-1][coordTriangle_prev_i][coordTriangle_prev_j];
					valY=LogY[m-1][coordTriangle_prev_i][coordTriangle_prev_j];

//					valM = ( std::isinf(valM) || std::isnan(valM)) ? 0.0 : valM;
//					valX = ( std::isinf(valX) || std::isnan(valX)) ? 0.0 : valX;
//					valY = ( std::isinf(valY) || std::isnan(valY)) ? 0.0 : valY;

					if(local){
						log_pr=computeLK_M_local_tree_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
					}else{
						log_pr=computeLK_M_all_edges_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
					}

//					scale_factor = (valM > valX) ? valM : valX;
//					scale_factor = (scale_factor > valY) ? scale_factor : valY;

//					scale_factor=get_scale_factor(valM,valX,valY);

//					printf("scale fator %lf\n",scale_factor);

					if( (valM==0.0) && (valX==0.0) && (valY==0.0) ){
						log1=0.0;
						Log_pr=0.0;
					}else{

						scale_factor=get_scale_factor(valM,valX,valY);


						e1 = (valM==0.0) ? 0.0 : exp(valM+scale_factor);
						e2 = (valX==0.0) ? 0.0 : exp(valX+scale_factor);
						e3 = (valY==0.0) ? 0.0 : exp(valY+scale_factor);

						etot = e1 + e2 + e3;

						log1=log(etot) - scale_factor;

//						log1=log(exp(valM+scale_factor) + exp(valX+scale_factor) + exp(valY+scale_factor)) - scale_factor;



						if(log_pr>=0.0){
							printf("log_pr > 0: %lf\n",log_pr);
							printf("scale factor %lf\n",scale_factor);
							exit(1);
						}
						if(log1>=0.0){
							printf("log1 > 0: %lf\n",log1);
							printf("scale factor %lf\n",scale_factor);
							printf("M %lf X %lf Y %lf\n",valM,valX,valY);
							exit(1);
						}

					}


					Log_pr = log_pr + log1;

					if ( std::isinf(Log_pr) || std::isnan(Log_pr) ){
//						Log_pr=0.0;
						printf("ERROR isinf or isnan (M)\n");
						printf("log_pr %lf ;log1 %lf\n",log_pr,log1);
						printf("scale factor %lf\n",scale_factor);
						printf("M %lf X %lf Y %lf\n",valM,valX,valY);
						printf("e1 %lf e2 %lf e3 %lf\n",e1,e2,e3);
						printf("etot %lf\n",etot);
						exit(EXIT_FAILURE);
					}

//					LogM[m_binary_this][coordTriangle_this_i][coordTriangle_this_j]=Log_pr;
					LogM[m][coordTriangle_this_i][coordTriangle_this_j]=Log_pr;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_gapx_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;
				coordTriangle_prev_i=coordTriangle_this_i-1;
				coordSeq_1=coordTriangle_this_i-1;
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordTriangle_prev_j=coordTriangle_this_j;

//					valM=LogM[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
//					valX=LogX[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
//					valY=LogY[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
					valM=LogM[m-1][coordTriangle_prev_i][coordTriangle_prev_j];
					valX=LogX[m-1][coordTriangle_prev_i][coordTriangle_prev_j];
					valY=LogY[m-1][coordTriangle_prev_i][coordTriangle_prev_j];

//					valM = ( std::isinf(valM) || std::isnan(valM)) ? 0.0 : valM;
//					valX = ( std::isinf(valX) || std::isnan(valX)) ? 0.0 : valX;
//					valY = ( std::isinf(valY) || std::isnan(valY)) ? 0.0 : valY;

					if(local){
						log_pr=computeLK_X_local_tree_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
					}else{
						log_pr=computeLK_X_all_edges_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
					}

//					scale_factor = (valM > valX) ? valM : valX;
//					scale_factor = (scale_factor > valY) ? scale_factor : valY;

//					scale_factor=get_scale_factor(valM,valX,valY);

//					printf("scale fator %lf\n",scale_factor);

					if( (valM==0.0) && (valX==0.0) && (valY==0.0) ){
						log2=0.0;
						Log_pr=0.0;
					}else{

						scale_factor=get_scale_factor(valM,valX,valY);


						e1 = (valM==0.0) ? 0.0 : exp(valM+scale_factor);
						e2 = (valX==0.0) ? 0.0 : exp(valX+scale_factor);
						e3 = (valY==0.0) ? 0.0 : exp(valY+scale_factor);

						etot = e1 + e2 + e3;

						log2=log(etot) - scale_factor;

//						log2=log(exp(valM+scale_factor) + exp(valX+scale_factor) + exp(valY+scale_factor)) - scale_factor;

						if(log_pr>=0.0){
							printf("log_pr > 0:  %lf\n",log_pr);
							printf("scale factor %lf\n",scale_factor);
							exit(1);
						}
						if(log2>=0.0){
							printf("log2 > 0: %lf\n",log2);
							printf("scale factor %lf\n",scale_factor);
							printf("M %lf X %lf Y %lf\n",valM,valX,valY);
							exit(1);
						}

					}

//					double log2=0.0;
//					if(valM<0.0){
//						log2+=exp(valM+scale_factor);
//					}
//					if(valX<0.0){
//						log2+=exp(valX+scale_factor);
//					}
//					if(valY<0.0){
//						log2+=exp(valY+scale_factor);
//					}
//
//					log2=log(log2) - scale_factor;
//
//




					Log_pr = log_pr + log2;

					if ( std::isinf(Log_pr) || std::isnan(Log_pr) ){
//						Log_pr=0.0;
						printf("ERROR isinf or isnan (X)\n");
						printf("log_pr %lf ;log1 %lf\n",log_pr,log2);
						printf("scale factor %lf\n",scale_factor);
						printf("M %lf X %lf Y %lf\n",valM,valX,valY);
						printf("e1 %lf e2 %lf e3 %lf\n",e1,e2,e3);
						printf("etot %lf\n",etot);
						exit(EXIT_FAILURE);
					}

//					LogX[m_binary_this][coordTriangle_this_i][coordTriangle_this_j]=Log_pr;
					LogX[m][coordTriangle_this_i][coordTriangle_this_j]=Log_pr;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_gapy_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				coordTriangle_this_i=i;
				coordTriangle_prev_i=coordTriangle_this_i;
				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordTriangle_prev_j=coordTriangle_this_j-1;
					coordSeq_2=coordTriangle_this_j-1;
					sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

//					valM=LogM[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
//					valX=LogX[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
//					valY=LogY[m_binary_prev][coordTriangle_prev_i][coordTriangle_prev_j];
					valM=LogM[m-1][coordTriangle_prev_i][coordTriangle_prev_j];
					valX=LogX[m-1][coordTriangle_prev_i][coordTriangle_prev_j];
					valY=LogY[m-1][coordTriangle_prev_i][coordTriangle_prev_j];

//					valM = ( std::isinf(valM) || std::isnan(valM)) ? 0.0 : valM;
//					valX = ( std::isinf(valX) || std::isnan(valX)) ? 0.0 : valX;
//					valY = ( std::isinf(valY) || std::isnan(valY)) ? 0.0 : valY;

					if(local){
						log_pr=computeLK_Y_local_tree_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
					}else{
						log_pr=computeLK_Y_all_edges_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
					}

//					scale_factor = (valM > valX) ? valM : valX;
//					scale_factor = (scale_factor > valY) ? scale_factor : valY;

//					scale_factor=get_scale_factor(valM,valX,valY);

//					printf("scale fator %lf\n",scale_factor);

					if( (valM==0.0) && (valX==0.0) && (valY==0.0) ){
						log3=0.0;
						Log_pr=0.0;
					}else{

						scale_factor=get_scale_factor(valM,valX,valY);


						e1 = (valM==0.0) ? 0.0 : exp(valM+scale_factor);
						e2 = (valX==0.0) ? 0.0 : exp(valX+scale_factor);
						e3 = (valY==0.0) ? 0.0 : exp(valY+scale_factor);

						etot = e1 + e2 + e3;

						log3=log(etot) - scale_factor;

//						log3=log(exp(valM+scale_factor) + exp(valX+scale_factor) + exp(valY+scale_factor)) - scale_factor;

						if(log_pr>=0.0){
							printf("log_pr > 0: %lf\n",log_pr);
							printf("scale factor %lf\n",scale_factor);
							printf("M %lf X %lf Y %lf\n",valM,valX,valY);
							exit(1);
						}
						if(log3>=0.0){
							printf("log3 > 0: %lf\n",log3);
							printf("scale factor %lf\n",scale_factor);
							printf("M %lf X %lf Y %lf\n",valM,valX,valY);
							exit(1);
						}

					}

//					double log3=0.0;
//					if(valM<0.0){
//						log3+=exp(valM+scale_factor);
//					}
//					if(valX<0.0){
//						log3+=exp(valX+scale_factor);
//					}
//					if(valY<0.0){
//						log3+=exp(valY+scale_factor);
//					}
//
//					log3=log(log3) - scale_factor;




					Log_pr = log_pr + log3;

					if ( std::isinf(Log_pr) || std::isnan(Log_pr) ){
//						Log_pr=0.0;
						printf("ERROR isinf or isnan (Y)\n");
						printf("log_pr %lf ;log1 %lf\n",log_pr,log3);
						printf("scale factor %lf\n",scale_factor);
						printf("M %lf X %lf Y %lf\n",valM,valX,valY);
						printf("e1 %lf e2 %lf e3 %lf\n",e1,e2,e3);
						printf("etot %lf\n",etot);
						exit(EXIT_FAILURE);
					}

//					LogY[m_binary_this][coordTriangle_this_i][coordTriangle_this_j]=Log_pr;
					LogY[m][coordTriangle_this_i][coordTriangle_this_j]=Log_pr;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
	}

//	LogM[0][0][0]=nu*(pc0-1.0);

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void forward_SB_2D(	PhyTree &tree,
									double** LogM,
									double** LogX,
									double** LogY,
									int h,int w,int d,
									double nu,
									ProgressivePIPResult<ALPHABET> &result_L,
									ProgressivePIPResult<ALPHABET> &result_R,
									const ModelFactory<ALPHABET> *model_factory,
									std::map<std::string,double> &lkM,
									std::map<std::string,double> &lkX,
									std::map<std::string,double> &lkY,
									bool local){

	int up_corner_i;
	int up_corner_j;
	int bot_corner_i;
	int bot_corner_j;

	int lw;

	std::string sLs;
	std::string sRs;
	std::string col_gap_Ls;
	std::string col_gap_Rs;

	double pr,pc0;
	double valM;
	double valX;
	double valY;

	int coordSeq_1;
	int coordSeq_2;
	int coordTriangle_this_i;
	int coordTriangle_this_j;
	int coordTriangle_prev_i;
	int coordTriangle_prev_j;

	int idx;

	//*******************************************************************************************************//
	LogM[0] = new double*[1];
	LogX[0] = new double*[1];
	LogY[0] = new double*[1];

	LogM[0][0] = new double[1];
	LogX[0][0] = new double[1];
	LogY[0][0] = new double[1];
	//*******************************************************************************************************//

	col_gap_Ls=create_col_MSA_gap_s(result_L.MSAs.size());
	col_gap_Rs=create_col_MSA_gap_s(result_R.MSAs.size());

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	if(local){
		pc0=compute_pr_gap_local_tree_s<ALPHABET>(tree,
										col_gap_Ls,
										col_gap_Rs,
										pi);
	}else{
		pc0=compute_pr_gap_all_edges_s<ALPHABET>(tree,
										col_gap_Ls,
										col_gap_Rs,
										pi);
	}

	LogM[0][0]=exp(nu*(pc0-1.0));
	LogX[0][0]=exp(nu*(pc0-1.0));
	LogY[0][0]=exp(nu*(pc0-1.0));

	int m_binary_this;
	int m_binary_prev;

	for(int m=1;m<d;m++){

		m_binary_this=m%2;
		m_binary_prev=(m+1)%2;

		//***************************************************************************************
//		LogM[m] = new double*[h];
//		LogX[m] = new double*[h];
//		LogY[m] = new double*[h];
//		for(int i=0;i<h;i++){
//			LogM[m][i] = new double[w];
//			LogX[m][i] = new double[w];
//			LogY[m][i] = new double[w];
//
//			memset(LogM[m][i],0,sizeof(LogM[m][0][0])*w);
//			memset(LogX[m][i],0,sizeof(LogX[m][0][0])*w);
//			memset(LogY[m][i],0,sizeof(LogY[m][0][0])*w);
//		}
		//***************************************************************************************

		//***************************************************************************************
		//***************************************************************************************
		set_indexes_match_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;
				coordSeq_1=coordTriangle_this_i-1;
				coordTriangle_prev_i=coordTriangle_this_i-1;
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordSeq_2=coordTriangle_this_j-1;
					coordTriangle_prev_j=coordTriangle_this_j-1;
					sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=0.0;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=0.0;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=0.0;
					}

//					valM=LogM[m][coordTriangle_prev_i][coordTriangle_prev_j];
//					valX=LogX[m][coordTriangle_prev_i][coordTriangle_prev_j];
//					valY=LogY[m][coordTriangle_prev_i][coordTriangle_prev_j];

					if(local){
						pr=computeLK_M_local_tree_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
					}else{
						pr=computeLK_M_all_edges_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
					}

//					pr=1.0/(double(m)) * nu * pr + (valM + valX + valY);
					pr = pr + (valM + valX + valY);

//					LogM[m][coordTriangle_this_i][coordTriangle_this_j]=pr;

					idx=get_linear_indices_M_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					LogM[m_binary_this][idx]=pr;


				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_gapx_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){

				coordTriangle_this_i=i;
				coordTriangle_prev_i=coordTriangle_this_i-1;
				coordSeq_1=coordTriangle_this_i-1;
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);

				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordTriangle_prev_j=coordTriangle_this_j;

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=0.0;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=0.0;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=0.0;
					}

//					valM=LogM[m][coordTriangle_prev_i][coordTriangle_prev_j];
//					valX=LogX[m][coordTriangle_prev_i][coordTriangle_prev_j];
//					valY=LogY[m][coordTriangle_prev_i][coordTriangle_prev_j];

					if(local){
						pr=computeLK_X_local_tree_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
					}else{
						pr=computeLK_X_all_edges_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
					}

//					pr=1.0/(double(m)) * nu * pr + (valM + valX + valY);
					pr = pr + (valM + valX + valY);

//					LogX[m][coordTriangle_this_i][coordTriangle_this_j]=pr;

					idx=get_linear_indices_X_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					LogX[m_binary_this][idx]=pr;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
		set_indexes_gapy_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				coordTriangle_this_i=i;
				coordTriangle_prev_i=coordTriangle_this_i;
				for(int j=0;j<=lw;j++){

					coordTriangle_this_j=up_corner_j-j;
					coordTriangle_prev_j=coordTriangle_this_j-1;
					coordSeq_2=coordTriangle_this_j-1;
					sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

					idx=get_linear_indices_M_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=0.0;
					}

					idx=get_linear_indices_X_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=0.0;
					}

					idx=get_linear_indices_Y_new(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=0.0;
					}

//					valM=LogM[m][coordTriangle_prev_i][coordTriangle_prev_j];
//					valX=LogX[m][coordTriangle_prev_i][coordTriangle_prev_j];
//					valY=LogY[m][coordTriangle_prev_i][coordTriangle_prev_j];

					if(local){
						pr=computeLK_Y_local_tree_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
					}else{
						pr=computeLK_Y_all_edges_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
					}

//					pr=1.0/(double(m)) * nu * pr + (valM + valX + valY);
					pr = pr + (valM + valX + valY);

//					LogY[m][coordTriangle_this_i][coordTriangle_this_j]=pr;

					idx=get_linear_indices_Y_new(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					LogY[m_binary_this][idx]=pr;
				}
				lw++;
			}

		}
		//***************************************************************************************
		//***************************************************************************************
	}

}
//=======================================================================================================
//DP-PIP
void first_state(double number,
								double *cumsum,
								int delta,
								int wh,
								int &STATUS,
								int &depth){

	printf("\n---\n");
	int idx=0;
	for(int i=0;i<delta;i++){
		printf("%d) %lf\n",i,cumsum[idx]);
		idx++;
	}
	printf("-\n");
	for(int i=0;i<delta;i++){
		printf("%d) %lf\n",i,cumsum[idx]);
		idx++;
	}
	printf("--\n");
	for(int i=0;i<delta;i++){
		printf("%d) %lf\n",i,cumsum[idx]);
		idx++;
	}
	printf("---\n\n");

	printf("number %lf\n",number);

	number=number*cumsum[(3*delta)-1];

	printf("number %lf\n",number);

	for(int i=0;i<(3*delta);i++){
		if(number<cumsum[i]){
			idx=i;
			break;
		}
	}

	printf("idx %d\n",idx);

	if(idx < delta ){
		STATUS=(int)MATCH_STATE;
		depth = idx +wh -1;
	}else if(idx < (2*delta)){
		STATUS=(int)GAP_X_STATE;
		depth = idx - delta +wh -1;
	}else{
		STATUS=(int)GAP_Y_STATE;
		depth = idx - (2*delta) +wh -1;
	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
ProgressivePIPResult<ALPHABET> backward_SB(PhyTree &tree,
																								long double*** LogM,
																								long double*** LogX,
																								long double*** LogY,
																								int d,int h,int w,
																								ProgressivePIPResult<ALPHABET> &result_L,
																								ProgressivePIPResult<ALPHABET> &result_R,
																								const ModelFactory<ALPHABET> *model_factory,
																								double nu,
																								std::map<std::string,double> &lkM,
																								std::map<std::string,double> &lkX,
																								std::map<std::string,double> &lkY,
																								bool local,
																								std::uniform_real_distribution<double> &distribution,
																								std::default_random_engine &generator){

	double m;
	double pm,px,py;
	double Z;
	double lk;
	int STATUS;
	double log_pr;
	std::string sLs;
	std::string sRs;
	std::string col_gap_Ls;
	std::string col_gap_Rs;
	int coordSeq_1,coordSeq_2;
	int prev_i,prev_j;
	double number;
	int depth;

//	std::cout<<"node: "<<tree.getName()<<"\n";

	//----------------------------------------------------------------------------------------------------------------------------//
	std::cout<<"left: "<<std::endl;
	for(unsigned int i=0;i<result_L.MSAs.size();i++){
		std::cout<<"key:"<<result_L.MSAs.at(i).first <<" val: "<<result_L.MSAs.at(i).second;std::cout<<"\n";
	}

	std::cout<<"right: "<<std::endl;
	for(unsigned int i=0;i<result_R.MSAs.size();i++){
		std::cout<<"key:"<<result_R.MSAs.at(i).first <<" val: "<<result_R.MSAs.at(i).second;std::cout<<"\n";
	}
	//----------------------------------------------------------------------------------------------------------------------------//


	//----------------------------------------------------------------------------------------------------------------------------//
//	printf("------------------------------\n");
//		std::cout<<tree.getName()<<std::endl;
//		printf("------------------------------\n");
//		printf("M\n");
//		for(int k=0;k<d;k++){
//			for(int i=0;i<h;i++){
//				for(int j=0;j<w;j++){
//					printf("%16.14Lf ",LogM[k][i][j]);
//				}
//				printf("\n");
//			}
//			printf("\n");
//		}
//		printf("\n");
//		printf("------------------------------\n");
//		printf("X\n");
//		for(int k=0;k<d;k++){
//			for(int i=0;i<h;i++){
//				for(int j=0;j<w;j++){
//					printf("%16.14Lf ",LogX[k][i][j]);
//				}
//				printf("\n");
//			}
//			printf("\n");
//		}
//		printf("\n");
//		printf("------------------------------\n");
//		printf("Y\n");
//		for(int k=0;k<d;k++){
//			for(int i=0;i<h;i++){
//				for(int j=0;j<w;j++){
//					printf("%16.14Lf ",LogY[k][i][j]);
//				}
//				printf("\n");
//			}
//			printf("\n");
//		}
//		printf("\n");
//		printf("------------------------------\n");
		//----------------------------------------------------------------------------------------------------------------------------//




	col_gap_Ls=create_col_MSA_gap_s(result_L.MSAs.size());
	col_gap_Rs=create_col_MSA_gap_s(result_R.MSAs.size());

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	std::string traceback_path;

	//*********************************************************************//
	number = distribution(generator);
//	STATUS=index_of_max_3(	LogM[h-1][w-1],
//														LogX[h-1][w-1],
//														LogY[h-1][w-1],
//														(double)DBL_EPSILON,
//														generator,
//														distribution);
	STATUS=index_of_max_3(	LogM[d-2][h-1][w-1],
														LogX[d-1][h-1][w-1],
														LogY[d-1][h-1][w-1],
														(double)DBL_EPSILON,
														generator,
														distribution);
	//*********************************************************************//
	coordSeq_1 = h;
	coordSeq_2 = w;
	prev_i = h-1;
	prev_j = w-1;
	//*********************************************************************//
	switch (STATUS) {
		case MATCH_STATE:
			coordSeq_1--;
			coordSeq_2--;
			prev_i--;
			prev_j--;
			traceback_path.append("1");

			depth=d-2;

			break;
		case GAP_X_STATE:
			coordSeq_1--;
			prev_i--;
			traceback_path.append("2");

			depth=d-1;

			break;
		case GAP_Y_STATE:
			coordSeq_2--;
			prev_j--;
			traceback_path.append("3");

			depth=d-1;

			break;
		default:
			error("ERROR in backward\n");
			break;
	}
	//*********************************************************************//

//	printf("STATUS %d\n",STATUS);
//	printf("%d %d %d %d\n",prev_i,prev_j,coordSeq_1,coordSeq_2);

//	printf("INIZIO\n");
//	printf("this-> %d : (%d ; %d ; %d)\n",STATUS,coordSeq_1,coordSeq_2,depth);
//	printf("(i,j,k) = (%d,%d,%d) of (%d %d %d)\n",prev_i,prev_j,depth,h,w,d);

	m = 0;

//	lk=nu*(pc0-1.0);
	lk=0.0;

//	long double scale_factor = 0.0;

	bool cond=true;

	while(cond){

		m = m + 1;

		//**********************************************
		switch (STATUS) {
			case MATCH_STATE:
				//-----------------------------------------------------------------------------------------
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1-1);
				sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2-1);

				if(local){
					log_pr=computeLK_M_local_tree_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
				}else{
					log_pr=computeLK_M_all_edges_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
				}
				//-----------------------------------------------------------------------------------------
				break;
			case GAP_X_STATE:
				//-----------------------------------------------------------------------------------------
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1-1);

				if(local){
					log_pr=computeLK_X_local_tree_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
				}else{
					log_pr=computeLK_X_all_edges_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
				}
				//-----------------------------------------------------------------------------------------
				break;
			case GAP_Y_STATE:
				//-----------------------------------------------------------------------------------------
				sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2-1);

				if(local){
					log_pr=computeLK_Y_local_tree_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
				}else{
					log_pr=computeLK_Y_all_edges_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
				}
				//-----------------------------------------------------------------------------------------
				break;
			default:
				error("ERROR in backward\n");
				break;
		}
		//**********************************************

//		pm = LogM[prev_i][prev_j] ;//+ log_pr;
//		px = LogX[prev_i][prev_j];// + log_pr;
//		py = LogY[prev_i][prev_j];// + log_pr;

//		pm = LogM[depth-1][prev_i][prev_j];// + log_pr;
//		px = LogX[depth-1][prev_i][prev_j];// + log_pr;
//		py = LogY[depth-1][prev_i][prev_j];// + log_pr;

		for(int dd=depth-1;dd>=0;dd--){
				pm = LogM[dd][prev_i][prev_j];// + log_pr;
				if(pm<0.0){
					break;
				}
		}
		for(int dd=depth-1;dd>=0;dd--){
				px = LogX[dd][prev_i][prev_j];// + log_pr;
				if(px<0.0){
					break;
				}
		}
		for(int dd=depth-1;dd>=0;dd--){
				py = LogY[dd][prev_i][prev_j];// + log_pr;
				if(py<0.0){
					break;
				}
		}

//		printf("pM %lf ; pX %lf ; pY %lf\n",pm,px,py);

		//**********************************************
		Z = fabs(pm) + fabs(px) + fabs(py);
		pm = fabs(pm)/Z;
		px = fabs(px)/ Z;
		py= fabs(py)/Z;
		//**********************************************

//		printf("pm %lf ; px %lf ; py %lf\n",pm,px,py);
//		printf("this-> %d %d\n",coordSeq_1,coordSeq_2);
//		printf("(i,j,k) = (%d,%d,%d) of (%d %d %d)\n",prev_i,prev_j,depth,h,w,d);

		//**********************************************
		double Temperature = 0.1;
		pm = (pm==0.0) ? 0.0 : exp(-(1-pm)/Temperature);
		px = (px==0.0) ? 0.0 : exp(-(1-px)/Temperature);
		py = (py==0.0) ? 0.0 : exp(-(1-py)/Temperature);
		Z = pm + px + py;
		pm = pm/Z;
		px = px/ Z;
		py= py/Z;
//		printf("with Temp: pm %lf ; px %lf ; py %lf\n",pm,px,py);
		//**********************************************

		number = distribution(generator);

		if (number < pm) {
			STATUS = (int)MATCH_STATE;
			traceback_path.append("1");
			prev_i--;
			prev_j--;
			coordSeq_1--;
			coordSeq_2--;
		} else if (number < (pm + px)) {
			STATUS = (int)GAP_X_STATE;
			traceback_path.append("2");
			prev_i--;
			coordSeq_1--;
		} else {
			STATUS = (int)GAP_Y_STATE;
			traceback_path.append("3");
			prev_j--;
			coordSeq_2--;
		}
		//**********************************************

		depth--;

		//**********************************************
//		printf("pm %lf ; px %lf ; py %lf\n",pm,px,py);
//		printf("STATUS %d\n",STATUS);
//		printf("%d %d %d %d\n",prev_i,prev_j,coordSeq_1,coordSeq_2);
		//**********************************************

		lk += (log(nu) - log(m) + log_pr);

		if(prev_i==0 && prev_j==0){
			cond=false;
		}

		//**********************************************

	};

	m=m+1;

	//**********************************************
	switch (STATUS) {
		case MATCH_STATE:
			//-----------------------------------------------------------------------------------------
			sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1-1);
			sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2-1);

			if(local){
				log_pr=computeLK_M_local_tree_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
			}else{
				log_pr=computeLK_M_all_edges_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
			}
			//-----------------------------------------------------------------------------------------
			break;
		case GAP_X_STATE:
			//-----------------------------------------------------------------------------------------
			sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1-1);

			if(local){
				log_pr=computeLK_X_local_tree_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
			}else{
				log_pr=computeLK_X_all_edges_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
			}
			//-----------------------------------------------------------------------------------------
			break;
		case GAP_Y_STATE:
			//-----------------------------------------------------------------------------------------
			sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2-1);

			if(local){
				log_pr=computeLK_Y_local_tree_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
			}else{
				log_pr=computeLK_Y_all_edges_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
			}
			//-----------------------------------------------------------------------------------------
			break;
		default:
			error("ERROR in backward\n");
			break;
	}
	//**********************************************
	if (STATUS==1) {
		lk += (log(nu) - log(m) + log_pr);
	} else if (STATUS==2) {
		lk += (log(nu) - log(m) + log_pr);
	} else {
		lk += (log(nu) - log(m) + log_pr);
	}


//	printf("LAST STATUS %d pre_i %d prev_j %d\n",STATUS,prev_i,prev_j);

//	lk += LogM[0][0][0];

	//flip left-right
	traceback_path=std::string(traceback_path.rbegin(),traceback_path.rend());



//	std::cout<<"trace: "<<traceback_path<<"\n";



	ProgressivePIPResult<ALPHABET> result;

	result.traceback_path=sequenceFromStringPIP<ALPHABET>(traceback_path);
	result.score=lk;
	result.MSAs=build_MSA_PIP_s(result.traceback_path,result_L.MSAs,result_R.MSAs);

	//----------------------------------------------------------------------------------------------------------------------------//
	std::cout<<"trace: "<<traceback_path<<std::endl;
	for(unsigned int i=0;i<result.MSAs.size();i++){
		std::cout<<"key:"<<result.MSAs.at(i).first <<" val: "<<result.MSAs.at(i).second;std::cout<<"\n";
	}
//	printf("m=%lf\n",m);
//	printf("lk %18.16lf\n\n",lk);
	//----------------------------------------------------------------------------------------------------------------------------//





	return result;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
ProgressivePIPResult<ALPHABET> backward_SB_3D(PhyTree &tree,
																								double*** LogM,
																								double*** LogX,
																								double*** LogY,
																								int h,int w,int d,
																								ProgressivePIPResult<ALPHABET> &result_L,
																								ProgressivePIPResult<ALPHABET> &result_R,
																								const ModelFactory<ALPHABET> *model_factory,
																								double nu,
																								std::map<std::string,double> &lkM,
																								std::map<std::string,double> &lkX,
																								std::map<std::string,double> &lkY,
																								bool local,
																								double *cumsum,
																								int delta,
																								std::uniform_real_distribution<double> &distribution,
																								std::default_random_engine &generator){

	double m;
	double pm,px,py;
	double Z;
	double lk;
	int STATUS;
	double pr;
	std::string sLs;
	std::string sRs;
	std::string col_gap_Ls;
	std::string col_gap_Rs;
	int coordSeq_1,coordSeq_2;
	int prev_i,prev_j,depth;
	double number;

	int wh = h > w ? h : w;

	col_gap_Ls=create_col_MSA_gap_s(result_L.MSAs.size());
	col_gap_Rs=create_col_MSA_gap_s(result_R.MSAs.size());

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	//*********************************************************************//
	number = distribution(generator);
	first_state(number,cumsum,delta,wh,STATUS,depth);
	printf("STATUS %d depth %d\n",STATUS,depth);
	//*********************************************************************//

	coordSeq_1 = (h-1);
	coordSeq_2 = (w-1);

	sequence_t<ALPHABET> traceback_path(depth,ALPHABET::unknow);

	//*********************************************************************//
	switch (STATUS) {
		case MATCH_STATE:
			coordSeq_1--;
			coordSeq_2--;
			prev_i = coordSeq_1-1;
			prev_j = coordSeq_2-1;
			traceback_path[depth-1]=ALPHABET::match;
			break;
		case GAP_X_STATE:
			coordSeq_1--;
			prev_i = coordSeq_1-1;
			prev_j = coordSeq_2;
			traceback_path[depth-1]=ALPHABET::gapX;
			break;
		case GAP_Y_STATE:
			coordSeq_2--;
			prev_i = coordSeq_1;
			prev_j = coordSeq_2-1;
			traceback_path[depth-1]=ALPHABET::gapY;
			break;
		default:
			error("ERROR in backward\n");
			break;
	}
	//*********************************************************************//


	printf("h=%d w=%d d=%d\n",h,w,d);
	printf("s1(%d) ; s2(%d)\n",coordSeq_1,coordSeq_2);
	printf("c_i(%d) ; c_j(%d)\n\n",prev_i,prev_j);

	m = 0;

	for(int level=depth-1;level>0;level--){

		m = m + 1;

		printf("STATUS %d\n",STATUS);
//		printf("s1(%d) ; s2(%d)\n",coordSeq_1,coordSeq_2);
//		printf("c_i(%d) ; c_j(%d)\n\n",prev_i,prev_j);
//		//qui si puo' anche solo cercare in lkM,...
		//evitare 1/m * nu e pc0
		//**********************************************
		switch (STATUS) {
			case MATCH_STATE:
				//-----------------------------------------------------------------------------------------
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);
				sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);

				std::cout<<"s1("<<coordSeq_1<<")='"<<sLs<<"'\n";
				std::cout<<"s2("<<coordSeq_2<<")='"<<sRs<<"'\n";


				if(local){
					pr=computeLK_M_local_tree_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
				}else{
					pr=computeLK_M_all_edges_s_opt_SB<ALPHABET>(tree,sLs,sRs,pi,lkM);
				}
				//-----------------------------------------------------------------------------------------
				break;
			case GAP_X_STATE:
				//-----------------------------------------------------------------------------------------
				sLs=create_col_MSA_s<ALPHABET>(result_L.MSAs,coordSeq_1);


				std::cout<<"s1("<<coordSeq_1<<")='"<<sLs<<"'\n";
				std::cout<<"s2(.)='"<<col_gap_Rs<<"'\n";


				if(local){
					pr=computeLK_X_local_tree_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
				}else{
					pr=computeLK_X_all_edges_s_opt_SB<ALPHABET>(tree,sLs,col_gap_Rs,pi,lkX);
				}
				//-----------------------------------------------------------------------------------------
				break;
			case GAP_Y_STATE:
				//-----------------------------------------------------------------------------------------
				sRs=create_col_MSA_s<ALPHABET>(result_R.MSAs,coordSeq_2);


				std::cout<<"s1(.)='"<<col_gap_Ls<<"'\n";
				std::cout<<"s2("<<coordSeq_2<<")='"<<sRs<<"'\n";

				if(local){
					pr=computeLK_Y_local_tree_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
				}else{
					pr=computeLK_Y_all_edges_s_opt_SB<ALPHABET>(tree,col_gap_Ls,sRs,pi,lkY);
				}
				//-----------------------------------------------------------------------------------------
				break;
			default:
				error("ERROR in backward\n");
				break;
		}
		//**********************************************

		printf("----\n");

		pm = LogM[level][prev_i][prev_j] * pr;
		px = LogX[level][prev_i][prev_j] * pr;
		py = LogY[level][prev_i][prev_j] * pr;

//		com'e' ora per  nu e m??????
//		pm=pm*1/((double)m)*nu;
//		px=px*1/((double)m)*nu;
//		py=py*1/((double)m)*nu;

		//**********************************************
		Z = (pm + px + py);
		pm = pm / Z;
		px = px / Z;
		py= py / Z;
		//**********************************************

		number = distribution(generator);

		if (number < pm) {
			STATUS = (int)MATCH_STATE;
			traceback_path[level-1]=ALPHABET::match;
			prev_i--;
			prev_j--;
			coordSeq_1--;
			coordSeq_2--;
			lk=pm;
		} else if (number < (pm + px)) {
			STATUS = (int)GAP_X_STATE;
			traceback_path[level-1]=ALPHABET::gapX;
			prev_i--;
			coordSeq_1--;
			lk=px;
		} else {
			STATUS = (int)GAP_Y_STATE;
			traceback_path[level-1]=ALPHABET::gapY;
			prev_j--;
			coordSeq_2--;
			lk=py;
		}
		//**********************************************
	};


	std::cout<<"trace: "<<stringFromSequence(traceback_path)<<std::endl;



	ProgressivePIPResult<ALPHABET> result;

	result.traceback_path=traceback_path;
	result.score=lk;
	result.MSAs=build_MSA_PIP_s<ALPHABET>(traceback_path,result_L.MSAs,result_R.MSAs);

	return result;
}
//=======================================================================================================
//DP-PIP
double *z_partition(double ***LogM,double ***LogX,double ***LogY,int h,int w,int d,int &delta){

	int wh = h > w ? h : w;
	delta=d-wh+1;

	double *cumsum = new double[3*delta];

	int idx;
	cumsum[0]=LogM[wh-1][h-1][w-1];
	idx=1;
	for(int k=1;k<delta;k++){
		cumsum[idx]=cumsum[idx-1]+LogM[k+wh-1][h-1][w-1];
		idx++;
	}
	for(int k=0;k<delta;k++){
		cumsum[idx]=cumsum[idx-1]+LogX[k+wh-1][h-1][w-1];
		idx++;
	}
	for(int k=0;k<delta;k++){
		cumsum[idx]=cumsum[idx-1]+LogY[k+wh-1][h-1][w-1];
		idx++;
	}

	return cumsum;
}
//=======================================================================================================
//DP-PIP
long double** flatten3Dmatrix(long double ***mat3D,int h,int w,int d){

	long double **mat2D;

	mat2D = new long double*[h];

	for(int i=0;i<h;i++){

		mat2D[i] = new long double[w];

		for(int j=0;j<w;j++){
			mat2D[i][j]=0.0;
			for(int k=0;k<d;k++){
				mat2D[i][j]+=mat3D[k][i][j];
			}
		}
	}


	return mat2D;
}
//=======================================================================================================
//DP-PIP
double** flatten_pseudo3Dmatrix(double **mat3D,int h,int w,int d){

	double **mat2D;
	int up_corner_i,up_corner_j,bot_corner_i,bot_corner_j;
	int idx;
	int binary_m;

	mat2D = new double*[h];

	for(int i=0;i<h;i++){

		mat2D[i] = new double[w];

		for(int j=0;j<w;j++){

			mat2D[i][j]=0.0;

			for(int m=0;m<2;m++){

				set_indexes_match_new(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

				idx=get_linear_indices_M_new(i,j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);

				mat2D[i][j]+=mat3D[m][idx];

				binary_m = binary_m == 0 ? 1 :0;
			}
		}
	}


	return mat2D;
}
//=======================================================================================================
//DP-PIP
void dealloc_3D_matrix(long double ***mat,int depth,int height){

	for(int k=(depth-1); k>=0; k--){
	    for(int j=(height-1); j>=0; j--){
	        delete[] mat[k][j];
	    }
	    delete[] mat[k];
	}
	delete[] mat;

	mat=NULL;
}
//=======================================================================================================
//DP-PIP
void dealloc_2D_matrix(long double **mat,int height){

	for(int k=(height-1); k>=0; k--){
	    delete[] mat[k];
	}
	delete[] mat;

	mat=NULL;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static std::vector<ProgressivePIPResult<ALPHABET>> compute_DP_PIP_optimized_3_SB(	ProgressivePIPResult<ALPHABET> &result_L,
																																												ProgressivePIPResult<ALPHABET> &result_R,
																																												PhyTree &tree,
																																												const ModelFactory<ALPHABET> *model_factory,
																																												double tau,
																																												double nu,
																																												double gamma_rate,
																																												int num_subopt,
																																												bool local){

	int h,w,d;
	std::map<std::string,double> lkM;
	std::map<std::string,double> lkX;
	std::map<std::string,double> lkY;

	ProgressivePIPResult<ALPHABET> result;
	std::vector<ProgressivePIPResult<ALPHABET>> result_v;

	//*******************************************************************************************************//
	//@gamma_distribution
	double lambda_gamma=model_factory->lambda*gamma_rate;
	double mu_gamma=model_factory->mu*gamma_rate;
	//*******************************************************************************************************//

	//*******************************************************************************************************//
	//	@ local tree
	if(local){
		tau=tree.computeLength();
		nu=lambda_gamma*(tau+1/mu_gamma);
		tree.set_tau(tau);
		tree.set_nu(nu);
		//@gamma_distribution
		tree.set_iota_local(tau,mu_gamma);
		tree.set_beta_local(tau,mu_gamma);
	}
	//*******************************************************************************************************//



	printf("lambda %lf\n",lambda_gamma);
	printf("mu %lf\n",mu_gamma);


	tree.print_local_var();




	//*******************************************************************************************************//
	unsigned seed;
	seed = std::chrono::system_clock::now().time_since_epoch().count();
//	seed=1;
	std::default_random_engine generator(seed);
	std::uniform_real_distribution<double> distribution(0.0, 1.0);
	//*******************************************************************************************************//

	h=get_length_seq_s<ALPHABET>(result_L.MSAs)+1;
	w=get_length_seq_s<ALPHABET>(result_R.MSAs)+1;
	d=(h-1)+(w-1)+1;

	//*******************************************************************************************************//
//	long double*** LogM = new long double**[2];
//	long double*** LogX = new long double**[2];
//	long double*** LogY = new long double**[2];
	long double*** LogM = new long double**[d];
	long double*** LogX = new long double**[d];
	long double*** LogY = new long double**[d];

//	for(int k=0;k<2;k++){
	for(int k=0;k<d;k++){
		LogM[k] = new long double*[h];
		LogX[k] = new long double*[h];
		LogY[k] = new long double*[h];
		for(int i=0;i<h;i++){
			LogM[k][i] = new long double[w];
			LogX[k][i] = new long double[w];
			LogY[k][i] = new long double[w];
			memset(LogM[k][i],0,sizeof(long double)*w);
			memset(LogX[k][i],0,sizeof(long double)*w);
			memset(LogY[k][i],0,sizeof(long double)*w);
		}
	}
	//*******************************************************************************************************//
	forward_SB(tree,LogM,LogX,LogY,h,w,d,nu,result_L,result_R,model_factory,lkM,lkX,lkY,local);
	//*******************************************************************************************************//



	//*******************************************************************************************************//
//	typedef typename std::map<std::string,double>::const_iterator MapIterator;
//    for (MapIterator iter = lkM.begin(); iter != lkM.end(); iter++){
//        std::cout << "Key: " << iter->first << " " << "Values: " << iter->second << std::endl;
//
//        if(iter->second >= 0.0){
//        	exit(1);
//        }
//
//    }
//    for (MapIterator iter = lkX.begin(); iter != lkX.end(); iter++){
//        std::cout << "Key: " << iter->first << " " << "Values: " << iter->second << std::endl;
//
//        if(iter->second >= 0.0){
//        	exit(1);
//        }
//    }
//    for (MapIterator iter = lkY.begin(); iter != lkY.end(); iter++){
//        std::cout << "Key: " << iter->first << " " << "Values: " << iter->second << std::endl;
//
//        if(iter->second >= 0.0){
//        	exit(1);
//        }
//
//    }
//    exit(1);
	//*******************************************************************************************************//


//	long double** logM2D;
//	long double** logX2D;
//	long double** logY2D;
//
//	logM2D=flatten3Dmatrix(LogM,h,w,2);
//	dealloc_3D_matrix(LogM,2,h);
//	logX2D=flatten3Dmatrix(LogX,h,w,2);
//	dealloc_3D_matrix(LogX,2,h);
//	logY2D=flatten3Dmatrix(LogY,h,w,2);
//	dealloc_3D_matrix(LogY,2,h);
	//*******************************************************************************************************//
	//*******************************************************************************************************//
//	bool flag=false;
//
//	for(int i=0;i<h;i++){
//		for(int j=0;j<w;j++){
//			if ( std::isinf(logM2D[i][j]) || std::isnan(logM2D[i][j]) ){
//				flag=true;
//			}
//		}
//	}
//	for(int i=0;i<h;i++){
//		for(int j=0;j<w;j++){
//			if ( std::isinf(logX2D[i][j]) || std::isnan(logX2D[i][j]) ){
//				flag=true;
//			}
//		}
//	}
//	for(int i=0;i<h;i++){
//		for(int j=0;j<w;j++){
//			if ( std::isinf(logY2D[i][j]) || std::isnan(logY2D[i][j]) ){
//				flag=true;
//			}
//		}
//	}
//
//	if(flag){
//
//
//		printf("------------------------------\n");
//		std::cout<<tree.getName()<<std::endl;
//		printf("------------------------------\n");
//		printf("M\n");
//		for(int i=0;i<h;i++){
//			for(int j=0;j<w;j++){
//				printf("%6.4Lf ",logM2D[i][j]);
//			}
//			printf("\n");
//		}
//		printf("\n");
//		printf("------------------------------\n");
//		printf("X\n");
//		for(int i=0;i<h;i++){
//			for(int j=0;j<w;j++){
//				printf("%6.4Lf ",logX2D[i][j]);
//			}
//			printf("\n");
//		}
//		printf("\n");
//		printf("------------------------------\n");
//		printf("Y\n");
//		for(int i=0;i<h;i++){
//			for(int j=0;j<w;j++){
//				printf("%6.4Lf ",logY2D[i][j]);
//			}
//			printf("\n");
//			}
//		printf("\n");
//		printf("------------------------------\n");
//		exit(1);
//
//	}
	bool flag=false;

	for(int k=0;k<d;k++){
		for(int i=0;i<h;i++){
			for(int j=0;j<w;j++){
				if ( std::isinf(LogM[k][i][j]) || std::isnan(LogM[k][i][j]) ){
					flag=true;
				}
			}
		}
	}
	for(int k=0;k<d;k++){
		for(int i=0;i<h;i++){
			for(int j=0;j<w;j++){
				if ( std::isinf(LogX[k][i][j]) || std::isnan(LogX[k][i][j]) ){
					flag=true;
				}
			}
		}
	}
	for(int k=0;k<d;k++){
		for(int i=0;i<h;i++){
			for(int j=0;j<w;j++){
				if ( std::isinf(LogY[k][i][j]) || std::isnan(LogY[k][i][j]) ){
					flag=true;
				}
			}
		}
	}
	if(flag){
		printf("------------------------------\n");
		std::cout<<tree.getName()<<std::endl;
		printf("------------------------------\n");
		printf("M\n");
		for(int k=0;k<d;k++){
			for(int i=0;i<h;i++){
				for(int j=0;j<w;j++){
					printf("%16.14Lf ",LogM[k][i][j]);
				}
				printf("\n");
			}
			printf("\n");
		}
		printf("\n");
		printf("------------------------------\n");
		printf("X\n");
		for(int k=0;k<d;k++){
			for(int i=0;i<h;i++){
				for(int j=0;j<w;j++){
					printf("%16.14Lf ",LogX[k][i][j]);
				}
				printf("\n");
			}
			printf("\n");
		}
		printf("\n");
		printf("------------------------------\n");
		printf("Y\n");
		for(int k=0;k<d;k++){
			for(int i=0;i<h;i++){
				for(int j=0;j<w;j++){
					printf("%16.14Lf ",LogY[k][i][j]);
				}
				printf("\n");
			}
			printf("\n");
		}
		printf("\n");
		printf("------------------------------\n");

//		exit(1);

	}
	//*******************************************************************************************************//
	//*******************************************************************************************************//
	for(int k=0;k<num_subopt;k++){
		result=backward_SB(	tree,
													LogM,
													LogX,
													LogY,
													d,h,w,
													result_L,
													result_R,
													model_factory,
													nu,
													lkM,lkX,lkY,
													local,
													distribution,
													generator);
		result_v.push_back(result);
	}
	//*******************************************************************************************************//
	//*******************************************************************************************************//
//	dealloc_2D_matrix(logM2D,h);
//	dealloc_2D_matrix(logX2D,h);
//	dealloc_2D_matrix(logY2D,h);
	dealloc_3D_matrix(LogM,d,h);
	dealloc_3D_matrix(LogX,d,h);
	dealloc_3D_matrix(LogY,d,h);
	//*******************************************************************************************************//
	//*******************************************************************************************************//

	return result_v;
}
//=======================================================================================================
//DP-PIP
/*
template <class ALPHABET>
static ProgressivePIPResult<ALPHABET> compute_DP_PIP_optimized(ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,Eigen::MatrixXd &matFv,std::ostream& fileTr){


//	std::cout<<"Inizio\n";


	int up_corner_i;
	int up_corner_j;
	int bot_corner_i;
	int bot_corner_j;
	int lw,lh;

	ProgressivePIPResult<ALPHABET> result;

	int h=get_length_seq(result_L.MSA)+1;
	int w=get_length_seq(result_R.MSA)+1;

	int d=(h-1)+(w-1)+1;

	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	Eigen::MatrixXd PX(h,w);
//	Eigen::MatrixXd PY(h,w);
//	Eigen::MatrixXd PM(h,w);

	Eigen::MatrixXd PX=Eigen::MatrixXd::Zero(h,w);
	Eigen::MatrixXd PY=Eigen::MatrixXd::Zero(h,w);
	Eigen::MatrixXd PM=Eigen::MatrixXd::Zero(h,w);
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	double pc0;
	double fv0;

	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	sequence_t<ALPHABET> sL;
	sequence_t<ALPHABET> sR;
	sequence_t<ALPHABET> col_gap_L;
	sequence_t<ALPHABET> col_gap_R;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	col_gap_L=create_col_MSA_gap(result_L.MSA);
	col_gap_R=create_col_MSA_gap(result_R.MSA);

	std::map<std::string,Eigen::VectorXd> temp_fv_map;

	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	double lk_gap;
	double pc0_subtree;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	std::cout<<"random generator ON\n";
	unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
	std::default_random_engine generator(seed);
//	std::default_random_engine generator(1);
	std::uniform_real_distribution<double> distribution(0.0,1.0);
	//.-----.------.------.//
//	std::cout<<"random generator OFF\n";
//	unsigned seed = 0;
//	std::default_random_engine generator(seed);
//	std::uniform_real_distribution<double> distribution(0.0,1.0);
//	double random_number;
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	double epsilon=DBL_EPSILON;

	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	if(!tree[0].isLeaf()){
		if(result_L.Pc.size()!=(h-1)){
			error("DIMENSION wrong\n");
		}
	}
	if(!tree[1].isLeaf()){
		if(result_R.Pc.size()!=(w-1)){
			error("DIMENSION wrong\n");
		}
	}






	//====================================================================
	int num_leaves;
	num_leaves=tree.countLeaves();

	int sizeFv=int(std::pow(double(ALPHABET::DIM+1),double(num_leaves)));

	if(sizeFv>500000 || sizeFv<0){
		sizeFv=500000;
	}

	//std::cout<<"sizeFv: "<<sizeFv<<"\n";

	double **fv_array=new double *[sizeFv];

	for(int k=0;k<sizeFv;k++){
		fv_array[k]=new double [ALPHABET::DIM+1];

		fv_array[k][0]=0.001;
		fv_array[k][1]=0.001;
		fv_array[k][2]=0.001;
		fv_array[k][3]=0.001;
		fv_array[k][4]=0.000;
	}
	//====================================================================









	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	fv0=compute_fv_new_fast(fv_array,tree,col_gap_L,col_gap_R,matFv,pi);

	lk_gap=result_L.lk_gap+result_R.lk_gap;
	pc0_subtree=result_L.pc0+result_R.pc0;

	result.lk_gap=0.0;//lk_gap+tree.get_iota()*tree.get_beta()*fv0;

	pc0=compute_Pe_new(tree,fv0,pc0_subtree);

	result.pc0=pc0;

	double** LogM = new double*[2];
	double** LogX = new double*[2];
	double** LogY = new double*[2];
	int** TR = new int*[d];

	LogM[0] = new double[int((w*(h+1))/2)];
	LogX[0] = new double[int((w*(h+1))/2)];
	LogY[0] = new double[int((w*(h+1))/2)];
	LogM[1] = new double[int((w*(h+1))/2)];
	LogX[1] = new double[int((w*(h+1))/2)];
	LogY[1] = new double[int((w*(h+1))/2)];

	LogM[0][0]=nu*(pc0-1.0);
	LogX[0][0]=nu*(pc0-1.0);
	LogY[0][0]=nu*(pc0-1.0);

	TR[0] = new int[1]();
	TR[0][0]=STOP_STATE;




	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	typedef typename std::set< std::pair<int,int> > ::const_iterator it_pair;

	double max_of_3;
	double max_lk=-INFINITY;
	int level_max_lk=-INFINITY;
	double val;
	int m_binary_this;
	int m_binary_prev;

	int size_m;
	int size_x;
	int size_y;

	double valM;
	double valX;
	double valY;

	int idx;
	int idxX,idxY;

	int coordSeq_1;
	int coordSeq_2;
	int coordTriangle_this_i;
	int coordTriangle_this_j;
	int coordTriangle_prev_i;
	int coordTriangle_prev_j;


	int counter=0;
	int max_counter=10;
	bool flag_exit=false;
	int last_d=d-1;

	for(int m=1;m<d;m++){

//		std::cout<<"m="<<m<<"\n";

		if(flag_exit){
			break;
		}

		m_binary_this=m%2;
		m_binary_prev=(m+1)%2;

		TR[m] = new int[h*w](); //TODO: optimize size TR
		memset(TR[m],0,h*w);



		set_indexes_match(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

//		std::cout<<"MATCH\n";

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				for(int j=0;j<=lw;j++){

					coordTriangle_this_i=i;
					coordTriangle_this_j=up_corner_j-j;

					coordSeq_1=coordTriangle_this_i-1;
					coordSeq_2=coordTriangle_this_j-1;

					coordTriangle_prev_i=coordTriangle_this_i-1;
					coordTriangle_prev_j=coordTriangle_this_j-1;

					sL=create_col_MSA(result_L.MSA,coordSeq_1);
					sR=create_col_MSA(result_R.MSA,coordSeq_2);

					//sub2ind(coordTriangle_prev_i,coordTriangle_prev_j,idx,h,w);

					idx=get_prev_linear_indices_M(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_prev_linear_indices_X(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_prev_linear_indices_Y(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}

					val=computeLK_Mopt(fv_array,valM,
									valX,
									valY,
									coordSeq_1,coordSeq_2,
									nu,
									tree,
									sL,sR,
									pi,
									lk_gap,
									PM,
									m,
									matFv);

//					if(std::isnan(val)){
//						std::cout<<"\nnan Match\n";
//						std::cout<<h<<" ; "<<w<<"\n";
//						std::cout<<up_corner_i<<" , "<<up_corner_j<<" , "<<bot_corner_i<<" , "<<bot_corner_j<<"\n";
//						std::cout<<m<<" : "<<coordTriangle_this_i<<" : "<<coordTriangle_this_j<<"\n";
//						std::cout<<valM<<" ; "<<valX<<" ; "<<valY<<"\n";
////						exit(EXIT_FAILURE);
//					}
//					if(std::isinf(val)){
//						std::cout<<"\n\ninf Match\n";
//						std::cout<<h<<" ; "<<w<<"\n";
//						std::cout<<up_corner_i<<" , "<<up_corner_j<<" , "<<bot_corner_i<<" , "<<bot_corner_j<<"\n";
//						std::cout<<m<<" : "<<coordTriangle_this_i<<" : "<<coordTriangle_this_j<<"\n";
//						std::cout<<valM<<" ; "<<valX<<" ; "<<valY<<"\n";
////						exit(EXIT_FAILURE);
//					}

					//sub2ind(first,second,idx,h,w);

					idx=get_this_linear_indices_M(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogM[m_binary_this][idx]=val;

				}
				lw++;
			}

		}


		set_indexes_gapx(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				for(int j=0;j<=lw;j++){

					coordTriangle_this_i=i;
					coordTriangle_this_j=up_corner_j-j;

					coordSeq_1=coordTriangle_this_i-1;
					//coordSeq_2=coordTriangle_this_j-1;
					coordSeq_2=coordTriangle_this_j; //??????????????

					coordTriangle_prev_i=coordTriangle_this_i-1;
					coordTriangle_prev_j=coordTriangle_this_j;

					sL=create_col_MSA(result_L.MSA,coordSeq_1);

					//sub2ind(first-1,second,idx,h,w);

					idx=get_prev_linear_indices_M(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_prev_linear_indices_X(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_prev_linear_indices_Y(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}

					val=computeLK_Xopt(fv_array,valM,
									valX,
									valY,
									coordSeq_1,coordSeq_2,
									nu,
									result_L,tree,
									sL,col_gap_R,
									pi,
									lk_gap,
									PX,
									m,
									matFv);

					//sub2ind(first,second,idx,h,w);
//					if(std::isnan(val)){
//						std::cout<<"\nnan GapX\n";
//						std::cout<<h<<" ; "<<w<<"\n";
//						std::cout<<up_corner_i<<" , "<<up_corner_j<<" , "<<bot_corner_i<<" , "<<bot_corner_j<<"\n";
//						std::cout<<m<<" : "<<coordTriangle_this_i<<" : "<<coordTriangle_this_j<<"\n";
//						std::cout<<valM<<" ; "<<valX<<" ; "<<valY<<"\n";
////						exit(EXIT_FAILURE);
//					}
//					if(std::isinf(val)){
//						std::cout<<"\n\ninf GapX\n";
//						std::cout<<h<<" ; "<<w<<"\n";
//						std::cout<<up_corner_i<<" , "<<up_corner_j<<" , "<<bot_corner_i<<" , "<<bot_corner_j<<"\n";
//						std::cout<<m<<" : "<<coordTriangle_this_i<<" : "<<coordTriangle_this_j<<"\n";
//						std::cout<<valM<<" ; "<<valX<<" ; "<<valY<<"\n";
////						exit(EXIT_FAILURE);
//					}

					idx=get_this_linear_indices_X(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogX[m_binary_this][idx]=val;

				}
				lw++;
			}

		}


		set_indexes_gapy(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				for(int j=0;j<=lw;j++){

					coordTriangle_this_i=i;
					coordTriangle_this_j=up_corner_j-j;

					//coordSeq_1=coordTriangle_this_i-1;
					coordSeq_1=coordTriangle_this_i; //??????????????????????????
					coordSeq_2=coordTriangle_this_j-1;

					coordTriangle_prev_i=coordTriangle_this_i;
					coordTriangle_prev_j=coordTriangle_this_j-1;

					sR=create_col_MSA(result_R.MSA,coordSeq_2);

					//sub2ind(first,second-1,idx,h,w);

					idx=get_prev_linear_indices_M(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valM=LogM[m_binary_prev][idx];
					}else{
						valM=-INFINITY;
					}

					idx=get_prev_linear_indices_X(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valX=LogX[m_binary_prev][idx];
					}else{
						valX=-INFINITY;
					}

					idx=get_prev_linear_indices_Y(coordTriangle_prev_i,coordTriangle_prev_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m-1,h,w);
					if(idx>=0){
						valY=LogY[m_binary_prev][idx];
					}else{
						valY=-INFINITY;
					}

					val=computeLK_Yopt(fv_array,valM,
									valX,
									valY,
									coordSeq_1,coordSeq_2,
									nu,
									result_R,tree,
									col_gap_L,sR,
									pi,
									lk_gap,
									PY,
									m,
									matFv);

					//sub2ind(first,second,idx,h,w);
//					if(std::isnan(val)){
//						std::cout<<"\nnan GapY\n";
//						std::cout<<h<<" ; "<<w<<"\n";
//						std::cout<<up_corner_i<<" , "<<up_corner_j<<" , "<<bot_corner_i<<" , "<<bot_corner_j<<"\n";
//						std::cout<<m<<" : "<<coordTriangle_this_i<<" : "<<coordTriangle_this_j<<"\n";
//						std::cout<<valM<<" ; "<<valX<<" ; "<<valY<<"\n";
////						exit(EXIT_FAILURE);
//					}
//					if(std::isinf(val)){
//						std::cout<<"\n\ninf GapY\n";
//						std::cout<<h<<" ; "<<w<<"\n";
//						std::cout<<up_corner_i<<" , "<<up_corner_j<<" , "<<bot_corner_i<<" , "<<bot_corner_j<<"\n";
//						std::cout<<m<<" : "<<coordTriangle_this_i<<" : "<<coordTriangle_this_j<<"\n";
//						std::cout<<valM<<" ; "<<valX<<" ; "<<valY<<"\n";
////						exit(EXIT_FAILURE);
//					}

					idx=get_this_linear_indices_Y(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					LogY[m_binary_this][idx]=val;

				}
				lw++;
			}

		}


		set_indexes_tr(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);

		if(checkboundary(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w)){

			lw=0;
			for(int i=up_corner_i;i<=bot_corner_i;i++){
				for(int j=0;j<=lw;j++){

					coordTriangle_this_i=i;
					coordTriangle_this_j=up_corner_j-j;

					//sub2ind(first,second,idx,h,w);

					double mval;
					double xval;
					double yval;

					idx=get_this_linear_indices_M(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						mval=LogM[m_binary_this][idx];
					}else{
						mval=-INFINITY;
					}

					idx=get_this_linear_indices_X(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						xval=LogX[m_binary_this][idx];
					}else{
						xval=-INFINITY;
					}

					idx=get_this_linear_indices_Y(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);
					if(idx>=0){
						yval=LogY[m_binary_this][idx];
					}else{
						yval=-INFINITY;
					}

					mval=fabs(mval)<epsilon?-INFINITY:mval;
					xval=fabs(xval)<epsilon?-INFINITY:xval;
					yval=fabs(yval)<epsilon?-INFINITY:yval;

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
					//(*TR[m]).coeffRef(first,second)=index_of_max_3(mval,xval,yval,epsilon,generator,distribution);
					//sub2ind(first,second,idx,h,w);

					int ttrr;

					ttrr=index_of_max_3(mval,xval,yval,epsilon,generator,distribution);

					idx=linear_indices_TR(coordTriangle_this_i,coordTriangle_this_j,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,m,h,w);

					if(TR[m][idx]!=0){
						std::cout<<"already assigned!!!\n";
						exit(EXIT_FAILURE);
					}

					TR[m][idx]=ttrr;

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
					if( (coordTriangle_this_i==(h-1)) & (coordTriangle_this_j==(w-1)) ){

						max_of_3=max_of_three_2(mval,xval,yval,epsilon);

//						if(max_of_3>max_lk){
//							max_lk=max_of_3;
//							level_max_lk=m;
//						}

						if(max_of_3>max_lk){
							max_lk=max_of_3;
							level_max_lk=m;
						}else{
							counter++;
							if(counter>max_counter){
								flag_exit=true;
								last_d=m;
								break;
							}
						}


					}
					//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

				}
				lw++;
			}

		}
	}

	result.score=max_lk;

	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
	sequence_t<ALPHABET> traceback_path(level_max_lk,ALPHABET::unknow);

	int id1=h-1;
	int id2=w-1;

	for(int lev=level_max_lk;lev>0;lev--){
		set_indexes_tr(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,lev,h,w);
		reset_corner(up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,h,w);
		idx=linear_indices_TR(id1,id2,up_corner_i,up_corner_j,bot_corner_i,bot_corner_j,lev,h,w);

		switch(TR[lev][idx]){
	        case MATCH_STATE:
	            id1=id1-1;
	            id2=id2-1;
	            traceback_path[lev-1]=ALPHABET::match;
	            break;
	        case GAP_X_STATE:
	            id1=id1-1;
	            traceback_path[lev-1]=ALPHABET::gapX;
	            break;
	        case GAP_Y_STATE:
	            id2=id2-1;
	            traceback_path[lev-1]=ALPHABET::gapY;
	            break;
	        default:
	        	error("ERROR in alignment_reconstruction !!!");
	            exit(EXIT_FAILURE);
	    }
	}
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	result.traceback_path=traceback_path;



//	std::cout<<"PM:\n";
//	for(int i=0;i<PM.rows();i++){
//		for(int j=0;j<PM.cols();j++){
//			std::cout<<PM(i,j)<<" ";
//		}
//		std::cout<<"\n";
//	}
//	std::cout<<"\n";
//	std::cout<<"PX:\n";
//	for(int i=0;i<PX.rows();i++){
//		for(int j=0;j<PX.cols();j++){
//			std::cout<<PX(i,j)<<" ";
//		}
//		std::cout<<"\n";
//	}
//	std::cout<<"\n";
//	std::cout<<"PY:\n";
//	for(int i=0;i<PY.rows();i++){
//		for(int j=0;j<PY.cols();j++){
//			std::cout<<PY(i,j)<<" ";
//		}
//		std::cout<<"\n";
//	}
//	std::cout<<"\n";
//
//	std::cout<<"tracepath:\n";
//	std::cout<<stringFromSequence<ALPHABET>(traceback_path)<<"\n";
//	std::cout<<"\n";


	fill_Pc_new3(result,traceback_path,PM,PX,PY);

//	std::cout<<"PCarray\n";
//	for(int k=0;k<result.Pc.size();k++){
//		std::cout<<result.Pc(k)<<" ";
//	}
//	std::cout<<"\n";



	result.MSA=build_MSA_PIP<ALPHABET>(traceback_path,result_L.MSA,result_R.MSA,fileTr);

	//update_fv_map(result,temp_fv_map,result.MSA);


//	std::cout<<"dealloco\n";


	free(LogM[1]);
	free(LogM[0]);
	free(LogM);

	free(LogX[1]);
	free(LogX[0]);
	free(LogX);

	free(LogY[1]);
	free(LogY[0]);
	free(LogY);

	for(int i=last_d;i>=0;i--){
		free(TR[i]);
	}
	free(TR);



	dealloc2Ddouble(fv_array,sizeFv);
	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//

	return result;
}
*/
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//static ProgressivePIPResult<ALPHABET> compute_DP_PIP_TMP(ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,std::ostream& fileTr){
//
//	ProgressivePIPResult<ALPHABET> result;
//
//	int h=get_length_seq(result_L.MSA)+1;
//	int w=get_length_seq(result_R.MSA)+1;
//	int d=(h-1)+(w-1)+1; //len_seq_1 + len_seq_2 + 1 (level 0 contains nu)
//
//	//-------------------------------
//	PrintVector(result_L.MSA);
//	PrintVector(result_R.MSA);
////	std::cout<<h<<" "<<w<<" "<<d<<"\n";
//	//-------------------------------
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//Eigen::MatrixXd log_SM(h,w);
//	//Eigen::MatrixXd log_SX(h,w);
//	//Eigen::MatrixXd log_SY(h,w);
//	//Eigen::MatrixXi M(h,w);
//
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogM = initialize_MatrixSparse3D(h,w,d);
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogX = initialize_MatrixSparse3D(h,w,d);
//	Eigen::SparseMatrix<double,Eigen::RowMajor>** LogY = initialize_MatrixSparse3D(h,w,d);
//
//	Eigen::SparseMatrix<int,Eigen::RowMajor>** TR = initialize_MatrixSparse3D_int(h,w,d);
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
////	Eigen::MatrixXi TR(h,w);
//
//	Eigen::MatrixXd PX(h,w);
//	Eigen::MatrixXd PY(h,w);
//
//	//:*:*:*:*:*:*:*:*:*:*:*:*
//	Eigen::MatrixXd PM(h,w);
//	//:*:*:*:*:*:*:*:*:*:*:*:*
//
//	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();
//
////	int i,j;
////	double Pa,Pb,Pab;
//	double pc0;
////	double pc;
//	double fv0;
//
//	sequence_t<ALPHABET> sL, sR;
//	sequence_t<ALPHABET> col_gap_L, col_gap_R;
//
//	col_gap_L=create_col_MSA_gap(result_L.MSA);
//	col_gap_R=create_col_MSA_gap(result_R.MSA);
//
//	//-------------------------------
////	std::cout<<"gapL"<<stringFromSequence<ALPHABET>(col_gap_L)<<"\n";
////	std::cout<<"gapR"<<stringFromSequence<ALPHABET>(col_gap_R)<<"\n";
//	//-------------------------------
//
//	std::map<std::string,Eigen::VectorXd> temp_fv_map;
//
//	//:*:*:*:*:*:*:*:*:*:*:*:*
//	double lk_gap;
//	double pc0_subtree;
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
////	std::cout<<"random generator ON\n";
////	unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
////	std::default_random_engine generator(seed);
////	std::uniform_real_distribution<double> distribution(0.0,1.0);
////	double random_number;
////	double epsilon=DBL_EPSILON;
//	//.-----.------.------.//
//	std::cout<<"random generator OFF\n";
////	unsigned seed = 0;
////	std::default_random_engine generator(seed);
////	std::uniform_real_distribution<double> distribution(0.0,1.0);
////	double random_number;
//	double epsilon=DBL_EPSILON;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	if(!tree[0].isLeaf()){
//		if(result_L.Pc.size()!=(h-1)){
//			error("DIMENSION wrong\n");
//		}
//	}
//	if(!tree[1].isLeaf()){
//		if(result_R.Pc.size()!=(w-1)){
//			error("DIMENSION wrong\n");
//		}
//	}
//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	std::vector< std::pair<int,int> > list_m_1;
//	std::vector< std::pair<int,int> > list_m_2;
//	std::vector< std::pair<int,int> > list_x_1;
//	std::vector< std::pair<int,int> > list_x_2;
//	std::vector< std::pair<int,int> > list_y_1;
//	std::vector< std::pair<int,int> > list_y_2;
//
//	std::vector< std::pair<int,int> > list_tr;
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	fv0=compute_fv_new(tree,result_L.fv_map,result_R.fv_map,temp_fv_map,col_gap_L,col_gap_R,pi);
//
//	//-------------------------------
////	std::cout<<fv0<<"\n";
//	//-------------------------------
//
//	//:*:*:*:*:*:*:*:*:*:*:*:*
//	lk_gap=result_L.lk_gap+result_R.lk_gap;
//	pc0_subtree=result_L.pc0+result_R.pc0;
//
//	result.lk_gap=0.0;//lk_gap+tree.get_iota()*tree.get_beta()*fv0;
//
//	pc0=compute_Pe_new(tree,fv0,pc0_subtree);
//
//	//:*:*:*:*:*:*:*:*:*:*:*:*
//	result.pc0=pc0;
//
//	//:*:*:*:*:*:*:*:*:*:*:*:*
////	PM(i,j)=0.0;
////	PX(i,j)=0.0;
////	PY(i,j)=0.0;
//	//:*:*:*:*:*:*:*:*:*:*:*:*
//
//	//TR(0,0)=MATCH_STATE;
//
//	//M(0,0)=0;
//	(*LogM[0]).coeffRef(0,0)=nu*(pc0-1.0);
//	(*LogX[0]).coeffRef(0,0)=nu*(pc0-1.0);
//	(*LogY[0]).coeffRef(0,0)=nu*(pc0-1.0);
//
//
//	(*TR[0]).coeffRef(0,0)=STOP_STATE;
//
//
//	list_m_1.push_back(std::pair<int,int>(0,0));
//	list_x_1.push_back(std::pair<int,int>(0,0));
//	list_y_1.push_back(std::pair<int,int>(0,0));
//
////	next_nonzero_elements(&list_m_1,&list_x_1,&list_y_1,&list_m_2,&list_x_2,&list_y_2,h,w);
////
////	std::sort(list_m_2.begin(),list_m_2.end());
////	std::sort(list_x_2.begin(),list_x_2.end());
////	std::sort(list_y_2.begin(),list_y_2.end());
////
////	list_m_2.erase(std::unique(list_m_2.begin(),list_m_2.end()),list_m_2.end());
////	list_x_2.erase(std::unique(list_x_2.begin(),list_x_2.end()),list_x_2.end());
////	list_y_2.erase(std::unique(list_y_2.begin(),list_y_2.end()),list_y_2.end());
////
////	std::swap(list_m_1,list_m_2);
////	std::swap(list_x_1,list_x_2);
////	std::swap(list_y_1,list_y_2);
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	// creare sL e sR da utilizzare dopo
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//	typedef typename std::vector<std::pair<int,int> > ::const_iterator it_pair;
//
//
//	double max_of_3;
//	double max_lk=-INFINITY;
//	int level_max_lk;
//	double val;
//	for(int m=1;m<d;m++){
//
//		next_nonzero_elements(&list_m_1,&list_x_1,&list_y_1,&list_m_2,&list_x_2,&list_y_2,h,w);
//
//		std::sort(list_m_2.begin(),list_m_2.end());
//		std::sort(list_x_2.begin(),list_x_2.end());
//		std::sort(list_y_2.begin(),list_y_2.end());
//
//		list_m_2.erase(std::unique(list_m_2.begin(),list_m_2.end()),list_m_2.end());
//		list_x_2.erase(std::unique(list_x_2.begin(),list_x_2.end()),list_x_2.end());
//		list_y_2.erase(std::unique(list_y_2.begin(),list_y_2.end()),list_y_2.end());
//
//		std::swap(list_m_1,list_m_2);
//		std::swap(list_x_1,list_x_2);
//		std::swap(list_y_1,list_y_2);
//
//		list_tr.clear();
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_m_1.begin();it!=list_m_1.end();it++){
//			sL=create_col_MSA(result_L.MSA,it->first-1);
//			sR=create_col_MSA(result_R.MSA,it->second-1);
//
//			//-----------------------------------------------------------
////			std::cout<<"M"<<"("<<m<<")"<<"\n";
////			std::cout<<"it->first: "<<it->first<<"\n";
////			std::cout<<"it->second: "<<it->second<<"\n";
////			std::cout<<"seq: "<<stringFromSequence<ALPHABET>(sL)<<"\n";
////			std::cout<<"seq: "<<stringFromSequence<ALPHABET>(sR)<<"\n\n";
//			//-----------------------------------------------------------
//
//			val=computeLK_M(LogM[m-1],
//							LogX[m-1],
//							LogY[m-1],
//							it->first,it->second,
//							nu,
//							result_L,result_R,tree,
//							sL,sR,
//							pi,
//							temp_fv_map,
//							lk_gap,
//							PM,
//							m);
//
//			(*LogM[m]).coeffRef(it->first,it->second)=val;
//
//			list_tr.push_back(std::pair<int,int>(it->first,it->second));
//
//		}
//
//
//
//
//
//
//
//		//-----------------------------------------------------------
//		std::cout<<"M:\n";
//		std::cout<<"level: "<<m<<"\n";
//		for(int j=0;j<h;j++){
//			for(int k=0;k<w;k++){
//				printf("%+10.7f  ",LogM[m]->coeff(j,k));
//			}
//			std::cout<<"\n";
//		}
//		std::cout<<"\n";std::cout<<"\n";
//		//-----------------------------------------------------------
//
//
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_x_1.begin();it!=list_x_1.end();it++){
//			sL=create_col_MSA(result_L.MSA,it->first-1);
//
//			//-----------------------------------------------------------
////			std::cout<<"X"<<"("<<m<<")"<<"\n";
////			std::cout<<"it->first: "<<it->first<<"\n";
////			std::cout<<"it->second: "<<it->second<<"\n";
////			std::cout<<"seq: "<<stringFromSequence<ALPHABET>(sL)<<"\n\n";
//			//-----------------------------------------------------------
//
//			val=computeLK_X(LogM[m-1],
//							LogX[m-1],
//							LogY[m-1],
//							it->first,it->second,
//							nu,
//							result_L,result_R,tree,
//							sL,col_gap_R,
//							pi,
//							temp_fv_map,
//							lk_gap,
//							PX,
//							m);
//
//			(*LogX[m]).coeffRef(it->first,it->second)=val;
//
//			list_tr.push_back(std::pair<int,int>(it->first,it->second));
//
//		}
//
//
//
//
//		//-----------------------------------------------------------
//		std::cout<<"X:\n";
//		std::cout<<"level: "<<m<<"\n";
//		for(int j=0;j<h;j++){
//			for(int k=0;k<w;k++){
//				printf("%+10.7f  ",LogX[m]->coeff(j,k));
//			}
//			std::cout<<"\n";
//		}
//		std::cout<<"\n";std::cout<<"\n";
//		//-----------------------------------------------------------
//
//
//
//
//
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		for(it_pair it=list_y_1.begin();it!=list_y_1.end();it++){
//			sR=create_col_MSA(result_R.MSA,it->second-1);
//
//			//-----------------------------------------------------------
////			std::cout<<"Y"<<"("<<m<<")"<<"\n";
////			std::cout<<"it->first: "<<it->first<<"\n";
////			std::cout<<"it->second: "<<it->second<<"\n";
////			std::cout<<"seq: "<<stringFromSequence<ALPHABET>(sR)<<"\n\n";
//			//-----------------------------------------------------------
//
//			val=computeLK_Y(LogM[m-1],
//							LogX[m-1],
//							LogY[m-1],
//							it->first,it->second,
//							nu,
//							result_L,result_R,tree,
//							col_gap_L,sR,
//							pi,
//							temp_fv_map,
//							lk_gap,
//							PY,
//							m);
//
//			(*LogY[m]).coeffRef(it->first,it->second)=val;
//
//			list_tr.push_back(std::pair<int,int>(it->first,it->second));
//		}
//
//
//
//
//
//
//
//
//
//
//		//-----------------------------------------------------------
//		std::cout<<"Y:\n";
//		std::cout<<"level: "<<m<<"\n";
//		for(int j=0;j<h;j++){
//			for(int k=0;k<w;k++){
//				printf("%+10.7f  ",LogY[m]->coeff(j,k));
//			}
//			std::cout<<"\n";
//		}
//		std::cout<<"\n";std::cout<<"\n";
//		//-----------------------------------------------------------
//
//
//
//
//
//
//
//
//		//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//		std::sort(list_tr.begin(),list_tr.end());
//
//		list_tr.erase(std::unique(list_tr.begin(),list_tr.end()),list_tr.end());
//
//		for(it_pair it=list_tr.begin();it!=list_tr.end();it++){
//
//			if(TR[m]->coeff(it->first,it->second)!=0){
//				std::cout<<"already assigned!!!\n";
//				exit(EXIT_FAILURE);
//			}
//
//			double mval=(double)LogM[m]->coeff(it->first,it->second)==0?-INFINITY:(double)LogM[m]->coeff(it->first,it->second);
//			double xval=(double)LogX[m]->coeff(it->first,it->second)==0?-INFINITY:(double)LogX[m]->coeff(it->first,it->second);
//			double yval=(double)LogY[m]->coeff(it->first,it->second)==0?-INFINITY:(double)LogY[m]->coeff(it->first,it->second);
//
//			/*
//			random_number = distribution(generator);
//			(*TR[m]).coeffRef(it->first,it->second)=index_of_max_2((double)LogM[m]->coeff(it->first,it->second),(double)LogX[m]->coeff(it->first,it->second),(double)LogY[m]->coeff(it->first,it->second),epsilon,random_number);
//			*/
//
//			(*TR[m]).coeffRef(it->first,it->second)=index_of_max(mval,xval,yval);
//
//
//
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//			if( (it->first==(h-1)) & (it->second==(w-1)) ){
//
//				max_of_3=max_of_three_2(mval,xval,yval,epsilon);
//
//				if(max_of_3>max_lk){
//					max_lk=max_of_3;
//					level_max_lk=m;
//				}
//
//			}
//			//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//		}
//
//	}
//
//
//
//
////	result.score=max_of_three((double)log_SM(h-1,w-1),(double)log_SX(h-1,w-1),(double)log_SY(h-1,w-1));
//
////	int len_MSA=M(h-1,w-1);
//
////	fill_Pc_new2(result,TR,PM,PX,PY,len_MSA);
//
////	sequence_t<ALPHABET> traceback_path=alignment_reconstruction<ALPHABET>(TR,len_MSA);
////
////	result.traceback_path=traceback_path;
////	result.MSA=build_MSA_PIP<ALPHABET>(traceback_path,result_L.MSA,result_R.MSA,fileTr);
////
////	update_fv_map(result,temp_fv_map,result.MSA);
//
//
//
//
//
//
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//	for(int i=0;i<d;i++){
//		for(int j=0;j<h;j++){
//			for(int k=0;k<w;k++){
//				std::cout<<TR[i]->coeff(j,k)<<"  ";
//			}
//			std::cout<<"\n";
//		}
//		std::cout<<"\n";
//	}
//	std::cout<<"\n";
//	std::cout<<"\n";
//	//.-----.------.------.-------.------.-------.-------.--------.-------.--------.//
//
//
//
//
//
//
////	std::cout<<h<<" "<<w<<" "<<std::max(h,w)<<"\n";
//
//	//---------------------------------------
////	for(int m=d-1;m>=0;m--){
////		std::cout<<"lev="<<m<<":"<<TR[m]->coeff(h-1,w-1)<<"\n";
////	}
//	//---------------------------------------
//
//
//
//
////	double max_lk=-INFINITY;
////	int level;
//////	int matr;
////	std::vector< std::pair<int,int> > list_tr_1;
////	for(int m=d-1;m>=std::max(h,w);m--){
////		if(TR[m]->coeff(h-1,w-1)>0){
////
////			list_tr_1.push_back(std::pair<int,int>(m,TR[m]->coeff(h-1,w-1)));
////
//////			std::cout<<LogM[m]->coeff(h-1,w-1)<<";"<<LogX[m]->coeff(h-1,w-1)<<";"<<LogY[m]->coeff(h-1,w-1)<<"\n";
////
////			if( (LogM[m]->coeff(h-1,w-1)<0.0) & (LogM[m]->coeff(h-1,w-1)>max_lk) ){
////				max_lk=LogM[m]->coeff(h-1,w-1);
////				level=m;
//////				matr=int(MATCH_STATE);
////
//////				std::cout<<"M: level: "<<m<<":"<<max_lk<<"\n";
////
////			}
////			if( (LogX[m]->coeff(h-1,w-1)<0.0) & (LogX[m]->coeff(h-1,w-1)>max_lk) ){
////				max_lk=LogX[m]->coeff(h-1,w-1);
////				level=m;
//////				matr=int(GAP_X_STATE);
////
//////				std::cout<<"X: level: "<<m<<":"<<max_lk<<"\n";
////			}
////			if( (LogY[m]->coeff(h-1,w-1)<0.0) & (LogY[m]->coeff(h-1,w-1)>max_lk) ){
////				max_lk=LogY[m]->coeff(h-1,w-1);
////				level=m;
//////				matr=int(GAP_Y_STATE);
////
//////				std::cout<<"Y: level: "<<m<<":"<<max_lk<<"\n";
////			}
////		}
////	}
//
//	std::cout<<"\n";
//	std::cout<<level_max_lk<<":"<<max_lk<<":"<<"\n";
//
//	result.score=max_lk;
//	int len_MSA=level_max_lk;
//
//
//
//	//---------------------------------------------------------------
////	std::cout<<"TR:\n";
////	for(int i=0;i<d;i++){
////		std::cout<<"level: "<<i<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
//////				if(TR[i]->coeff(j,k)>0){
//////					std::cout<<"("<<j<<","<<k<<") "<<TR[i]->coeff(j,k)<<"  ";
////					printf("%2d  ",TR[i]->coeff(j,k));
//////				}
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
////	}
////
////	std::cout<<"\n";std::cout<<"\n";
////
////	std::cout<<"M:\n";
////	for(int i=0;i<d;i++){
////		std::cout<<"level: "<<i<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
//////				if(TR[i]->coeff(j,k)>0){
//////					std::cout<<"("<<j<<","<<k<<") "<<TR[i]->coeff(j,k)<<"  ";
////				printf("%+10.7f  ",LogM[i]->coeff(j,k));
//////				}
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
////	}
////
////	std::cout<<"\n";std::cout<<"\n";
////
////	std::cout<<"X:\n";
////	for(int i=0;i<d;i++){
////		std::cout<<"level: "<<i<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
//////				if(TR[i]->coeff(j,k)>0){
//////					std::cout<<"("<<j<<","<<k<<") "<<TR[i]->coeff(j,k)<<"  ";
////				printf("%+10.7f  ",LogX[i]->coeff(j,k));
//////				}
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
////	}
////
////	std::cout<<"\n";std::cout<<"\n";
////
////	std::cout<<"Y:\n";
////	for(int i=0;i<d;i++){
////		std::cout<<"level: "<<i<<"\n";
////		for(int j=0;j<h;j++){
////			for(int k=0;k<w;k++){
//////				if(TR[i]->coeff(j,k)>0){
//////					std::cout<<"("<<j<<","<<k<<") "<<TR[i]->coeff(j,k)<<"  ";
////				printf("%+10.7f  ",LogY[i]->coeff(j,k));
//////				}
////			}
////			std::cout<<"\n";
////		}
////		std::cout<<"\n";std::cout<<"\n";
////	}
////
////	std::cout<<"\n";std::cout<<"\n";
////
////
////	exit(EXIT_SUCCESS);
//	//---------------------------------------------------------------
//
//
//	//---------------------------------------------------------------
//	sequence_t<ALPHABET> traceback_path(len_MSA,ALPHABET::unknow);
//
//	int id1=h-1;
//	int id2=w-1;
//
//
////	std::cout<<"(id1,id2): "<<id1<<","<<id2<<"\n";
//
//
//	for(int i=len_MSA;i>0;i--){
//
////		std::cout<<"m:"<<i<<"; x,y: "<<id1<<","<<id2<<"; "<<TR[i]->coeff(id1,id2)<<"\n";
//
//
//
//		switch(TR[i]->coeff(id1,id2)){
//	        case MATCH_STATE:
//	            id1=id1-1;
//	            id2=id2-1;
//	            traceback_path[i-1]=ALPHABET::match;
//	            break;
//	        case GAP_X_STATE:
//	            id1=id1-1;
//	            traceback_path[i-1]=ALPHABET::gapX;
//	            break;
//	        case GAP_Y_STATE:
//	            id2=id2-1;
//	            traceback_path[i-1]=ALPHABET::gapY;
//	            break;
//	        default:
//
//	        	std::cout<<"(id1,id2): "<<id1<<","<<id2<<"="<<TR[i]->coeff(id1,id2)<<"\n";
//
//	        	error("ERROR in alignment_reconstruction !!!");
//	            exit(EXIT_FAILURE);
//	    }
//
////		std::cout<<"m:"<<i<<"-> "<<stringFromSequence<ALPHABET>(traceback_path)<<"\n";
//	}
//	//---------------------------------------------------------------
//
//
////	std::cout<<"tracepath: "<<stringFromSequence<ALPHABET>(traceback_path)<<"\n";
//
//	result.traceback_path=traceback_path;
//
//	fill_Pc_new3(result,traceback_path,PM,PX,PY);
//
//	result.MSA=build_MSA_PIP<ALPHABET>(traceback_path,result_L.MSA,result_R.MSA,fileTr);
//
//	update_fv_map(result,temp_fv_map,result.MSA);
//
//	delete_MatrixSparse3D(LogM,d);
//	delete_MatrixSparse3D(LogX,d);
//	delete_MatrixSparse3D(LogY,d);
//
//
//
//
//
//
//	return result;
//}
//=======================================================================================================
//DP-PIP
double factorial(double n)
{
    if (n == 0)
       return 1;
    return n * factorial(n - 1);
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void forward(PhyTree &tree,const ModelFactory<ALPHABET> *model_factory,double nu,ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,Eigen::MatrixXd &SM,Eigen::MatrixXd &SX,Eigen::MatrixXd &SY,Eigen::MatrixXd &PM,Eigen::MatrixXd &PX,Eigen::MatrixXd &PY,double *P0,std::map<std::string,Eigen::VectorXd> &temp_fv_map){

	int h=SM.rows();
	int w=SM.cols();

	Eigen::Matrix<score_t,ALPHABET::DIM+1,1> pi = model_factory->getPiPIP();

	sequence_t<ALPHABET> sL;
	sequence_t<ALPHABET> sR;
	sequence_t<ALPHABET> col_gap_L;
	sequence_t<ALPHABET> col_gap_R;

	double Pa,Pb,Pab;
	double pc0;
	double pc;
	double fv0;

	Eigen::VectorXd f;
	f.resize(ALPHABET::DIM+1);

	std::string s;

	col_gap_L=create_col_MSA_gap(result_L.MSA);
	col_gap_R=create_col_MSA_gap(result_R.MSA);

	/*
	if(!tree[0].isLeaf()){
		if(result_L.Pc.size()!=(h-1)){
			error("DIMENSION wrong\n");
		}
	}
	if(!tree[1].isLeaf()){
		if(result_R.Pc.size()!=(w-1)){
			error("DIMENSION wrong\n");
		}
	}
	*/

	for(int i=0;i<h;i++){

		if(i>0){
			sL=create_col_MSA(result_L.MSA,i-1);
		}

		for(int j=0;j<w;j++){

			if(j>0){
				sR=create_col_MSA(result_R.MSA,j-1);
			}

			if(i==0 && j==0){

				compute_fv(tree,result_L,result_R,f,col_gap_L,col_gap_R);
				fv0=f.dot(pi);
				s.append(stringFromSequence(col_gap_L));
				s.append(stringFromSequence(col_gap_R));
				temp_fv_map[s]=f;
				s.clear();

				pc0=compute_Pe(tree,fv0);

				SM(0,0)=1.0;
				SX(0,0)=1.0;
				SY(0,0)=1.0;

				PM(0,0)=0.0;
				PX(0,0)=0.0;
				PY(0,0)=0.0;

				*P0=exp(nu*(pc0-1.0));

				continue;
			}

			if(j==0){

				//if not in temp map compute otherwise...
				compute_fv(tree,result_L,result_R,f,sL,col_gap_R);
				fv0=f.dot(pi);
				s.append(stringFromSequence(sL));
				s.append(stringFromSequence(col_gap_R));
				temp_fv_map[s]=f;
				s.clear();

				pc=getPc(result_L,i-1);

				Pa=compute_Pa<ALPHABET>(tree,fv0,pc,pi,sL);

				SM(i,0)=0.0;
				SY(i,0)=0.0;
				PM(i,0)=0.0;
				PY(i,0)=0.0;

				PX(i,0)=Pa;
				SX(i,0)=Pa * SX(i-1,0);

			}else if(i==0){

				//if not in temp_map
				compute_fv(tree,result_L,result_R,f,col_gap_L,sR);
				fv0=f.dot(pi);
				s.append(stringFromSequence(col_gap_L));
				s.append(stringFromSequence(sR));
				temp_fv_map[s]=f;
				s.clear();

				pc=getPc(result_R,j-1);

				Pb=compute_Pb<ALPHABET>(tree,fv0,pc,pi,sR);

				SM(0,j)=0.0;
				SX(0,j)=0.0;
				PM(0,j)=0.0;
				PX(0,j)=0.0;

				PY(0,j)=Pb;
				SY(0,j)=Pb * SY(0,j-1);

			}else{

				compute_fv(tree,result_L,result_R,f,sL,sR);
				fv0=f.dot(pi);
				s.append(stringFromSequence(sL));
				s.append(stringFromSequence(sR));
				temp_fv_map[s]=f;
				s.clear();

				Pab=compute_Pab(tree,fv0);

				PM(i,j)=Pab;

				if(i==1 && j==1){
					SM(i,j)=Pab;
				}else{
					SM(i,j)=Pab *
						((double)SM(i-1,j-1)+
						(double)SX(i-1,j-1)+
						(double)SY(i-1,j-1));
				}
				//if not in temp_map compute
				compute_fv(tree,result_L,result_R,f,sL,col_gap_R);
				fv0=f.dot(pi);
				s.append(stringFromSequence(sL));
				s.append(stringFromSequence(col_gap_R));
				temp_fv_map[s]=f;
				s.clear();

				pc=getPc(result_L,i-1);

				Pa=compute_Pa<ALPHABET>(tree,fv0,pc,pi,sL);

				PX(i,j)=Pa;
				SX(i,j)=Pa *
						((double)SM(i-1,j) +
						(double)SX(i-1,j) +
						(double)SY(i-1,j));

				compute_fv(tree,result_L,result_R,f,col_gap_L,sR);
				fv0=f.dot(pi);
				s.append(stringFromSequence(col_gap_L));
				s.append(stringFromSequence(sR));
				temp_fv_map[s]=f;
				s.clear();

				pc=getPc(result_R,j-1);

				Pb=compute_Pb<ALPHABET>(tree,fv0,pc,pi,sR);

				PY(i,j)=Pb;
				SY(i,j)=Pb *
						((double)SM(i,j-1)+
						(double)SX(i,j-1)+
						(double)SY(i,j-1));

			}

		}
	}

}
//=======================================================================================================
//DP-PIP
void backward(std::string &trace_path,double *score,double nu,double P0,Eigen::MatrixXd &SM,Eigen::MatrixXd &SX,Eigen::MatrixXd &SY,Eigen::MatrixXd &PM,Eigen::MatrixXd &PX,Eigen::MatrixXd &PY,Eigen::MatrixXi &TR){

//#define LOG

	unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
	std::default_random_engine generator (seed);

	std::uniform_real_distribution<double> distribution(0.0,1.0);

	double number;

	int i=SM.rows()-1;
	int j=SM.cols()-1;

	double m;

	double Pm,Px,Py;
	double pm;
	double px;
//	double py;

	double Z;

	double lk;

	lk=1.0;

	m=1;

	Z=(SM(i,j)+SX(i,j)+SY(i,j));
	pm=SM(i,j)/Z;
	px=SX(i,j)/Z;
//	py=SY(i,j)/Z;

	number = distribution(generator);

	int STATUS;

	if(number<pm){
		STATUS=MATCH_STATE;
		TR(i,j)=STATUS;
		trace_path.append("1");
		i--;
		j--;
	}else if(number<(pm+px)){
		STATUS=GAP_X_STATE;
		TR(i,j)=STATUS;
		trace_path.append("2");
		i--;
	}else{
		STATUS=GAP_Y_STATE;
		TR(i,j)=STATUS;
		trace_path.append("3");
		j--;
	}

	bool cond=true;

	while(cond){

		//std::cout<<"i: "<<i<<" j: "<<j<<"\n";

		m=m+1;

#ifdef LOG
		switch(STATUS){
			case MATCH_STATE:
				Pm=log((double)SM(i,j))+log((double)PM(i+1,j+1));
				Px=log((double)SX(i,j))+log((double)PM(i+1,j+1));
				Py=log((double)SY(i,j))+log((double)PM(i+1,j+1));
				break;
			case GAP_X_STATE:
				Pm=log((double)SM(i,j))+log((double)PX(i+1,j));
				Px=log((double)SX(i,j))+log((double)PX(i+1,j));
				Py=log((double)SY(i,j))+log((double)PX(i+1,j));
				break;
			case GAP_Y_STATE:
				Pm=log((double)SM(i,j))+log((double)PY(i,j+1));
				Px=log((double)SX(i,j))+log((double)PY(i,j+1));
				Py=log((double)SY(i,j))+log((double)PY(i,j+1));
				break;
			default:
				error("ERROR in backward\n");
				break;
		}

		Z=(double)Pm+(double)Px+(double)Py;
		pm=(double)Pm/Z;
		px=(double)Px/Z;
		py=(double)Py/Z;

		if(i==0 && j!=0){
			pm=0.0;
			px=0.0;
			py=1.0;
		}
		if(i!=0 && j==0){
			pm=0.0;
			py=0.0;
			px=1.0;
		}

#else
		switch(STATUS){
			case MATCH_STATE:
				Pm=SM(i,j)*PM(i+1,j+1);
				Px=SX(i,j)*PM(i+1,j+1);
				Py=SY(i,j)*PM(i+1,j+1);
				lk*=PM(i+1,j+1);
				break;
			case GAP_X_STATE:
				Pm=SM(i,j)*PX(i+1,j);
				Px=SX(i,j)*PX(i+1,j);
				Py=SY(i,j)*PX(i+1,j);
				lk*=PM(i+1,j);
				break;
			case GAP_Y_STATE:
				Pm=SM(i,j)*PY(i,j+1);
				Px=SX(i,j)*PY(i,j+1);
				Py=SY(i,j)*PY(i,j+1);
				lk*=PM(i,j+1);
				break;
			default:
				error("ERROR in backward\n");
				break;
		}

		Z=Pm+Px+Py;
		pm=Pm/Z;
		px=Px/Z;
//		py=Py/Z;
#endif

		number = distribution(generator);

		if(number<pm){
			STATUS=MATCH_STATE;
			TR(i,j)=STATUS;
			trace_path.append("1");
			i--;
			j--;
		}else if(number<(pm+px)){
			STATUS=GAP_X_STATE;
			TR(i,j)=STATUS;
			trace_path.append("2");
			i--;
		}else{
			STATUS=GAP_Y_STATE;
			TR(i,j)=STATUS;
			trace_path.append("3");
			j--;
		}


		if(i==0 && j==0){
			cond=false;
		}


	};

#ifdef LOG

	switch(STATUS){
		case MATCH_STATE:
			*score=Pm+log(1)-log(factorial(m))+m*log(nu)+log(P0);
			break;
		case GAP_X_STATE:
			*score=Px+log(1)-log(factorial(m))+m*log(nu)+log(P0);
			break;
		case GAP_Y_STATE:
			*score=Py+log(1)-log(factorial(m))+m*log(nu)+log(P0);
			break;
		default:
			error("ERROR in backward\n");
			break;
	}

#else

	switch(STATUS){
		case MATCH_STATE:
			*score=lk;//Pm/Z;//+log(1)-log(factorial(m))+m*log(nu)+log(P0);
			break;
		case GAP_X_STATE:
			*score=lk;//Px/Z;//+log(1)-log(factorial(m))+m*log(nu)+log(P0);
			break;
		case GAP_Y_STATE:
			*score=lk;//Py/Z;//+log(1)-log(factorial(m))+m*log(nu)+log(P0);
			break;
		default:
			error("ERROR in backward\n");
			break;
	}

#endif


	trace_path=std::string(trace_path.rbegin(),trace_path.rend());

	std::cout<<*score<<"\n";
	//std::cout<<trace_path<<"\n";

}
//=======================================================================================================
//DP-PIP
/*
template <class ALPHABET>
void init_fv_map(const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences){

	if(this->isLeaf()){
		const std::string name = this->getName();

		typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>> ::const_iterator vect_iter;
		vect_iter it = std::find_if(sequences.begin(),sequences.end(),CompareFirst<ALPHABET>(name));

		if (it == sequences.end()){
			error("ERROR sequence name doesn't match any tree leaves");
			exit(EXIT_FAILURE);
		}

		std::string s=stringFromSequence<ALPHABET>(it->second);
		sequence_t<ALPHABET> seq=it->second;

		for(unsigned int i=0;i<seq.length();i++){
			Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
			x[seq[i].value()]=1.0;
			this->fv_map[s.substr(i,1)]=x;
			//this->fv_map[seq.substr(i,1)]=x;
		}

		Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
		x[ALPHABET::DIM]=1.0;

		this->fv_map[GAP_STR]=x;


	}else{

		this->children[0]->init_fv_map<ALPHABET>(sequences);
		this->children[1]->init_fv_map<ALPHABET>(sequences);

	}
}
*/
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void compute_fv(PhyTree &tree,ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,Eigen::VectorXd &fv,sequence_t<ALPHABET> sL,sequence_t<ALPHABET> sR){

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;

	MapIterator itL=result_L.fv_map.find(stringFromSequence<ALPHABET>(sL));
	if(itL == result_L.fv_map.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sL);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvL=itL->second;

	MapIterator itR=result_R.fv_map.find(stringFromSequence<ALPHABET>(sR));
	if(itR == result_R.fv_map.end()){
		std::cout<<"ERRORE in new_get_fv: "<<stringFromSequence<ALPHABET>(sR);
		exit(EXIT_FAILURE);
	}
	Eigen::VectorXd &fvR=itR->second;

	fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_fv_new(PhyTree &tree,std::map<std::string,Eigen::VectorXd> &map_L,std::map<std::string,Eigen::VectorXd> &map_R,std::map<std::string,Eigen::VectorXd> &map0,sequence_t<ALPHABET> &sL,sequence_t<ALPHABET> &sR,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;
	std::string s;
	double fv0;
	Eigen::VectorXd fv;

	s.append(stringFromSequence(sL));
	s.append(stringFromSequence(sR));

	MapIterator it=map0.find(s);
	if(it == map0.end()){

		MapIterator itL=map_L.find(stringFromSequence<ALPHABET>(sL));
		if(itL == map_L.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sL);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvL=itL->second;

		MapIterator itR=map_R.find(stringFromSequence<ALPHABET>(sR));
		if(itR == map_R.end()){
			std::cout<<"ERROR in compute_fv_new: "<<stringFromSequence<ALPHABET>(sR);
			exit(EXIT_FAILURE);
		}
		Eigen::VectorXd &fvR=itR->second;

		fv=(tree.get_left_child()->get_Pr()*fvL).cwiseProduct(tree.get_right_child()->get_Pr()*fvR);

	}else{
		fv=it->second;
	}


	fv0=fv.dot(pi);

	map0[s]=fv;

	return fv0;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
//double mydot(Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){
double mydot(double *a,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){
	double f;

	for(int k=0;k<(ALPHABET::DIM+1);k++){
		//f+=a[k]*pi.at(k);
		f+=pi(k);
	}

	return f;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
double compute_fv_new_fast(double **fv_array,PhyTree &tree,sequence_t<ALPHABET> &sL,sequence_t<ALPHABET> &sR,Eigen::MatrixXd &matFv,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi){

	/*
	int idx;
	sequence_t<ALPHABET> colMSA;
	Eigen::VectorXd fv;
	double fv0;

	colMSA.append(sL);
	colMSA.append(sR);

	idx=0;
	fv=recursive_fv(tree,matFv,colMSA,idx);

	fv0=fv.dot(pi);
	 */

	double fv0;
	fv0=mydot<ALPHABET>(fv_array[0],pi);
	//fv0=mydot<ALPHABET>(pi);

	return fv0;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void update_fv_map(ProgressivePIPResult<ALPHABET> &result,std::map<std::string,Eigen::VectorXd> &temp_fv_map,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> MSA){

	typedef typename std::map<std::string,Eigen::VectorXd>::iterator MapIterator;

	unsigned int len=MSA.at(0).second.length();

	for(unsigned int i=0;i<len;i++){
		sequence_t<ALPHABET> seq=create_col_MSA(MSA,i);
		std::string s=stringFromSequence<ALPHABET>(seq);
		MapIterator it=temp_fv_map.find(s);
		if(it == temp_fv_map.end()){
			std::cout<<"ERRORE in update_fv_map: "<<s<<"\n";
		}
		result.fv_map[s]=it->second;
	}

	sequence_t<ALPHABET> seq_gap=create_col_MSA_gap(MSA);
	std::string s_gap=stringFromSequence<ALPHABET>(seq_gap);
	MapIterator it=temp_fv_map.find(s_gap);
	if(it == temp_fv_map.end()){
		std::cout<<"ERRORE in update_fv_map: "<<s_gap<<"\n";
	}
	result.fv_map[s_gap]=it->second;

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static ProgressivePIPResult<ALPHABET> compute_DP_PIP_SB(ProgressivePIPResult<ALPHABET> &result_L,ProgressivePIPResult<ALPHABET> &result_R,PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,std::ostream& fileTr){

	//std::cout<<"ENTRO\n";

	ProgressivePIPResult<ALPHABET> result;

	int h=get_length_seq(result_L.MSA)+1;
	int w=get_length_seq(result_R.MSA)+1;

	Eigen::MatrixXd SM(h,w);
	Eigen::MatrixXd SX(h,w);
	Eigen::MatrixXd SY(h,w);

	Eigen::MatrixXi M(h,w);

	Eigen::MatrixXi TR(h,w);

	Eigen::MatrixXd PM(h,w);
	Eigen::MatrixXd PX(h,w);
	Eigen::MatrixXd PY(h,w);

	double P0;

	double score;

	std::string trace_path;

	std::map<std::string,Eigen::VectorXd> temp_fv_map;

	//std::cout<<"FORWARDING...\n";

	forward(tree,model_factory,nu,result_L,result_R,SM,SX,SY,PM,PX,PY,&P0,temp_fv_map);

	//std::cout<<"BACKWARDING...\n";

	backward(trace_path,&score,nu,P0,SM,SX,SY,PM,PX,PY,TR);
	result.score=score;

	//std::cout<<"FILLING...\n";

	fill_Pc_new(result,TR,PX,PY,trace_path.size());

	//==========================================
	fileTr<<">Traceback\n";
	fileTr<<trace_path;
	fileTr<<"\n";
	//==========================================

	result.traceback_path=sequenceFromString<ALPHABET>(trace_path);

	//std::cout<<"PRIMA BUILD\n";

	result.MSA=build_MSA_PIP<ALPHABET>(result.traceback_path,result_L.MSA,result_R.MSA,fileTr);

	//std::cout<<"PRIMA UPDATE\n";

	update_fv_map(result,temp_fv_map,result.MSA);

	//std::cout<<"DOPO UPDATE\n";

	return result;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static std::vector<ProgressivePIPResult<ALPHABET>> compute_DP_PIP_V_SB(std::vector<ProgressivePIPResult<ALPHABET>> &result_L,std::vector<ProgressivePIPResult<ALPHABET>> &result_R,PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,const std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,std::ostream& fileTr,int num_subopt){

	ProgressivePIPResult<ALPHABET> result;

	std::vector<ProgressivePIPResult<ALPHABET>> subopt;

	std::vector<ProgressivePIPResult<ALPHABET>> orig_result_L=result_L;
	std::vector<ProgressivePIPResult<ALPHABET>> orig_result_R=result_R;

	for(unsigned int i=0;i<result_L.size();i++){
		for(unsigned int j=0;j<result_R.size();j++){

			for(int k=0;k<num_subopt;k++){

				result=compute_DP_PIP_SB<ALPHABET>(orig_result_L.at(i),orig_result_R.at(j),tree,nu,model_factory,sequences,fileTr);

				orig_result_L=result_L;
				orig_result_R=result_R;

				subopt.push_back(result);

			}
		}
	}

	sortProgressivePIPResult(subopt);

	typename std::vector<ProgressivePIPResult<ALPHABET>>::const_iterator first = subopt.begin();
	typename std::vector<ProgressivePIPResult<ALPHABET>>::const_iterator last = subopt.begin()+num_subopt;
	std::vector<ProgressivePIPResult<ALPHABET>> result_SB(first,last);

	return result_SB;
}
//=======================================================================================================
//DP-PIP
//template <class ALPHABET>
//ProgressivePIPResult<ALPHABET> compute_DP_PIP_tree(PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,std::ostream& fileTr) throw (ProgressivePIPException){
//
//	ProgressivePIPResult<ALPHABET> result;
//
//	if(tree.isLeaf()){
//
//		add_sequence_to_vector(result.MSA,tree.getName(),sequences);
//
//		//=====================================================================
//		const std::string name = tree.getName();
//
//		typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>> ::const_iterator vect_iter;
//		vect_iter it = std::find_if(sequences.begin(),sequences.end(),CompareFirst<ALPHABET>(name));
//
//		if (it == sequences.end()){
//			error("ERROR sequence name doesn't match any tree leaves");
//			exit(EXIT_FAILURE);
//		}
//
//		std::string s=stringFromSequence<ALPHABET>(it->second);
//		sequence_t<ALPHABET> seq=it->second;
//
//
//
//		for(unsigned int i=0;i<seq.length();i++){
//			Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//			x[seq[i].value()]=1.0;
//			result.fv_map[s.substr(i,1)]=x;
//			//this->fv_map[seq.substr(i,1)]=x;
//		}
//
////		std::cout<<tree.getName()<<"\n";
////		PrintMap(result.fv_map);
////		std::cout<<"------------\n";
//
//		Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//		x[ALPHABET::DIM]=1.0;
//
//		result.fv_map[GAP_STR]=x;
//
//		result.lk_gap=0.0;
//		result.pc0=0.0;
//		//=====================================================================
//
//	}else{
//
//		if(tree.n_children() != 2){
//			error("only bifurcating trees allowed");
//		}
//
//		ProgressivePIPResult<ALPHABET> result_L = compute_DP_PIP_tree<ALPHABET>(tree[0],nu,model_factory,sequences,fileTr);
//		ProgressivePIPResult<ALPHABET> result_R = compute_DP_PIP_tree<ALPHABET>(tree[1],nu,model_factory,sequences,fileTr);
//
//		result=compute_DP_PIP<ALPHABET>(result_L,result_R,tree,nu,model_factory,sequences,fileTr);
//
//	}
//
//	return result;
//}
//=======================================================================================================
//DP-PIP
//@gamma distribution
template <class ALPHABET>
ProgressivePIPResult<ALPHABET> compute_DP_PIP_tree_fast_2(PhyTree &tree,const ModelFactory<ALPHABET> *model_factory,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,double gamma_rate) throw (ProgressivePIPException){

	ProgressivePIPResult<ALPHABET> result;

	if(tree.isLeaf()){

		const std::string name = tree.getName();

//		std::cout<<name<<"\n";
////		PrintVector(sequences);
//		PrintVector(result.MSA);
//		std::cout<<"\n";

		//@seq2str
//		add_sequence_to_vector(result.MSA,name,sequences);
		add_sequence_to_vector_string(result.MSAs,tree.getName(),sequences);

//		std::cout<<name<<"\n";
//////		PrintVector(sequences);
////		PrintVector(result.MSA);
////		//printVector_string(result.MSAs);
//
//		for(unsigned int i=0;i<result.MSAs.size();i++){
//			std::cout<<"key:"<<result.MSAs.at(i).first <<" val: "<<result.MSAs.at(i).second<<"\n";
//		}
//		std::cout<<"\n";

		//=====================================================================


//		typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>> ::const_iterator vect_iter;
//		vect_iter it = std::find_if(sequences.begin(),sequences.end(),CompareFirst<ALPHABET>(name));
//
//		if (it == sequences.end()){
//			error("ERROR sequence name doesn't match any tree leaves");
//			exit(EXIT_FAILURE);
//		}
//
//		std::string s=stringFromSequence<ALPHABET>(it->second);
//		sequence_t<ALPHABET> seq=it->second;
//
//		if(cmdlineopts.aa_flag){
//			perror("ERROR: not implemeted\n");
//			exit(EXIT_FAILURE);
//		}
//		if(cmdlineopts.codon_flag){
//			perror("ERROR: not implemeted\n");
//			exit(EXIT_FAILURE);
//		}
//		if(cmdlineopts.dna_flag){
//			for(int i=0;i<ALPHABET::DIM+1;i++){
//				Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//				x[i]=1.0;
//				result.fv_map[my_dna_alphabet[i]]=x;
//			}
//		}

//		std::cout<<tree.getName()<<"\n";
//		PrintMap(result.fv_map);
//		std::cout<<"------------\n";


//		for(unsigned int i=0;i<seq.length();i++){
//			Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//			x[seq[i].value()]=1.0;
//			result.fv_map[s.substr(i,1)]=x;
//			//this->fv_map[seq.substr(i,1)]=x;
//		}

//		std::cout<<tree.getName()<<"\n";
//		PrintMap(result.fv_map);
//		std::cout<<"------------\n";

//		Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//		x[ALPHABET::DIM]=1.0;
//
//		result.fv_map[GAP_STR]=x;

//		result.lk_gap=0.0;
//		result.pc0=0.0;
		//=====================================================================

	}else{

		if(tree.n_children() != 2){
			error("only bifurcating trees allowed");
		}

		ProgressivePIPResult<ALPHABET> result_L = compute_DP_PIP_tree_fast_2<ALPHABET>(tree[0],model_factory,sequences,gamma_rate);
		ProgressivePIPResult<ALPHABET> result_R = compute_DP_PIP_tree_fast_2<ALPHABET>(tree[1],model_factory,sequences,gamma_rate);

		result=compute_DP_PIP_optimized_2<ALPHABET>(result_L,result_R,tree,model_factory,gamma_rate);

	}

	return result;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
ProgressivePIPResult<ALPHABET> compute_DP_PIP_tree_fast(PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,Eigen::MatrixXd &matFv,std::ostream& fileTr) throw (ProgressivePIPException){

	ProgressivePIPResult<ALPHABET> result;

	if(tree.isLeaf()){

		add_sequence_to_vector(result.MSA,tree.getName(),sequences);

		//PrintVector(result.MSA);
		//std::cout<<"------------\n";


		//=====================================================================
//		const std::string name = tree.getName();
//
//		typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>> ::const_iterator vect_iter;
//		vect_iter it = std::find_if(sequences.begin(),sequences.end(),CompareFirst<ALPHABET>(name));
//
//		if (it == sequences.end()){
//			error("ERROR sequence name doesn't match any tree leaves");
//			exit(EXIT_FAILURE);
//		}
//
//		std::string s=stringFromSequence<ALPHABET>(it->second);
//		sequence_t<ALPHABET> seq=it->second;
//
//
//
//		for(unsigned int i=0;i<seq.length();i++){
//			Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//			x[seq[i].value()]=1.0;
//			result.fv_map[s.substr(i,1)]=x;
//			//this->fv_map[seq.substr(i,1)]=x;
//		}
//
//		Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
//		x[ALPHABET::DIM]=1.0;
//
//		result.fv_map[GAP_STR]=x;

		result.lk_gap=0.0;
		result.pc0=0.0;
		//=====================================================================

	}else{

		if(tree.n_children() != 2){
			error("only bifurcating trees allowed");
		}

		ProgressivePIPResult<ALPHABET> result_L = compute_DP_PIP_tree_fast<ALPHABET>(tree[0],nu,model_factory,sequences,matFv,fileTr);
		ProgressivePIPResult<ALPHABET> result_R = compute_DP_PIP_tree_fast<ALPHABET>(tree[1],nu,model_factory,sequences,matFv,fileTr);

//		result=compute_DP_PIP<ALPHABET>(result_L,result_R,tree,nu,model_factory,sequences,fileTr);
//		result=compute_DP_PIP_fast<ALPHABET>(result_L,result_R,tree,nu,model_factory,sequences,matFv,fileTr);
//		result=compute_DP_PIP_optimized<ALPHABET>(result_L,result_R,tree,nu,model_factory,sequences,matFv,fileTr);

	}

	return result;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
std::vector<ProgressivePIPResult<ALPHABET>> compute_DP_PIP_tree_SB(PhyTree &tree,double nu,const ModelFactory<ALPHABET> *model_factory,std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,std::ostream& fileTr,int num_subopt) throw (ProgressivePIPException){

	std::vector<ProgressivePIPResult<ALPHABET>> result;

	if(tree.isLeaf()){

		result.resize(1);
		add_sequence_to_vector(result[0].MSA,tree.getName(),sequences);

		//=====================================================================
		const std::string name = tree.getName();

		typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>> ::const_iterator vect_iter;
		vect_iter it = std::find_if(sequences.begin(),sequences.end(),CompareFirst<ALPHABET>(name));

		if (it == sequences.end()){
			error("ERROR sequence name doesn't match any tree leaves");
			exit(EXIT_FAILURE);
		}

		std::string s=stringFromSequence<ALPHABET>(it->second);
		sequence_t<ALPHABET> seq=it->second;

		for(unsigned int i=0;i<seq.length();i++){
			Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
			x[seq[i].value()]=1.0;
			result[0].fv_map[s.substr(i,1)]=x;
			//this->fv_map[seq.substr(i,1)]=x;
		}

		Eigen::VectorXd x=Eigen::VectorXd::Zero(ALPHABET::DIM+1);
		x[ALPHABET::DIM]=1.0;

		result[0].fv_map[GAP_STR]=x;
		//=====================================================================

	}else{

		if(tree.n_children() != 2){
			error("only bifurcating trees allowed");
		}

		std::vector<ProgressivePIPResult<ALPHABET>> result_L = compute_DP_PIP_tree_SB<ALPHABET>(tree[0],nu,model_factory,sequences,fileTr,num_subopt);
		std::vector<ProgressivePIPResult<ALPHABET>> result_R = compute_DP_PIP_tree_SB<ALPHABET>(tree[1],nu,model_factory,sequences,fileTr,num_subopt);

		result=compute_DP_PIP_V_SB<ALPHABET>(result_L,result_R,tree,nu,model_factory,sequences,fileTr,num_subopt);

	}

	return result;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
void check_max_lk(std::vector<ProgressivePIPResult<ALPHABET>> &resultPIP,std::map<std::string,std::string> &true_seqs){

	for(unsigned int k=0;k<resultPIP.size();k++){

		ProgressivePIPResult<ALPHABET> &res=resultPIP.at(k);

		bool all_true=true;

		typedef typename std::vector<std::pair<std::string,sequence_t<ALPHABET>>>::iterator vect_iterator;
		for (vect_iterator iter = res.MSA.begin(); iter != res.MSA.end(); iter++){

			std::pair<std::string,sequence_t<ALPHABET>> p = (*iter);
			std::string label=p.first;
			sequence_t<ALPHABET> s=p.second;

			typedef typename std::map<std::string,std::string>::iterator MapIterator;
			MapIterator itR=true_seqs.find(label);

			if(stringFromSequence(s).compare(itR->second)!=0){
				all_true=false;
			}

		}

		printf("%18.17lf\n",res.score);

		if(all_true){
			std::cout<<"ESATTO\n";
		}

	}

}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
std::vector<ProgressivePIPResult<ALPHABET>> extract_N_best(std::vector<ProgressivePIPResult<ALPHABET>> &vec,unsigned int n){

	std::vector<ProgressivePIPResult<ALPHABET>> best;

//	std::cout<<"vec size: "<<vec.size()<<"\n";

	for(unsigned int k=0;k<n;k++){

		double score=vec[0].score;
		unsigned int idx=0;
		for(unsigned int i=1;i<vec.size();i++){
			if(vec[i].score>score){
				idx=i;
				score=vec[i].score;
			}
		}

		best.push_back(vec[idx]);
		vec.erase(vec.begin() + idx);

//		std::cout<<"vec size: "<<vec.size()<<"\n";

	}

	return best;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
static std::vector<ProgressivePIPResult<ALPHABET>> compute_DP_PIP_cross(	std::vector<ProgressivePIPResult<ALPHABET>> &result_L,
																																							std::vector<ProgressivePIPResult<ALPHABET>> &result_R,
																																							PhyTree &tree,
																																							const ModelFactory<ALPHABET> *model_factory,
																																							double tau,
																																							double nu,
																																							double gamma_rate,
																																							int num_subopt,
																																							bool local_tree,
																																							bool stoch_backtracking_flag){

	std::vector<ProgressivePIPResult<ALPHABET>> result;
	std::vector<ProgressivePIPResult<ALPHABET>> subopt;
	std::vector<ProgressivePIPResult<ALPHABET>> orig_result_L=result_L;
	std::vector<ProgressivePIPResult<ALPHABET>> orig_result_R=result_R;

	for(unsigned int i=0;i<result_L.size();i++){
		for(unsigned int j=0;j<result_R.size();j++){


//			result=compute_DP_PIP_optimized_2<ALPHABET>(orig_result_L.at(i),orig_result_R.at(j),tree,model_factory,gamma_rate,num_subopt);

			if(stoch_backtracking_flag){
				//@SB
				result=compute_DP_PIP_optimized_3_SB<ALPHABET>(orig_result_L.at(i),orig_result_R.at(j),tree,model_factory,tau,nu,gamma_rate,num_subopt,local_tree);
			}else{

				result=compute_DP_PIP_optimized_3<ALPHABET>(orig_result_L.at(i),orig_result_R.at(j),tree,model_factory,tau,nu,gamma_rate,num_subopt,local_tree);
			}

			orig_result_L=result_L;
			orig_result_R=result_R;

			for(unsigned int z=0;z<result.size();z++){
				subopt.push_back(result.at(z));
			}
		}
	}


//	printf("size %d\n",(int)subopt.size());

	unsigned int N;
	N=result.size() < (unsigned int)num_subopt ? result.size() : (unsigned int)num_subopt;
	std::vector<ProgressivePIPResult<ALPHABET>> result_v=extract_N_best(subopt,N);

	return result_v;
}
//=======================================================================================================
//DP-PIP
template <class ALPHABET>
std::vector<ProgressivePIPResult<ALPHABET>> compute_DP_PIP_tree_cross(PhyTree &tree,
																																						const ModelFactory<ALPHABET> *model_factory,
																																						std::vector<std::pair<std::string,sequence_t<ALPHABET>>> &sequences,
																																						double tau,
																																						double nu,
																																						double gamma_rate,
																																						int num_subopt,
																																						bool local_tree,
																																						bool stoch_backtracking_flag) throw (ProgressivePIPException){

	std::vector<ProgressivePIPResult<ALPHABET>> result;

	if(tree.isLeaf()){

		result.resize(1);
		add_sequence_to_vector_string(result[0].MSAs,tree.getName(),sequences);

	}else{

		if(tree.n_children() != 2){
			error("only bifurcating trees allowed");
		}

		std::vector<ProgressivePIPResult<ALPHABET>>  result_L = compute_DP_PIP_tree_cross<ALPHABET>(tree[0],model_factory,sequences,tau,nu,gamma_rate,num_subopt,local_tree,stoch_backtracking_flag);
		std::vector<ProgressivePIPResult<ALPHABET>>  result_R = compute_DP_PIP_tree_cross<ALPHABET>(tree[1],model_factory,sequences,tau,nu,gamma_rate,num_subopt,local_tree,stoch_backtracking_flag);

		result=compute_DP_PIP_cross<ALPHABET>(result_L,result_R,tree,model_factory,tau,nu,gamma_rate,num_subopt,local_tree,stoch_backtracking_flag);

	}

	return result;
}
//=======================================================================================================
//******************************************************************
//******************************************************************
template <class ALPHABET>
void check_compute_Pa(PhyTree &tree,double fv_ij,double pC,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,sequence_t<ALPHABET> &sq){

	double v;
	v=compute_Pa<ALPHABET>(tree,fv_ij,pC,pi,sq);

	std::cout<<v<<"\n";

}

template <class ALPHABET>
void check_compute_Pb(PhyTree &tree,double fv_ij,double pC,Eigen::Matrix<score_t,ALPHABET::DIM+1,1> &pi,sequence_t<ALPHABET> &sq){

	double v;
	v=compute_Pb<ALPHABET>(tree,fv_ij,pC,pi,sq);

	std::cout<<v<<"\n";

}

void check_compute_Pe(PhyTree &tree,double fv_ij){

	double v;
	v=compute_Pe(tree,fv_ij);

	std::cout<<v<<"\n";

}

void check_compute_Pab(PhyTree &tree,double fv_ij){

	double v;
	v=compute_Pab(tree,fv_ij);

	std::cout<<v<<"\n";

}
//******************************************************************
//******************************************************************



#endif /* PROGRESSIVEPIP_H_ */
